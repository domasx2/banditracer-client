 /*
  * Copyright (c) 2010 James Brantly
  *
  * Permission is hereby granted, free of charge, to any person
  * obtaining a copy of this software and associated documentation
  * files (the "Software"), to deal in the Software without
  * restriction, including without limitation the rights to use,
  * copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following
  * conditions:
  *
  * The above copyright notice and this permission notice shall be
  * included in all copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  * OTHER DEALINGS IN THE SOFTWARE.
  */

(function(globalFunctionEval) {

	var Yabble = function() {
		throw "Synchronous require() is not supported.";
	};

	Yabble.unit = {};

	var _moduleRoot = '',
		_modules,
		_callbacks,
		_fetchFunc,
		_timeoutLength = 20000,
		_mainProgram;

	var isWebWorker = this.importScripts !== undefined;


	var head = !isWebWorker && document.getElementsByTagName('head')[0];

	// Shortcut to native hasOwnProperty
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	// A for..in implementation which uses hasOwnProperty and fixes IE non-enumerable issues
	if ((function() {for (var prop in {hasOwnProperty: true}) { return prop; }})() == 'hasOwnProperty') {
		var forIn = function(obj, func, ctx) {
			for (var prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					func.call(ctx, prop);
				}
			}
		};
	}
	else {
		var ieBadProps = [
	      'isPrototypeOf',
	      'hasOwnProperty',
	      'toLocaleString',
	      'toString',
	      'valueOf'
		];

		var forIn = function(obj, func, ctx) {
			for (var prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					func.call(ctx, prop);
				}
			}

			for (var i = ieBadProps.length; i--;) {
				var prop = ieBadProps[i];
				if (hasOwnProperty.call(obj, prop)) {
					func.call(ctx, prop);
				}
			}
		};
	}

	// Array convenience functions
	var indexOf = function(arr, val) {
		for (var i = arr.length; i--;) {
			if (arr[i] == val) { return i; }
		}
		return -1;
	};

	var removeWhere = function(arr, func) {
		var i = 0;
		while (i < arr.length) {
			if (func.call(null, arr[i], i) === true) {
				arr.splice(i, 1);
			}
			else {
				i++;
			}
		}
	};

	var combinePaths = function(relPath, refPath) {
		var relPathParts = relPath.split('/');
		refPath = refPath || '';
		if (refPath.length && refPath.charAt(refPath.length-1) != '/') {
			refPath += '/';
		}
		var refPathParts = refPath.split('/');
		refPathParts.pop();
		var part;
		while (part = relPathParts.shift()) {
			if (part == '.') { continue; }
			else if (part == '..'
				&& refPathParts.length
				&& refPathParts[refPathParts.length-1] != '..') { refPathParts.pop(); }
			else { refPathParts.push(part); }
		}
		return refPathParts.join('/');
	};

	// Takes a relative path to a module and resolves it according to the reference path
	var resolveModuleId = Yabble.unit.resolveModuleId = function(relModuleId, refPath) {
		if (relModuleId.charAt(0) != '.') {
			return relModuleId;
		}
		else {
			return combinePaths(relModuleId, refPath);
		}
	};

	// Takes a module's ID and resolves a URI according to the module root path
	var resolveModuleUri = function(moduleId) {
		if (moduleId.charAt(0) != '.') {
			return _moduleRoot+moduleId+'.js';
		}
		else {
			return this._resolveModuleId(moduleId, _moduleRoot)+'.js';
		}
	};

	// Returns a module object from the module ID
	var getModule = function(moduleId) {
		if (!hasOwnProperty.call(_modules, moduleId)) {
			return null;
		}
		return _modules[moduleId];
	};

	// Adds a callback which is executed when all deep dependencies are loaded
	var addCallback = function(deps, cb) {
		_callbacks.push([deps.slice(0), cb]);
	};

	// Generic implementation of require.ensure() which takes a reference path to
	// use when resolving relative module IDs
	var ensureImpl = function(deps, cb, refPath) {
		var unreadyModules = [];

		for (var i = deps.length; i--;) {
			var moduleId = resolveModuleId(deps[i], refPath),
				module = getModule(moduleId);

			if (!areDeepDepsDefined(moduleId)) {
				unreadyModules.push(moduleId);
			}
		}

		if (unreadyModules.length) {
			addCallback(unreadyModules, function() {
				cb(createRequireFunc(refPath));
			});
			queueModules(unreadyModules);
		}
		else {
			setTimeout(function() {
				cb(createRequireFunc(refPath));
			}, 0);
		}
	};

	// Creates a require function that is passed into module factory functions
	// and require.ensure() callbacks. It is bound to a reference path for
	// relative require()s
	var createRequireFunc = function(refPath) {
		var require = function(relModuleId) {
			var moduleId = resolveModuleId(relModuleId, refPath),
				module = getModule(moduleId);

			if (!module) {
				throw "Module not loaded";
			}
			else if (module.error) {
				throw "Error loading module";
			}

			if (!module.exports) {
				module.exports = {};
				var moduleDir = moduleId.substring(0, moduleId.lastIndexOf('/')+1),
					injects = module.injects,
					args = [];

				for (var i = 0, n = injects.length; i<n; i++) {
					if (injects[i] == 'require') {
						args.push(createRequireFunc(moduleDir));
					}
					else if (injects[i] == 'exports') {
						args.push(module.exports);
					}
					else if (injects[i] == 'module') {
						args.push(module.module);
					}
				}

				module.factory.apply(null, args);
			}
			return module.exports;
		};

		require.ensure = function(deps, cb) {
			ensureImpl(deps, cb, refPath);
		};

		if (_mainProgram != null) {
			require.main = getModule(_mainProgram).module;
		}

		return require;
	};

	// Begins loading modules asynchronously
	var queueModules = function(moduleIds) {
		for (var i = moduleIds.length; i--;) {
			var moduleId = moduleIds[i],
				module = getModule(moduleId);

			if (module == null) {
				module = _modules[moduleId] = {};
				_fetchFunc(moduleId);
			}
		}
	};

	// Returns true if all deep dependencies are satisfied (in other words,
	// can more or less safely run the module factory function)
	var areDeepDepsDefined = function(moduleId) {
		var visitedModules = {};
		var recurse = function(moduleId) {
			if (visitedModules[moduleId] == true) { return true; }
			visitedModules[moduleId] = true;
			var module = getModule(moduleId);
			if (!module || !module.defined) { return false; }
			else {
				var deps = module.deps || [];
				for (var i = deps.length; i--;) {
					if (!recurse(deps[i])) {
						return false;
					}
				}
				return true;
			}
		};
		return recurse(moduleId);
	};

	// Checks dependency callbacks and fires as necessary
	var fireCallbacks = function() {
		var i = 0;
		while (i<_callbacks.length) {
			var deps = _callbacks[i][0],
				func = _callbacks[i][1],
				n = 0;
			while (n<deps.length) {
				if (areDeepDepsDefined(deps[n])) {
					deps.splice(n, 1);
				}
				else {
					n++;
				}
			}
			if (!deps.length) {
				_callbacks.splice(i, 1);
				if (func != null) {
					setTimeout(func, 0);
				}
			}
			else {
				i++;
			}
		}
	};

	// Load an unwrapped module using XHR and eval()
	var loadModuleByEval = _fetchFunc = function(moduleId) {
		var timeoutHandle;

		var errorFunc = function() {
			var module = getModule(moduleId);
			if (!module.defined) {
				module.defined = module.error = true;
				fireCallbacks();
			}
		};

		var xhr = this.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
		var moduleUri = resolveModuleUri(moduleId);
		xhr.open('GET', moduleUri, true);
		xhr.onreadystatechange = function() {
			if (xhr.readyState === 4) {
				clearTimeout(timeoutHandle);
				if (xhr.status == 200 || xhr.status === 0) {
					var moduleCode = xhr.responseText,
						deps = determineShallowDependencies(moduleCode),
						moduleDir = moduleId.substring(0, moduleId.lastIndexOf('/')+1),
						moduleDefs = {};
					for (var i = deps.length; i--;) {
						deps[i] = resolveModuleId(deps[i], moduleDir);
					}
					try {
						moduleDefs[moduleId] = globalFunctionEval('\r\n' + moduleCode + '\r\n');
					} catch (e) {
						if (e instanceof SyntaxError) {
							var msg = 'Syntax Error: ';
							if (e.lineNumber) {
								msg += 'line ' + (e.lineNumber - 581);
							} else {
								console.log('GameJs tip: use Firefox to see line numbers in Syntax Errors.');
							}
							msg += ' in file ' + moduleUri;
							console.log(msg);
						}
						throw e;
					}

					Yabble.define(moduleDefs, deps);
				}
				else {
					errorFunc();
				}
			}
		};

		timeoutHandle = setTimeout(errorFunc, _timeoutLength);

		xhr.send(null);
	};

	// Used by loadModuleByEval and by the packager. Determines shallow dependencies of
	// a module via static analysis. This can currently break with require.ensure().
	var determineShallowDependencies = Yabble.unit.determineShallowDependencies = function(moduleCode) {
		// TODO: account for comments
		var deps = {}, match, unique = {};

		var requireRegex = /(?:^|[^\w\$_.])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')\s*\)/g;
		while (match = requireRegex.exec(moduleCode)) {
			var module = eval(match[1]);
			if (!hasOwnProperty.call(deps, module)) {
				deps[module] = true;
			}
		}

		var ensureRegex = /(?:^|[^\w\$_.])require.ensure\s*\(\s*(\[("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*'|\s*|,)*\])/g;
		while (match = ensureRegex.exec(moduleCode)) {
			var moduleArray = eval(match[1]);
			for (var i = moduleArray.length; i--;) {
				var module = moduleArray[i];
				delete deps[module];
			}
		}

		var depsArray = [];
		forIn(deps, function(module) {
			depsArray.push(module);
		});

		return depsArray;
	};

	// Load a wrapped module via script tags
	var loadModuleByScript = function(moduleId) {
		var scriptEl = document.createElement('script');
		scriptEl.type = 'text/javascript';
		scriptEl.src = resolveModuleUri(moduleId);

		var useStandard = !!scriptEl.addEventListener,
			timeoutHandle;

		var errorFunc = function() {
			postLoadFunc(false);
		};

		var loadFunc = function() {
			if (useStandard || (scriptEl.readyState == 'complete' || scriptEl.readyState == 'loaded')) {
				postLoadFunc(getModule(moduleId).defined);
			}
		};

		var postLoadFunc = function(loaded) {
			clearTimeout(timeoutHandle);

			if (useStandard) {
				scriptEl.removeEventListener('load', loadFunc, false);
				scriptEl.removeEventListener('error', errorFunc, false);
			}
			else {
				scriptEl.detachEvent('onreadystatechange', loadFunc);
			}

			if (!loaded) {
				var module = getModule(moduleId);
				if (!module.defined) {
					module.defined = module.error = true;
					fireCallbacks();
				}
			}
		};

		if (useStandard) {
			scriptEl.addEventListener('load', loadFunc, false);
			scriptEl.addEventListener('error', errorFunc, false);
		}
		else {
			scriptEl.attachEvent('onreadystatechange', loadFunc);
		}

		timeoutHandle = setTimeout(errorFunc, _timeoutLength);

		head.appendChild(scriptEl);
	};

	var normalizeTransport = function() {
		var transport = {modules: []};
		var standardInjects = ['require', 'exports', 'module'];
		if (typeof arguments[0] == 'object') { // Transport/D
			transport.deps = arguments[1] || [];
			var moduleDefs = arguments[0];
			forIn(moduleDefs, function(moduleId) {
				var module = {
					id: moduleId
				};

				if (typeof moduleDefs[moduleId] == 'function') {
					module.factory = moduleDefs[moduleId];
					module.injects = standardInjects;
				}
				else {
					module.factory = moduleDefs[moduleId].factory;
					module.injects = moduleDefs[moduleId].injects || standardInjects;
				}
				transport.modules.push(module);
			});
		}
		else { // Transport/C
			transport.deps = arguments[1].slice(0);
			removeWhere(transport.deps, function(dep) {
				return indexOf(standardInjects, dep) >= 0;
			});

			transport.modules.push({
				id: arguments[0],
				factory: arguments[2],
				injects: arguments[1]
			});
		}
		return transport;
	};

	// Set the uri which forms the conceptual module namespace root
	Yabble.setModuleRoot = function(path) {
		if (this.window && !(/^http(s?):\/\//.test(path))) {
			var href = window.location.href;
			href = href.substr(0, href.lastIndexOf('/')+1);
			path = combinePaths(path, href);
		}

		if (path.length && path.charAt(path.length-1) != '/') {
			path += '/';
		}

		_moduleRoot = path;
	};
	Yabble.getModuleRoot = function() {
	   return _moduleRoot;
	}
	// Set a timeout period for async module loading
	Yabble.setTimeoutLength = function(milliseconds) {
		_timeoutLength = milliseconds;
	};

	// Use script tags with wrapped code instead of XHR+eval()
	Yabble.useScriptTags = function() {
		_fetchFunc = loadModuleByScript;
	};

	// Define a module per various transport specifications
	Yabble.def = Yabble.define = function() {
		var transport = normalizeTransport.apply(null, arguments);

		var unreadyModules = [],
			definedModules = [];

		var deps = transport.deps;

		for (var i = transport.modules.length; i--;) {
			var moduleDef = transport.modules[i],
				moduleId = moduleDef.id,
				module = getModule(moduleId);

			if (!module) {
				module = _modules[moduleId] = {};
			}
			module.module = {
				id: moduleId,
				uri: resolveModuleUri(moduleId)
			};

			module.defined = true;
			module.deps = deps.slice(0);
			module.injects = moduleDef.injects;
			module.factory = moduleDef.factory;
			definedModules.push(module);
		}

		for (var i = deps.length; i--;) {
			var moduleId = deps[i],
				module = getModule(moduleId);

			if (!module || !areDeepDepsDefined(moduleId)) {
				unreadyModules.push(moduleId);
			}
		}

		if (unreadyModules.length) {
			setTimeout(function() {
				queueModules(unreadyModules);
			}, 0);
		}

		fireCallbacks();
	};

	Yabble.isKnown = function(moduleId) {
		return getModule(moduleId) != null;
	};

	Yabble.isDefined = function(moduleId) {
		var module = getModule(moduleId);
		return !!(module && module.defined);
	};

	// Do an async lazy-load of modules
	Yabble.ensure = function(deps, cb) {
		ensureImpl(deps, cb, '');
	};

	// Start an application via a main program module
	Yabble.run = function(program, cb) {
		program = _mainProgram = resolveModuleId(program, '');
		Yabble.ensure([program], function(require) {
			require(program);
			if (cb != null) { cb(); }
		});
	};

	// Reset internal state. Used mostly for unit tests.
	Yabble.reset = function() {
		_mainProgram = null;
		_modules = {};
		_callbacks = [];

		// Built-in system module
		Yabble.define({
			'system': function(require, exports, module) {}
		});
	};

	Yabble.reset();

	// Export to the require global
	if (isWebWorker) {
		self.require = Yabble;
	} else {
		window.require = Yabble;
	}
})(function(code) {
   with (this.importScripts ? self : window) {
      return (new Function('require', 'exports', 'module', code));
   };
});
/* This file has been generated by yabbler.js */
require.define({
"world": function(require, exports, module) {
var utils = require('./utils');
var vec=utils.vec;
var arr=utils.arr;
var weapon_descriptions=require('./weapon_descriptions');
var combatracer=require('./combatracer');
var car_descriptions=require('./car_descriptions');
var cars=require('./cars');
var weapons=require('./weapons');
var animation=require('./animation');
var props=require('./props');
var settings=require('./settings');
var gamejs=require('gamejs');
var sounds=require('./sounds');
var renderer=require('./renderer');
var buffs=require('./buffs');
var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
var engine = require('./engine');

radians=math.radians;
degrees=math.degrees;



var MODE_CLIENT = exports.MODE_CLIENT = 1;
var MODE_SERVER = exports.MODE_SERVER = 2;
var MODE_STANDALONE = exports.MODE_STANDALONE = 3;

var World = exports.World = function(parameters){
    
    var par_list = ['width',
                    'height',
                    'ai_waypoints',
                    'checkpoints',
                    'start_positions',
                    'mode'];
    
    engine.utils.process_parameters(parameters, par_list);
    this.parameters = parameters;
    
    World.superConstructor.apply(this, [parameters]);
    
    this.width = parameters.width;
    this.height = parameters.height;
    this.size = [this.width, this.height];
    this.ai_waypoints = parameters.ai_waypoints;
    this.checkpoints = parameters.checkpoints;
    this.start_positions = parameters.start_positions;
    this.mode = parameters.mode;
    
    this.max_waypoint=0;
    for(var no in this.ai_waypoints) this.max_waypoint=Math.max(this.max_waypoint, no);
    
    this.max_checkpoint=0;
    for(var no in this.checkpoints) this.max_checkpoint=Math.max(this.max_checkpoint, no);
};

gamejs.utils.objects.extend(World, engine.World);

World.prototype.spawn_animation = function(anim_name, position, follow_obj){
    this.create(animation.AnimationObject, utils.copy(animation.animations[anim_name], {'position':position,
                                                                                        'follow_obj':follow_obj}));
};

World.prototype.play_sound = function(filename, position){
    if(settings.get('sound')) engine.World.prototype.play_sound.apply(this, ['sounds/fx/'+filename, position]);
};

exports.build_world = function(level, mode) {
    //level - data property of level module

    var phys_scale = settings.get('PHYS_SCALE');

    var dict = level.dict;

    //CAR POSITIONS
    var start_positions = {};
    level.start_positions.forEach(function(pos) {
        start_positions[pos.n] = {
            'x' : (pos.p[0] + 30) / phys_scale,
            'y' : (pos.p[1] + 30) / phys_scale,
            'angle' : pos.a
        }
    });
    //WAYPOINTS
    var ai_waypoints = {};
    level.ai_waypoints.forEach(function(wp) {
        ai_waypoints[wp.n] = {
            'x' : (wp.p[0] + 20) / phys_scale,
            'y' : (wp.p[1] + 20) / phys_scale
        };
    });
    //CHECKPOINTS
    var checkpoints = {}, pt1, pt2;
    level.checkpoints.forEach(function(c) {
        pt1 = [c.p[0] / phys_scale, c.p[1] / phys_scale];
        pt2 = [(c.p[0] + 280) / phys_scale, (c.p[1] + 280) / phys_scale];
        ;
        checkpoints[c.n] = {
            'pt1' : pt1,
            'pt2' : pt2,
            'width' : pt2[0] - pt1[0],
            'height' : pt2[1] - pt1[1],
            'center' : [(pt1[0] + pt2[0]) / 2, (pt1[1] + pt2[1]) / 2]
        };
    });
    //BUILD WORLD

    var width = level.size[0] / phys_scale;
    var height = level.size[1] / phys_scale;

    var world = new World({
        'width' : width,
        'height' : height,
        'ai_waypoints' : ai_waypoints,
        'checkpoints' : checkpoints,
        'start_positions' : start_positions,
        'mode' : mode
    });

    //BUILD PROPS
    var position, angle, s, sz, sz2, ws;
    level.props.forEach(function(prop) {
        angle = math.normaliseDegrees(prop.a);
        s = renderer.cache.getPropSprite(dict[prop.f], angle);
        sz = s.getSize();
        s = renderer.cache.props[dict[prop.f]].orig;
        sz2 = s.getSize();
        ws = [sz2[0] / phys_scale, sz2[1] / phys_scale];
        world.create(props.BoxProp, {
            'filename' : dict[prop.f],
            'position' : [((prop.p[0] + sz[0] / 2) / phys_scale), ((prop.p[1] + sz[1] / 2) / phys_scale)],
            'angle' : angle,
            'size' : ws
        });
    });
    return world;
}


}}, ["utils", "weapon_descriptions", "combatracer", "car_descriptions", "cars", "weapons", "animation", "props", "settings", "gamejs", "sounds", "renderer", "buffs", "engine"]);/* This file has been generated by yabbler.js */
require.define({
"json": function(require, exports, module) {
var JSON;
if (!JSON) {
    exports.JSON=JSON = {};
}

(function () {
    "use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        exports.stringify=JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        exports.parse=JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.
            console.log(text);
            throw new SyntaxError('JSON.parse');
        };
    }

// Augment the basic prototypes if they have not already been augmented.
// These forms are obsolete. It is recommended that JSON.stringify and
// JSON.parse be used instead.
/*
    if (!Object.prototype.toJSONString) {
        Object.prototype.toJSONString = function (filter) {
            return JSON.stringify(this, filter);
        };
        Object.prototype.parseJSON = function (filter) {
            return JSON.parse(this, filter);
        };
    }*/
}());

}}, []);/* This file has been generated by yabbler.js */
require.define({
"resources": function(require, exports, module) {
exports.props=['9tires.png','3tires.png', 'tire.png'];
exports.cars=['bandit_blue.png','bandit_green.png','bandit_red.png','bandit_yellow.png',
              'big_wheel.png', 'cannon_shell.png',
              'brawler_blue.png','brawler_green.png','brawler_red.png','brawler_yellow.png','bullet.png','missile.png',
              'racer_blue.png','racer_green.png','racer_red.png','racer_yellow.png','wheel.png',
              'sandbug_blue.png','sandbug_green.png','sandbug_red.png','sandbug_yellow.png', 'missile_homing.png',
              'samaritan_blue.png','samaritan_green.png','samaritan_red.png','samaritan_yellow.png', 
              'plasma_projectile.png',
              'thunderbolt_blue.png', 'thunderbolt_green.png', 'thunderbolt_yellow.png', 'thunderbolt_red.png'];
exports.tiles=['sand.png','grass.png', 'snow.png'];
exports.animations=['explosion.png','explosion_small.png', 'sw.png', 'smoke.png', 'heal.png', 'fire64.png',
					'forcefield.png', 'explosion2.png'];
exports.ui=['controls.png','garage.png','guncar.png','logo.png','key_bg.png'];
exports.statics=['mine.png', 'samaritan_big.png', 'brawler_big.png', 'racer_big.png', 'bandit_big.png', 'icon_machinegun.png', 'icon_mine.png', 'icon_missiles.png', 'ico_damage.png', 'ico_ammo.png',
                 '0stars.png', '1stars.png', '2stars.png', '3stars.png', '4stars.png', '5stars.png', 'sandbug_big.png', 'icon_fix.png', 'icon_sw.png', 'icon_missiles_homing.png',
                 'ico_nos.png', 'ico_oil.png', 'oil_spill.png', 'icon_plasma.png', 'icon_flame.png',
                 'icon_shield.png', 'icon_cannon.png', 'thunderbolt_big.png'];
exports.levels=['snowpeakcircuit', 'drycircuit', 'deathvalley', 'spiralraceway', 'greenring', 
			   'frogfoot', '2_icemanloops', '2_vultureplains', '2_queersands', '1_bloodbathlane',
			   '3_bullpen', '3_hunter_end', '3_lullabycircuit', '3_peril_flats', '3_radiator'];
exports.decals=[,'dideliskampas.png','ilgas.png','trumpas.png','issisakojimas.png','kryzius.png','lenktas.png',
                'paprastas.png','siauras.png','siaurasiplatu.png','siaurejantis1.png','siaurejantis2.png','sonaslenktas1.png',
                'sonaslenktas2.png','startbar.png','susikerta.png','uglyduckling.png', 'white_bar.png',
                'arrow2.png', 'arrow3.png', 'arrow4.png', 'arrow5.png', 'arrow.png'];
exports.sound_fx=['bullet_impact_metal.wav','bullet_impact_soft.wav','button_click.wav','explosion.wav','machinegun_shot.wav','missile_launch.wav','thud.wav', 'shockwave.wav', 'repair.wav',
                    'plasma_cannon.wav', 'fire_cannon.wav'];
//exports.sound_engine=['loop_0.wav', 'loop_1.wav', 'loop_2.wav','loop_3.wav','loop_4.wav','loop_5.wav' ];
}}, []);/* This file has been generated by yabbler.js */
require.define({
"leagues": function(require, exports, module) {
exports[0]={'name':'Begginer League',
            'tracks':['drycircuit', 'snowpeakcircuit', 'greenring', 'frogfoot', '1_bloodbathlane'],
            'bots':['Bob', 'CatLady', 'Dominator'],
            'reward_1':1000,
            'reward_2':600,
            'reward_3':300};
            
exports[1] = {'name':'Veteran League',
	            'tracks':['spiralraceway', 'deathvalley', '2_icemanloops', '2_vultureplains', '2_queersands'],
	            'bots':['HotShot', 'TheDude', 'Ratman'],
	            'reward_1':2000,
	            'reward_2':1000,
	            'reward_3':500};
            
exports[2] = {'name':'Badass League',
			  'tracks':['3_bullpen', '3_hunter_end', '3_lullabycircuit', '3_peril_flats', '3_radiator'],
			  'bots':['Bulldog', 'JC', 'PainKid'],
			  'reward_1':3500,
			  'reward_2':2000,
			  'reward_3':1000};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"weapons": function(require, exports, module) {
var gamejs = require('gamejs');
var utils = require('./utils');
var sounds = require('./sounds');
var buffs = require('./buffs');
var vec=utils.vec;
var arr=utils.arr;
var weapon_descriptions=require('./weapon_descriptions');
var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
var buffs = require('./buffs');
var engine = require('./engine');
var settings = require('./settings');
var box2d= engine.box2d;

radians=math.radians;
degrees=math.degrees;

var animation = require('./animation');

var fireAtNearbyTargets = function(){
    var i, c, len;
    var cars = this.world.get_objects_by_tag('car');
    for(i = 0; i < cars.length; i++){
        c = cars[i];
        if(c.id != this.car.id){
            len = vectors.distance(this.car.get_position(), c.get_position());
            if(len <= 10){
                return true;
            }
        }
    }
    return false;
};

var fireAtRearTargets = function(){
    var i, c, len, angle;
    var cars = this.world.get_objects_by_tag('car');
    for(i = 0; i < cars.length; i++){
        c = cars[i];
        if(c.id!=this.car.id){
            len = vectors.distance(this.car.get_position(), c.get_position());
            angle = degrees(vectors.angle([0, 1], this.car.get_local_point(c.get_position())));
            if(len < 20 && angle < 15){
                return true;
            }
        }
    }
    return false;
};

var fireAtFrontTargets = function(){
    var i, c, len, angle;
    var cars = this.world.get_objects_by_tag('car');
    for(i = 0; i < cars.length; i++){
        c = cars[i];
        if(c.id != this.car.id){
            len = vectors.distance(this.car.get_position(), c.get_position());
            angle = degrees(vectors.angle([0, -1], this.car.get_local_point(c.get_position())));
            if(len < 50 && angle < 15){
                return true;
            }
        }
    }
    return false;  
};

var Projectile = exports.Projectile = function(pars){
    /*
    pars:
    weapon   - weapon object
    position - [x, y]
    angle    - degrees
    width    - meters
    height   - meters
    damage   - damage, points
    */
   
    pars.fixed_rotation = true;
    pars.bullet = true;
    pars.linear_damping = 0;
    pars.angular_damping = 0;
    //pars.sensor = true;
    Projectile.superConstructor.apply(this, [pars]);
    this.weapon   = pars.weapon;
    this.speed    = pars.speed;
    this.damage   = pars.damage;
    this.position = pars.position;
    this.angle    = pars.angle;
    this.speed    = pars.speed;
    this.damage   = pars.damage;
    this.car      = pars.car;
    this.world    = this.car.world;
    this.add_tag('projectile');
    this.spent    = false;
    this.set_speed(this.speed);
};

gamejs.utils.objects.extend(Projectile, engine.Entity);


engine.register_class(Projectile);

Projectile.prototype.impact = function(obj, cpoint, direction) {
    if(obj.has_tag('solid') && (!this.spent)) {
        this.world.destroy(this);
        if(obj.has_tag('car')) {
            obj.apply_damage(this.damage, this.car);
            
        }
        if(this.onimpact)
            this.onimpact(obj);
        this.spent = true;
    }
};

Projectile.prototype.update = function(msDuration) {
    var pos = this.get_position();
    if((pos[0] < 0) || (pos[1] < 0) || (pos[0] > this.car.world.width) || (pos[1] > this.car.world.height)) {
        this.world.destroy(this);
    }
};


var Mine = exports.Mine = function(pars){
    /*
    pars:
    car   - car object
    position - [x, y]
    */
    pars.size = [2, 2];
    pars.sensor = true;
    pars.angle = 0;
    pars.fixed_rotation = true;
    Mine.superConstructor.apply(this, [pars]);
    this.car=pars.car;
    this.damage=pars.damage;
    this.add_tag('mine');
};

gamejs.utils.objects.extend(Mine, engine.Entity);

engine.register_class(Mine);

Mine.prototype.impact=function(obj, cpoint, direction){
        if((obj.has_tag('car'))){
            var i, c;
            this.world.get_objects_by_tag('car').forEach(function(c){
                if((c == obj) || (vectors.distance(this.position, c.get_position())<=8)){
                    c.apply_damage(this.damage, this.car);
                    utils.push(c, this, 15, 200);
                    if(this.onimpact) this.onimpact();
                }
            }, this);
            this.world.spawn_animation('explosion', this.position);
            this.world.play_sound('explosion.wav', this.position);
            this.world.destroy(this);
        }
    };

Mine.prototype.draw = function(renderer){
    renderer.drawStatic('mine.png', this.position);
};

var OilPuddle = exports.OilPuddle = function(pars){
    /*
    pars:
    car   - car object
    position - [x, y]
    */
    pars.size = [4.5, 3.5];
    pars.angle = 0;
    pars.sensor = true;
    pars.fixed_rotation = true;
    
    OilPuddle.superConstructor.apply(this, [pars]);   
    this.damage = pars.damage;
    this.car = this.parameters.car;
    this.drawn = false;
};

gamejs.utils.objects.extend(OilPuddle, engine.Entity);

engine.register_class(OilPuddle);

OilPuddle.prototype.impact = function(obj, cpoint, direction){
    if(obj.has_tag('car')){
        this.world.create(buffs.SlipDebuff, {'duration':weapon_descriptions.Oil.duration,
                                              'object':obj});
    }
};

OilPuddle.prototype.draw=function(renderer){
    if(!this.drawn){
        var sprite = renderer.cache.getStaticSprite('oil_spill.png');
        var sz = sprite.getSize();
        var phys_scale = settings.get('PHYS_SCALE');
        var pos= [this.position[0] * phys_scale, this.position[1] * phys_scale];
        renderer.background.blit(sprite, [pos[0]-sz[0]/2, pos[1]-sz[1]/2]);
        this.drawn=true;
    }
};


var Missile=exports.Missile=function(pars){
    /*
    pars:
    car   - car obj;
    position - [x, y]
    angle    - degrees
    */

    pars.size = [0.5, 2.5];
    pars.density = 0.3;
    this.tts=50;
    Missile.superConstructor.apply(this, [pars]);
    this.world.play_sound('missile_launch.wav', this.position);
};

gamejs.utils.objects.extend(Missile, Projectile);

engine.register_class(Missile);
    
Missile.prototype.onimpact = function(){
    var pos = this.get_position();
    this.world.spawn_animation('explosion',pos);
    this.world.play_sound('explosion.wav', pos);
};

Missile.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('missile.png', this.get_position(), this.get_angle());
};

Missile.prototype.update = function(msDuration){
    this.tts -= msDuration;
    if(this.tts<0){
        this.world.spawn_animation('smoke', this.get_world_point([0, 1.25]));
        this.tts = 50;
    }
};



var NapalmFlame = exports.NapalmFlame = function(pars) {
    
    //how often damage can be reapplied on the same flame
    pars.size = [4, 4];
    pars.sensor = true;
    pars.fixed_rotation = true;
    
    NapalmFlame.superConstructor.apply(this, [pars]);

    this.car = pars.car;
    this.life = 6000;
    this.damage = pars.damage;
    this.burn_cooldown = 200;
    this.burning = {};
    this.collapse = false;
    this.animation = new animation.Animation({
        'filename' : 'fire64.png',
        'duration' : 800,
        'repeat' : true
    });
    this.animation.resize(30, 64, 800);
};

gamejs.utils.objects.extend(NapalmFlame, engine.Entity);

engine.register_class(NapalmFlame);

NapalmFlame.prototype.impact = function(obj, cpoint, direction){
    if(obj.has_tag('car')){
        if(!this.burning[obj.id]){
        	obj.apply_damage(this.damage, this.car);
        	this.burning[obj.id] = this.burn_cooldown;
        }
    }
};
    
NapalmFlame.prototype.update = function(msDuration){
	for(var id in this.burning){
		this.burning[id] -= msDuration;
		if(this.burning[id] <0){
			delete this.burning[id];
		}
	}
	this.animation.update(msDuration);
	this.life -= msDuration;
	if(this.life <= 800 && (!this.collapse)){
		this.animation.resize(64, 30, 800);
		this.collapse=true;
	}
	
	if(this.life < 0) this.world.destroy(this);
};

NapalmFlame.prototype.draw = function(renderer){
    this.animation.draw(renderer, this.get_position());
};

var HomingMissile = exports.HomingMissile = function(pars){
    
    HomingMissile.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(HomingMissile, Missile);

engine.register_class(HomingMissile);

HomingMissile.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('missile_homing.png', 
                                     this.get_position(),
                                     this.get_angle());
};
    
HomingMissile.prototype.update = function(msDuration){
    //spawn smoke
    this.tts -= msDuration;
    if(this.tts < 0 ){
        this.world.spawn_animation('smoke', this.get_world_point([0, 1.25]));
        this.tts = 50;
    }
    
    //drive the missile towards nearest front facing target
    var target = null;
    var target_distance = 1000000;
    this.world.objects_by_tag.car.forEach(function(car){
        var cpos = this.get_local_point(car.get_position());
        if(cpos[1]<0){
            var distance = gamejs.utils.vectors.distance(this.get_position(), car.get_position());
            if(target_distance > distance){
                target = car;
                target_distance = distance;
                
            }
        }
        return false;
    }, this);
    
    if(target){
        var cpos = this.get_local_point(target.get_position());
        var angle = gamejs.utils.math.radians(this.get_angle());
        if(cpos[0] < 0){
            angle += gamejs.utils.math.radians((-90 / 700) * msDuration);
        }else if(cpos[0] > 0){
            angle += gamejs.utils.math.radians((90 / 700) * msDuration);
        }
        this.set_angle(gamejs.utils.math.degrees(angle));
        
        this.set_speed(this.speed);
    }
    
};

var Bullet = exports.Bullet = function(pars){
    /*
    pars:
    car   - car obj
    position - [x, y]
    angle    - degrees
    */
    pars.size = [0.3, 0.8];
    pars.density = 0.1;
    Bullet.superConstructor.apply(this, [pars]);
    this.color = '#FFD800';
    this.world.play_sound('machinegun_shot.wav', this.position);
};

gamejs.utils.objects.extend(Bullet, Projectile);

engine.register_class(Bullet);

Bullet.prototype.onimpact = function(obj) {
    var pos = this.get_position();
    this.world.spawn_animation('small_explosion', pos);
    if(obj.has_tag('car')){
        this.world.play_sound('bullet_impact_metal.wav', pos);
    }else if(obj.has_tag('prop')){
        this.world.play_sound('bullet_impact_soft.wav', pos);
    }
};

Bullet.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('bullet.png', 
                                     this.get_position(), 
                                     this.get_angle());
};

var PlasmaProjectile = exports.PlasmaProjectile = function(pars){
    /*
    pars:
    car   - car obj
    position - [x, y]
    angle    - degrees
    */
    pars.size = [0.6, 2.5];
    pars.sensor = true;
    PlasmaProjectile.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(PlasmaProjectile, Projectile);
engine.register_class(PlasmaProjectile);

PlasmaProjectile.prototype.impact = function(obj, cpoint, direction){
    if((obj.has_tag('car') || obj.has_tag('prop'))){
        if(obj.has_tag('car')){
            obj.apply_damage(this.damage, this.car);
        }
        if(this.onimpact) this.onimpact(obj);
    }
};

PlasmaProjectile.prototype.onimpact = function(obj){
    var pos = this.get_position();
    this.world.spawn_animation('small_explosion', pos);
};

PlasmaProjectile.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('plasma_projectile.png', 
                                      this.get_position(), 
                                      this.get_angle());
};

var Weapon = exports.Weapon = function(pars){
    pars = this.pars = utils.copy(pars, utils.copy(weapon_descriptions[pars.type], {}));
    Weapon.superConstructor.apply(this, [pars]);
    this.type = pars.type;
    this.add_tag('weapon');
    this.car = pars.car;
    this.car[pars.slot] = this;
    this.ammo_capacity = pars.ammo_capacity+(pars.ammo_upgrades*pars.ammo_upgrade);
    this.fire_rate = pars.fire_rate;
    this.cooldown = 0;
    this.ammo = 0;
    this.damage = pars.damage+(pars.damage_upgrades*pars.damage_upgrade);
    this.speed = pars.speed;
    this.projectile = pars.projectile;
};
gamejs.utils.objects.extend(Weapon, engine.Object);

engine.register_class(Weapon);

Weapon.prototype.update = function(msDuration) {
    if(this.cooldown > 0) this.cooldown -= msDuration;
};

Weapon.prototype.reload = function(){
    this.ammo = this.ammo_capacity;
};

Weapon.prototype._fire = function(){
    if(this.ammo && this.cooldown<=0){
        this.fire();
        this.ammo--;
        this.cooldown = this.fire_rate;
    }
};

Weapon.prototype.AI = function(){ return false; };
    
Weapon.prototype.fire = function(){
    var pos = this.get_fire_pos();
    this.world.create(exports[this.projectile], {'position':pos,
                                                 'damage':this.damage,
                                                 'weapon':this,
                                                 'speed':this.speed,
                                                 'angle':this.car.get_angle(),
                                                 'car':this.car});     
};
    
Weapon.prototype.get_fire_pos = function(){
    var retv = this.car.get_world_point([0, -(this.car.size[1]/2+3)]);
    return retv;
};


var RepairKit = exports.RepairKit = function(pars){
    RepairKit.superConstructor.apply(this, [pars]);
    this.add_tag('repairkit');
};

gamejs.utils.objects.extend(RepairKit, Weapon);

engine.register_class(RepairKit);
    
RepairKit.prototype.AI = function() {
    if(this.car.health <= this.car.max_health / 2){
        return true;
    }
    return false;
};
    
RepairKit.prototype._fire = function() {
    if(this.ammo&&(this.cooldown<=0) && (this.car.health<this.car.max_health)){
        this.fire();
        this.ammo--;
        this.cooldown = this.fire_rate;
    }
};
    
RepairKit.prototype.fire = function(){
    this.world.spawn_animation('heal', this.car.get_position(), this.car);
    this.world.play_sound('repair.wav', this.car.get_position());
    this.car.apply_damage(-this.damage, this.car);
};


var Machinegun=exports.Machinegun=function(pars){
    /*
    pars:
    car - car object this weapon belongs to
    */
    Machinegun.superConstructor.apply(this, [pars]);
    this.add_tag('machinegun');
    this.ofst_x = -0.5;
};

gamejs.utils.objects.extend(Machinegun, Weapon);

engine.register_class(Machinegun);

Machinegun.prototype.AI = fireAtFrontTargets;

Machinegun.prototype.get_fire_pos = function(){
    this.ofst_x *= -1;
    return this.car.get_world_point([this.ofst_x, -(this.car.parameters.size[1] / 2 + 0.9)]);
};

var PlasmaCannon = exports.PlasmaCannon = function(pars){

    PlasmaCannon.superConstructor.apply(this, [pars]);
    
    this.add_tag('plasmacannon');

    this.AI=fireAtFrontTargets;
};

gamejs.utils.objects.extend(PlasmaCannon, Weapon);

engine.register_class(PlasmaCannon);

PlasmaCannon.prototype.fire = function(){
    var pos = this.car.get_world_point([-0.6, -(this.car.parameters.size[1]/2+3)]);
    this.world.create(exports[this.projectile], {'position':pos,
                                                'damage':this.damage,
                                                'speed':this.speed,
                                                'weapon':this,
                                                'angle':this.car.get_angle(),
                                                'car':this.car});
    if(this.ammo){
        var pos = this.car.get_world_point([0.6, -(this.car.parameters.size[1]/2+3)]);
        this.world.create(exports[this.projectile], {'position':pos,
                                            'damage':this.damage,
                                            'speed':this.speed,
                                            'weapon':this,
                                            'angle':this.car.get_angle(),
                                            'car':this.car});
        this.ammo--;
    }
    this.world.play_sound('plasma_cannon.wav');
};

var NOS = exports.NOS = function(pars){
    NOS.superConstructor.apply(this, [pars]);
    this.duration = this.parameters.duration;
    this.add_tag('nos');
};

gamejs.utils.objects.extend(NOS, Weapon);

engine.register_class(NOS);
   
NOS.prototype.AI = function(){
    if(this.car.get_speed_KMH() > this.car.get_max_speed()-10){
        return true;
    }
    return false;
};

NOS.prototype.fire = function(){
    this.world.create(buffs.EngineBuff,{'duration':this.duration,
                                        'value':this.damage,
                                        'object':this.car});
};

var ShockwaveGenerator = exports.ShockwaveGenerator = function(pars){
    ShockwaveGenerator.superConstructor.apply(this, [pars]);
    this.add_tag('shockwave')
};

gamejs.utils.objects.extend(ShockwaveGenerator, Weapon);

engine.register_class(ShockwaveGenerator);

ShockwaveGenerator.prototype.AI = fireAtNearbyTargets;
    
ShockwaveGenerator.prototype.fire = function(){
    this.world.get_objects_by_tag('solid').forEach(function(obj){
        if(obj.id != this.car.id){
            var tp = this.car.get_position();
            var cp= obj.get_position();
            var d = vectors.distance(tp, cp);
            if(d <= 12){
                obj.apply_damage(this.damage, this.car);
                utils.push(obj, this.car, 40, 500);
            };
        }
    }, this);
    
    this.world.play_sound('shockwave.wav', this.car.get_position());
    this.world.spawn_animation('shockwave', this.car.get_position(), this.car);
    
};

var MineLauncher = exports.MineLauncher=function(pars){
    MineLauncher.superConstructor.apply(this, [pars]);
    this.add_tag('minelauncher');
};

gamejs.utils.objects.extend(MineLauncher, Weapon);

engine.register_class(MineLauncher);
    
MineLauncher.prototype.AI = fireAtRearTargets;
    
MineLauncher.prototype.get_fire_pos=function(){
    return this.car.get_world_point([0, (this.car.parameters.size[1] / 2 + 3)]);  
};

var MissileLauncher = exports.MissileLauncher = function(pars){
    MineLauncher.superConstructor.apply(this, [pars]);
    this.add_tag('missilelauncher');
};

gamejs.utils.objects.extend(MissileLauncher, Weapon);

engine.register_class(MissileLauncher);
   
MissileLauncher.prototype.AI = fireAtFrontTargets;
    
MissileLauncher.prototype.get_fire_pos=function(){
    return this.car.get_world_point([0, -(this.car.parameters.size[1] / 2 + 3)]);    
};

var Oil = exports.Oil = function(pars){
    Oil.superConstructor.apply(this, [pars]);
    this.add_tag('oil');
};

gamejs.utils.objects.extend(Oil, Weapon);

engine.register_class(Oil);
    
Oil.prototype.AI = fireAtRearTargets;

Oil.prototype.get_fire_pos = function(){
    return this.car.get_world_point([0, (this.car.parameters.size[1]/2+3)]);    
};

var Shield=exports.Shield=function(pars){
    Shield.superConstructor.apply(this, [pars]);
    this.duration = pars.duration;
    this.add_tag('shield');
};

gamejs.utils.objects.extend(Shield, Weapon);

engine.register_class(Shield);
    
Shield.prototype.AI = function(){
    if(this.car.health <= this.car.max_health/3){
        return true;
    }
    return false;
};
    
Shield.prototype._fire=function(){
    if(this.ammo && (this.cooldown <= 0)){
        this.fire();
        this.ammo--;
        this.cooldown = this.fire_rate;
    }
};
    
Shield.prototype.fire=function(){
    this.car.world.create(buffs.InvulnerabilityBuff, {'object':this.car});
};



var TankShell = exports.TankShell = function(pars){
    pars.size = [0.8, 1.5];
    TankShell.superConstructor.apply(this, [pars]);
	this.add_tag('tank_shell');
	this.world.play_sound('fire_cannon.wav', this.position);
};

gamejs.utils.objects.extend(TankShell, Projectile);

engine.register_class(TankShell);
	
TankShell.prototype.impact = function(obj, cpoint, direction){
    if((obj.has_tag('car') || obj.has_tag('prop')) && (!this.spent)){
        this.world.destroy(this);
        this.world.get_objects_by_tag('car').forEach(function(car){
            if(car.id != this.car.id){
                var tp = this.get_position();
                var cp = car.get_position();
                var d = vectors.distance(tp, cp);
                if(d <= 5){
                    car.apply_damage(this.damage, this.car);
                    this.world.create(buffs.SlipDebuff, {'duration':500,
                                                         'object':car});
                    var fvect = vectors.unit(vectors.subtract(cp, tp));
                    fvect=vectors.multiply(fvect, 200);
                    car.apply_impulse(fvect, car.get_position());
                };
            }
        }, this);
        
        this.spent = true;
        this.world.spawn_animation('explosion2', this.get_position());
        this.world.play_sound('explosion.wav', this.position);
    }
};

TankShell.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('cannon_shell.png',  this.get_position(), this.get_angle());
};


}}, ["gamejs", "utils", "sounds", "buffs", "weapon_descriptions", "engine", "settings", "animation"]);/* This file has been generated by yabbler.js */
require.define({
"engine": function(require, exports, module) {


game = require('./engine/game');

exports.initialize_images = function(retv){
    exports.preload_list = exports.preload_list.concat(retv);    
}

exports.register_class = function(fn){
    game.register_class(fn);
};

exports.get_class_by_id = function(id){
    return game.get_class_by_id(id);
};

exports.get_id_by_class = function(fn){
    return game.get_id_by_class(fn);
};

exports.World = require('./engine/world').World;
exports.Object = require('./engine/object').Object;
exports.Entity = require('./engine/entity').Entity;

var sound = require('./engine/sound');
exports.Sound = sound.Sound;
exports.SoundObject = sound.SoundObject;
exports.initialize_sounds = sound.initialize;
exports.play_sound = sound.play;

exports.utils = require('./engine/utils');
exports.box2d = require('./engine/box2d');



}}, ["engine/game", "engine/world", "engine/object", "engine/entity", "engine/sound", "engine/utils", "engine/box2d"]);/* This file has been generated by yabbler.js */
require.define({
"controllers": function(require, exports, module) {
var gamejs=require('gamejs');
var vectors=gamejs.utils.vectors;
var utils=require('./utils');
var combatracer=require('./combatracer');
var vec=utils.vec;
var arr=utils.arr;

var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
radians=math.radians;
degrees=math.degrees;

var STEER_NONE=exports.STEER_NONE=0;
var STEER_RIGHT=exports.STEER_RIGHT=1;
var STEER_LEFT=exports.STEER_LEFT=2;

var ACC_NONE=exports.ACC_NONE=0;
var ACC_ACCELERATE=exports.ACC_ACCELERATE=1;
var ACC_BRAKE=exports.ACC_BRAKE=2;

var DIFFICULTY={1:{'FIRE_CHANCE':0.20,
                   'MAX_SPEED_BUFF':0,
                   'MAX_SPEED_DEBUFF':30},
             	2:{'FIRE_CHANCE':0.5,
                   'MAX_SPEED_BUFF':10,
                   'MAX_SPEED_DEBUFF':25},
                3:{'FIRE_CHANCE':0.6,
                   'MAX_SPEED_BUFF':20,
                   'MAX_SPEED_DEBUFF':10},
                4:{'FIRE_CHANCE':0.6,
                   'MAX_SPEED_BUFF':20,
                   'MAX_SPEED_DEBUFF':10}}

exports.AIController=function(car, world, scene){
    car.max_steer_angle = car.max_steer_angle*1.1;
    car.turn_msec=50;
    this.difficulty=DIFFICULTY[combatracer.game.player.singleplayer.difficulty];
    this.scene = scene;
    this.car = car;
    this.world = world;
    this.cur_wp = 1;
    this.ceasfire = false;
    this.ceasfire_cur_cooldown = 0;
    this.ceasfire_cooldown = 1000;
    
    this.stationary=0; //how many seconds is this car stationary?
    
    this.update=function(keys_down, ms){
        if(!this.car.alive)return;
         this.car.accelerate=ACC_ACCELERATE;
        var wp = this.world.ai_waypoints[this.cur_wp];
        var nwp = this.world.ai_waypoints[this.cur_wp < this.world.max_waypoint ? this.cur_wp + 1 : 1];

        var speed=this.car.get_speed_KMH();

        //cheats
        var player_pos = this.scene.player_car.get_race_position();
        var mypos = this.car.get_race_position();

        //if player is ahead, gradually increase speed to up to extra 10 km/h
        if(player_pos < mypos){
            if(car.mod_speed < this.difficulty.MAX_SPEED_BUFF){
                car.mod_speed += 5*(ms/1000);
            }
        }else if(player_pos > mypos){
            //if car is ahead, gradually decrease speed down to -25 km/h
            if(car.mod_speed > -this.difficulty.MAX_SPEED_DEBUFF){
                car.mod_speed -= 5 * (ms / 1000);
            }
        }

        //if car speed is below 6 km/h for 3 seconds, most likely it is stuck. teleport it to next waypoint
        if(speed < 6){
            if(this.car.alive){
                this.stationary += ms;
                if(this.stationary > 3000){
                    this.car.teleport([wp.x, wp.y]);
                    this.stationary=0;
                }
            }else {this.stationary=0;}
        }
        else this.stationary=0;

        var carpos = this.car.get_position();
        var lp = this.car.get_local_point([wp.x, wp.y]);
        var len=vectors.distance(carpos, [wp.x, wp.y]);
        var len2=vectors.distance(carpos, [nwp.x, nwp.y]);

        /*switch to next waypont if :
          1)closer than 5 meters to it
          2)it is behind the car, but closer than 35 meters
        */
        var angle = gamejs.utils.math.normaliseDegrees(degrees(vectors.angle([0, -1], lp)));

        if(len < 10 || (lp[1] > 0 && len < 35)){
            if(this.cur_wp < this.world.max_waypoint) this.cur_wp++;
            else this.cur_wp = 1;
            wp =this.world.ai_waypoints[this.cur_wp];
        }
        if(angle > 10){
            if(lp[0] > 0)this.car.steer=STEER_RIGHT;
            else this.car.steer = STEER_LEFT;
        } else this.car.steer = STEER_NONE;

        //is this bot shooting?
        if(this.ceasfire_cur_cooldown <= 0){
            this.ceasfire = Math.random() >this.difficulty.FIRE_CHANCE ? true : false;
            this.ceasfire_cur_cooldown = this.ceasfire_cooldown;
        }else{
            this.ceasfire_cur_cooldown-= ms;
        }
        
        //fire weapons if needed        
        (['front_weapon', 'util', 'rear_weapon']).forEach(function(wtype){
            if(this.car[wtype]) this.car['fire_'+wtype] = this.ceasfire ? false : this.car[wtype].AI();
        }, this);
    }

    return this;
}

exports.MultiplayerController=function(){
    this.bindings={accelerate:gamejs.event.K_UP, //up
                   brake:gamejs.event.K_DOWN,      //down
                   steer_left:gamejs.event.K_LEFT, //left
                   steer_right:gamejs.event.K_RIGHT, //right
                   fire_front_weapon:gamejs.event.K_x, //fire front weapon
                   fire_rear_weapon:gamejs.event.K_v,
                   fire_util:gamejs.event.K_c}; //fire rear weapon

    this.actions={'accelerate':ACC_NONE,
                  'steer':STEER_NONE,
                  'fire_front_weapon':false,
                  'fire_rear_weapon':false,
                  'fire_util':false};


    this.update=function(keys_down, ms){
        var changed=false;

        var accelerate, steer, fire_front_weapon, fire_rear_weapon, fire_util;

        if(keys_down[this.bindings.accelerate]){
            accelerate=ACC_ACCELERATE;
        }else if(keys_down[this.bindings.brake]){
            accelerate=ACC_BRAKE;
        }else{
            accelerate=ACC_NONE;
        }

        if(keys_down[this.bindings.steer_right]){
            steer=STEER_RIGHT;
        }else if(keys_down[this.bindings.steer_left]){
            steer=STEER_LEFT;
        }else{
            steer=STEER_NONE;
        }

        if(keys_down[this.bindings.fire_front_weapon]) fire_front_weapon=true;
        else fire_front_weapon=false;

        if(keys_down[this.bindings.fire_rear_weapon]) fire_rear_weapon=true;
        else fire_rear_weapon=false;
        
        if(keys_down[this.bindings.util]) fire_util=true;
        else fire_util=false;

        if(!(accelerate===this.actions.accelerate)){
            this.actions.accelerate=accelerate;
            changed=true;
        }
        if(!(steer===this.actions.steer)){
            this.actions.steer=steer;
            changed=true;
        }
        if(!(fire_front_weapon===this.actions.fire_front_weapon)){
            this.actions.fire_front_weapon=fire_front_weapon;
            changed=true;
        }
        if(!(fire_rear_weapon===this.actions.fire_rear_weapon)){
            this.actions.fire_rear_weapon=fire_rear_weapon;
            changed=true;
        }
        if(!(fire_util===this.actions.fire_util)){
            this.actions.fire_util=fire_util;
            changed=true;
        }
        return changed;

    };

    return this;

};

exports.PlayerCarController=function(car){
    this.car=car;
    this.bindings={accelerate:gamejs.event.K_UP, //up
                   brake:gamejs.event.K_DOWN,      //down
                   steer_left:gamejs.event.K_LEFT, //left
                   steer_right:gamejs.event.K_RIGHT, //right
                   fire_front_weapon:gamejs.event.K_x, //fire front weapon
                   fire_rear_weapon:gamejs.event.K_v,
                   fire_util:gamejs.event.K_c}; //fire rear weapon

    this.update=function(keys_down, ms){
        if(!this.car.alive)return;
        if(keys_down[this.bindings.accelerate]){
            this.car.accelerate=ACC_ACCELERATE;
        }else if(keys_down[this.bindings.brake]){
            this.car.accelerate=ACC_BRAKE;
        }else{
            this.car.accelerate=ACC_NONE;
        }

        if(keys_down[this.bindings.steer_right]){
            this.car.steer=STEER_RIGHT;
        }else if(keys_down[this.bindings.steer_left]){
            this.car.steer=STEER_LEFT;
        }else{
            this.car.steer=STEER_NONE;
        }

        if(keys_down[this.bindings.fire_front_weapon]) this.car.fire_front_weapon=true;
        else this.car.fire_front_weapon=false;

        if(keys_down[this.bindings.fire_rear_weapon]) this.car.fire_rear_weapon=true;
        else this.car.fire_rear_weapon=false;
        
        if(keys_down[this.bindings.fire_util]) this.car.fire_util=true;
        else this.car.fire_util=false;

    };

    return this;
};

}}, ["gamejs", "utils", "combatracer"]);/* This file has been generated by yabbler.js */
require.define({
"renderer": function(require, exports, module) {
var gamejs = require('gamejs');
var utils=require('./utils');
var vec=utils.vec;
var arr=utils.arr;

var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
radians=math.radians;
degrees=math.degrees;

var resources=require('./resources');
var skin=require('./skin');
var settings=require('./settings');
var weapon_descriptions=require('./weapon_descriptions');

//hax gamejs to render font properly with a very hax fix
gamejs.font.Font.prototype.size=function(text){
    var metrics = this.sampleSurface.context.measureText(text);
    return [metrics.width*4, this.fontHeight];    
};

gamejs.font.Font.prototype.render = function(text, color) {
    var dims = this.size(text);
    var surface = new gamejs.Surface(dims);
    var ctx = surface.context;
    ctx.save();
    ctx.font = this.sampleSurface.context.font;
    ctx.textBaseline = this.sampleSurface.context.textBaseline;
    ctx.textAlign = this.sampleSurface.context.textAlign;
    ctx.fillStyle = ctx.strokeStyle = color || "#000000";
    ctx.fillText(text, dims[0]/2, surface.rect.height, surface.rect.width);
    ctx.restore();
    
    //scans the surface left to right and right to left to find where hte letter begins and then trims it.

    
    var s=0, e=dims[0], i;
    var arr=new gamejs.surfacearray.SurfaceArray(surface);
    
    //left to right
    var found=false;
    for(s=0;s<arr.getSize()[0];s++){
        for(i=0;i<arr.getSize()[1];i++){
            if(arr.get(s, i)[3]!=0){
                found=true;
                break;
            }
        }
        if(found)break;
    }
    
    //right to left
    found=false;
    for(e=arr.getSize()[0]-1;e>=0;e--){
        for(i=0;i<arr.getSize()[1];i++){
            if(arr.get(e, i)[3]!=0){
                found=true;
                break;
            }
        }
        if(found) break;
    }
    var h=Math.floor(dims[1]);
    var newsurface=new gamejs.Surface([e-s, h]);
    newsurface.blit(surface, new gamejs.Rect([0, 0], newsurface.getSize()),
                             new gamejs.Rect([s, 0], [e-s, h]));
    return newsurface;
    
    
};

var sprite2rotarray=exports.sprite2rotarray=function(surface, step){
    var retv={'orig':surface,
              0:surface,
              'step':step};
    var orig_size=surface.getSize();
    var timg;
    if(orig_size[0]!=orig_size[1]){
        var s=Math.max(orig_size[0], orig_size[1]);
        timg=new gamejs.Surface(s, s)
        timg.blit(surface, [(s-orig_size[0])/2, (s-orig_size[1])/2]);
        retv[0]=timg;
    }else{
        timg=surface;
        retv[0]=surface;
    }
    for(var angle=step;angle<360;angle+=step){
        retv[angle]=gamejs.transform.rotate(timg, angle);
    }
    return retv;
};


var ImageCache = exports.ImageCache = function() {
    this.cars = {};
    this.props = {};
    this.decals = {};
    this.tiles = {};
    this.animations = {};
    this.fonts = {};
    this.ui = {};
    this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890.,:\/!?"|()';
    this['static'] = {};

    //load tiles
    resources.tiles.forEach(function(f) {
        this.tiles[f] = gamejs.image.load('images/tiles/' + f);
    }, this);
    //load cars
    //resources.cars.forEach(function(f){
    //    this.cars[f]=sprite2rotarray(gamejs.image.load('images/cars/'+f), 2);
    //}, this);

    //cache props
    resources.props.forEach(function(f) {
        this.props[f] = sprite2rotarray(gamejs.image.load('images/props/' + f), 5);
    }, this);
    //cache decals
    resources.decals.forEach(function(f) {
        this.decals[f] = sprite2rotarray(gamejs.image.load('images/decals/' + f), 90);
    }, this);
    //cache animations
    resources.animations.forEach(function(f) {
        this.animations[f] = gamejs.image.load('images/animations/' + f);
    }, this);
    //cache ui
    resources.ui.forEach(function(f) {
        this.ui[f] = gamejs.image.load('images/ui/' + f);
    }, this);
    //cache static
    resources['statics'].forEach(function(f) {
        this['static'][f] = gamejs.image.load('images/static/' + f);
    }, this);
    /*    //cache fonts
     var font='hud', letter;

     this.fonts[font]={};
     resources.fonts[font].forEach(function(f){
     letter=f.split('.')[0];
     this.fonts[font][letter]=gamejs.image.load('images/fonts/'+font+'/'+f);
     }, this);      */

    this.initFont = function(name, fontSettings, color) {
        this.fonts[name] = {};
        var font = new gamejs.font.Font(fontSettings);

        var c;
        for(var i = 0; i < this.alphabet.length; i++) {
            c = this.alphabet[i];
            this.fonts[name][c] = font.render(c, color);
        }
    };

    this.getDecalSprite = function(filename, angle) {
        return this.getSpriteFromRotarray(this.decals[filename], angle);
    };

    this.getPropSprite = function(filename, angle) {
        return this.getSpriteFromRotarray(this.props[filename], angle);
    };

    this.cacheCarSprite = function(filename) {
        if(!this.cars[filename]) {
            this.cars[filename] = sprite2rotarray(gamejs.image.load('images/cars/' + filename), 2);
        }
    };

    this.getCarSprite = function(filename, angle) {
        if(!this.cars[filename]) {
            this.cacheCarSprite(filename);
        }
        return this.getSpriteFromRotarray(this.cars[filename], angle);
    };

    this.getTile = function(filename) {
        return this.tiles[filename];
    };

    this.getLetter = function(font, letter) {
        return this.fonts[font][letter];
    };

    this.getTextSize = function(text, font) {
        var w = 0, h = 0, c, l, sz;
        if(text) {
            for(var i = 0; i < text.length; i++) {
                c = text[i];
                if(c == ' ')
                    w += 8;
                else {
                    l = this.getLetter(font, c);
                    if(l) {
                        sz = l.getSize();
                        w += sz[0];
                        h = sz[1];
                    }
                }
            }
            return [w, h];
        } else
            return [0, 0];
    };

    this.getAnimationFrameCount = function(filename) {
        var sz = this.animations[filename].getSize();
        return sz[0] / sz[1];
    };

    this.getAnimationSheet = function(filename) {
        return this.animations[filename];
    };

    this.getUIImage = function(filename) {
        return this.ui[filename];
    };
    this.getStaticSprite = function(filename) {
        return this['static'][filename];
    };

    this.getSpriteFromRotarray = function(rotarray, angle) {
        angle = math.normaliseDegrees(angle);
        if((angle % rotarray['step']) != 0)
            angle = parseInt(angle / rotarray['step']) * rotarray['step'];
        return rotarray[angle];
    };
    //init fonts
    this.initFont('hud', skin.fonts['hud'][0], skin.fonts['hud'][1]);

    return this;
};



exports.cache=null;

exports.init=function(){
    exports.cache=new ImageCache();
    return exports.cache;
};


var Renderer=exports.Renderer=function(width, height, cache){ 
    this.width=width;
    this.height=height;
    this.cache=cache;
    this.surface=null;
    
    this.textLength=function(text, font){
        var c;
        var len=0;
        for(var i=0;i<text.length;i++){
            c=text[i];
            if(c==' '){
                len+=8;
            }else{
                s=this.cache.getLetter(font, c);
                len+=s.getSize()[0];
            }
        }
        return len;
    };
    
    this.fillBackground=function(color){
        gamejs.draw.rect(this.surface, color, new gamejs.Rect([0, 0], this.surface.getSize()));
    };
    
    this.drawRect=function(color, pos, size, w){
        w = (w || w===0) ? w : 1;
        gamejs.draw.rect(this.surface, color, new gamejs.Rect(pos, size), w);
    };
    
    this.drawLine=function(color, pos1, pos2, w){
        w = (w || w===0) ? w : 1;
        gamejs.draw.line(this.surface, color, pos1, pos2, w);
    }
    
    this.drawText=function(text, font, position, zoom, draw_on){
        /*
        font - font name
        position - position in SCREEN COORDINATES !!
        */
        ofst=position[0];
        zoom = zoom  ? zoom: 1;
        var i, c, s;
        for(i=0;i<text.length;i++){
            c=text[i];
            if(c==' ')ofst+=8/zoom;
            else{
                s=this.cache.getLetter(font, c);
                if(zoom==1){
                    r1=[ofst, position[1]-10];
                }
                else{
                    size=s.getSize();
                    r1=new gamejs.Rect([ofst, position[1]], [parseInt(size[0]/zoom), parseInt(size[1]/zoom)]);
                
                }
                (draw_on ? draw_on: this.surface).blit(s, r1);
                ofst+=s.getSize()[0]/zoom;
            }
        }        
    };
    return this;  
};

var UIRenderer=exports.UIRenderer=function(width, height, cache){
    UIRenderer.superConstructor.apply(this, [width, height, cache]);
    this.cache=cache;
    this.surface=null;
    
    this.setSurface=function(surface){
        this.surface=surface;
    };
    
    this.drawUIImage=function(filename, pos){
        this.surface.blit(this.cache.getUIImage(filename), pos);
    };
    
};

gamejs.utils.objects.extend(UIRenderer, Renderer);

var RaceRenderer = exports.RaceRenderer = function(width, height, world, background, cache, follow_object){
    RaceRenderer.superConstructor.apply(this, [width, height, cache]);
    this.display_width=width;
    this.display_height=height;
    this.world = world;
    this.size=[this.width, this.height];
    this.follow_object=follow_object;
    this.offset_x = 0;
    this.offset_y = 0;
    this.background=background;
    this.surface=null;
    this.st=new gamejs.Surface(this.display_width*2, this.display_height*2);
    this.display=null;
    this.zoom=1;
    this.r1=new gamejs.Rect([0, 0], [this.display_width, this.display_height]);
    this.r2=new gamejs.Rect([0, 0], [this.width, this.height]);
    this.phys_scale = settings.get('PHYS_SCALE');
    
    this.follow=function(obj){
        this.follow_object=obj;
    };
    
    //update camera offset
    this.updateOffset=function(){
        if(this.follow_object){
            var pos = this.follow_object.alive ? this.follow_object.get_position() : this.follow_object.respawn_location;
            this.offset_x=Math.min(Math.max(0, pos[0] * this.phys_scale-parseInt(this.width/2)), world.width * this.phys_scale - this.width);
            this.offset_y=Math.min(Math.max(0, pos[1] * this.phys_scale-parseInt(this.height/2)), world.height * this.phys_scale - this.height);
        }
        return false;
    };
       
    //world point 2 screen point
    this.getScreenPoint=function(world_point){
        return [world_point[0] * this.phys_scale - this.offset_x,
                world_point[1] * this.phys_scale - this.offset_y];
    };
    
    this.drawBackground=function(){
      //  this.blit(this.background, [0, 0], new gamejs.Rect(-this.offset_x, -this.offset_y, this.width, this.height));
      this.surface.blit(this.background, new gamejs.Rect([0, 0], [this.width, this.height]), new gamejs.Rect([this.offset_x, this.offset_y], [this.width, this.height]));
    };
    
    //zoom
    this.setZoom=function(zoom){
        var new_width=parseInt(this.display_width/zoom);
        var new_height=parseInt(this.display_height/zoom);
        if((new_width<=this.world.width_px) && (new_height<=this.world.height_px)){
            this.zoom=zoom;
            this.width=parseInt(this.display_width/zoom);
            this.height=parseInt(this.display_height/zoom);
            this.r2=new gamejs.Rect([0, 0], [this.width, this.height]);
            this.st=new gamejs.Surface(this.width, this.height);
        }
        
    };
    
    this.increaseZoom=function(){
        if(this.zoom<1)this.setZoom(this.zoom+0.01);
    };
    
    this.decreaseZoom=function(){
        if(this.zoom>0.5)this.setZoom(this.zoom-0.01);
    };
    
    //render
    this.render=function(display){
        if(this.zoom==1)this.surface=display;
        else this.surface=this.st;
        this.updateOffset();
        this.drawBackground();
        this.world.draw(this);
        if(this.zoom!=1){
            display.blit(this.surface, this.r1, this.r2);
        }
    };
    
    //DRAW FUNCTIONS
    
    this.drawLine=function(color, pt1, pt2, width){
        /*
         pt1, pt2 - points in world coordinates
         width - width in pixels
        */
        gamejs.draw.line(this.surface, color, this.getScreenPoint(pt1),
                                               this.getScreenPoint(pt2), 2);
    };
    
    this.drawProp=function(filename, pos, angle){
        /*
        pos - position in world coordinates
        angle - angle, degrees
        */
        var sprite=this.cache.getPropSprite(filename, angle ? angle : 0);
        var ofst=sprite.getSize()[0]/2;
        pos=this.getScreenPoint(pos);
        this.surface.blit(sprite, [pos[0]-ofst, pos[1]-ofst]);  
    };
    
    this.drawDecal=function(filename, pos, angle){
        /*
        pos - position in world coordinates
        angle - angle, degrees
        */
        var sprite=this.cache.getDecalSprite(filename, angle ? angle : 0)
        var ofst=sprite.getSize()[0]/2;
        pos=this.getScreenPoint(pos);
        this.surface.blit(sprite, [pos[0]-ofst, pos[1]-ofst]);  
    };
    
    this.drawCar=function(filename, pos, angle){
        /*
        pos - position in world coordinates
        angle - angle, degrees
        */
        var sprite=this.cache.getCarSprite(filename, angle ? angle : 0);
        var ofst=sprite.getSize()[0]/2;
        pos=this.getScreenPoint(pos);
        this.surface.blit(sprite, [pos[0]-ofst, pos[1]-ofst]);

    };
    
    this.drawStatic=function(filename, pos){
        var sprite=this.cache.getStaticSprite(filename);
        var sz=sprite.getSize();
        pos=this.getScreenPoint(pos);
        this.surface.blit(sprite, [pos[0]-sz[0]/2, pos[1]-sz[1]/2]);
    };
    
    this.drawAnimation=function(filename, pos, frame, sz){
        /*
        pos - position in world coordinates
        frame - frame number (starts with 0 ) 
        */
        var sheet=this.cache.getAnimationSheet(filename);
        var h=sheet.getSize()[1];
        sz=sz ? sz : h;
        pos=this.getScreenPoint(pos);
        this.surface.blit(sheet, new gamejs.Rect([pos[0]-sz/2, pos[1]-sz/2], [sz, sz]), new gamejs.Rect([frame*h, 0], [h, h]));
    };
    
    this.renderHUD=function(display,  pars){
        /*
         pars:
         car - car to render hud for
         max_laps - max laps of the track
         time_to_start - time till game start
         paused - is game paused?
         delta - perceived difference between server and client time
         bfs - bad frames. number of frames where nearest further state was unknown and had to simulate world to make up for it
         message - a message to display onscreen
        */

        this.surface=display;
        this.drawText('FPS: ' + parseInt(1000/pars.msDuration), 'hud', [10, 10]);
        var size = display.getSize();
        
        var car = pars.car;

        if(car) {
            this.drawText('POS: ' + car.get_race_position() + '/' + this.world.get_objects_by_tag('car').length, 'hud', [size[0] / 2 - 140, 10]);
            //lap
            this.drawText('LAP: ' + car.lap + '/' + pars.max_laps, 'hud', [size[0] / 2 + 20, 10]);
            //speed
            this.drawText('SPEED: ' + parseInt(car.get_speed_KMH()), 'hud', [10, display.getSize()[1] - 40]);
            //ammo

            var x = 250;
            var y = display.getSize()[1] - 40;
            (['front_weapon', 'util', 'rear_weapon']).forEach(function(weapon_type) {
                if(car[weapon_type]) {
                    var descr = weapon_descriptions[car[weapon_type].type];
                    var icon = this.cache.getStaticSprite(descr.icon);
                    this.surface.blit(icon, [x, y - 15]);
                    x += 50;
                    this.drawText(String(parseInt(car[weapon_type].ammo)), 'hud', [x, y]);
                    x += 60;
                }
            }, this);
        }

        
        if(settings.get('DEBUG')){
            if(pars.delta){
                 this.drawText('D: ' + Math.abs(pars.delta), 'hud', [10, 80]);          
            }
            if(pars.bfs){
                this.drawText('BFS: ' +pars.bfs, 'hud', [10, 140]);
            }
        }
        if(pars.paused){
            this.drawText('PAUSED', 'hud', [size[0]/2-100, size[1]/2], 0.75);
        }else if(pars.message){
            this.drawText(pars.message, 'hud', [size[0]/2-100, size[1]/2], 0.75);
        }else{
            var tts=pars.time_to_start;
            if(tts){
                if(tts>3000){
                    this.drawText('WAITING FOR OTHERS', 'hud', [size[0]/2-150, size[1]/2]);
                }
                else if(tts>2000){
                  this.drawText('GET READY 3...', 'hud', [size[0]/2-150, size[1]/2], 0.75);
                }else if(tts>1000){
                  this.drawText('GET READY 2...', 'hud', [size[0]/2-150, size[1]/2], 0.75);
                }else if(tts>0){
                  this.drawText('GET READY 1...', 'hud', [size[0]/2-150, size[1]/2], 0.75);
                }else if(tts> -1000){
                  this.drawText('GO!!!', 'hud', [size[0]/2-150, size[1]/2], 0.75);
                }
            }
        }   
    };  
    
    return this;
};
gamejs.utils.objects.extend(RaceRenderer, Renderer);

}}, ["gamejs", "utils", "resources", "skin", "settings", "weapon_descriptions"]);/* This file has been generated by yabbler.js */
require.define({
"weapon_descriptions": function(require, exports, module) {
exports.Machinegun = {
    'damage' : 5,
    'preload' : ['bullet.png'],
    'type' : 'front_weapon',
    'launcher' : 'Machinegun',
    'projectile' : 'Bullet',
    'speed' : 500,
    'fire_rate' : 200,
    'ammo_capacity' : 50,
    'damage_upgrade' : 1,
    'damage_upgrade_price' : 500,
    'ammo_upgrade' : 10,
    'ammo_upgrade_price' : 500,
    'name' : 'Machineguns',
    'icon' : 'icon_machinegun.png',
    'price' : 700,
    'description' : 'Your basic car accessory: two front mounted high caliber machineguns'
};

exports.MissileLauncher = {
    'damage' : 25,
    'preload' : ['missile.png'],
    'speed' : 400,
    'type' : 'front_weapon',
    'launcher' : 'MissileLauncher',
    'projectile' : 'Missile',
    'fire_rate' : 600,
    'ammo_capacity' : 10,
    'ammo_upgrade' : 2,
    'ammo_upgrade_price' : 700,
    'damage_upgrade' : 5,
    'damage_upgrade_price' : 700,
    'name' : 'Missiles',
    'icon' : 'icon_missiles.png',
    'price' : 1000,
    'description' : 'Torpedo missiles with high yield warheads, for when you really don\'t like the guy in front of you'
};

exports.RepairKit = {
    'damage' : 30,
    'type' : 'util',
    'launcher' : 'RepairKit',
    'projectile' : null,
    'fire_rate' : 500,
    'ammo_capacity' : 2,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 500,
    'damage_upgrade' : 10,
    'damage_upgrade_price' : 700,
    'name' : 'Repair Kit',
    'icon' : 'icon_fix.png',
    'price' : 1000,
    'description' : 'Repair your car on the go with a automatic repair kit'
};

exports.NOS = {
    'damage' : 15,
    'type' : 'util',
    'fire_rate' : 2000,
    'duration' : 2000,
    'ammo_capacity' : 2,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 1500,
    'damage_upgrade' : 4,
    'damage_upgrade_price' : 1000,
    'launcher' : 'NOS',
    'name' : 'Boost',
    'price' : 2000,
    'icon' : 'ico_nos.png',
    'description' : 'Increases top speed and acceleration for a shot time'
};

exports.Shockwave = {
    'damage' : 10,
    'type' : 'util',
    'fire_rate' : 1500,
    'ammo_capacity' : 3,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 1300,
    'damage_upgrade' : 5,
    'damage_upgrade_price' : 800,
    'launcher' : 'ShockwaveGenerator',
    'name' : 'Shockwave',
    'price' : 1500,
    'icon' : 'icon_sw.png',
    'description' : 'Generates a shockwave that slams nearby cars away from your car'
};

exports.HomingMissiles = {
    'damage' : 18,
    'speed' : 400,
    'preload' : ['missile_homing.png'],
    'type' : 'front_weapon',
    'launcher' : 'MissileLauncher',
    'projectile' : 'HomingMissile',
    'fire_rate' : 500,
    'ammo_capacity' : 10,
    'ammo_upgrade' : 2,
    'ammo_upgrade_price' : 700,
    'damage_upgrade' : 4,
    'damage_upgrade_price' : 800,
    'name' : 'Homing Missiles',
    'price' : 1300,
    'icon' : 'icon_missiles_homing.png',
    'description' : "Heat seeking missiles, a blind driver's favourite weapon"
};

exports.MineLauncher = {
    'damage' : 30,
    'type' : 'rear_weapon',
    'launcher' : 'MineLauncher',
    'projectile' : 'Mine',
    'fire_rate' : 500,
    'ammo_capacity' : 5,
    'ammo_upgrade' : 2,
    'ammo_upgrade_price' : 600,
    'damage_upgrade' : 8,
    'damage_upgrade_price' : 500,
    'name' : 'Mines',
    'icon' : 'icon_mine.png',
    'price' : 800,
    'description' : 'Discourage tailgating with anti-vehicle mines'
};

exports.Oil = {
    'damage' : 0,
    'type' : 'rear_weapon',
    'fire_rate' : 500,
    'duration' : 800,
    'ammo_capacity' : 2,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 2000,
    'damage_upgrade' : null,
    'damage_upgrade_price' : null,
    'name' : 'Oil',
    'icon' : 'ico_oil.png',
    'price' : 2000,
    'launcher' : 'Oil',
    'projectile' : 'OilPuddle',
    'description' : 'Leave slippery puddles of finest grade oil'
};

exports.Napalm = {
    'damage' : 10,
    'type' : 'rear_weapon',
    'launcher' : 'MineLauncher',
    'projectile' : 'NapalmFlame',
    'fire_rate' : 160,
    'ammo_capacity' : 20,
    'ammo_upgrade' : 5,
    'ammo_upgrade_price' : 1000,
    'damage_upgrade' : 2,
    'damage_upgrade_price' : 1000,
    'name' : 'Napalm',
    'icon' : 'icon_flame.png',
    'price' : 2500,
    'description' : 'Burn your opponents to a crisp'
};

exports.PlasmaCannon = {
    'damage' : 12,
    'speed' : 500,
    'preload' : ['plasma_projectile.png'],
    'type' : 'front_weapon',
    'launcher' : 'PlasmaCannon',
    'projectile' : 'PlasmaProjectile',
    'fire_rate' : 400,
    'ammo_capacity' : 24,
    'damage_upgrade' : 3,
    'damage_upgrade_price' : 1500,
    'ammo_upgrade' : 6,
    'ammo_upgrade_price' : 1500,
    'name' : 'Plasma Cannon',
    'icon' : 'icon_plasma.png',
    'price' : 3000,
    'description' : 'Fires super heated blobs of pure plasma that will burn through anything'
};

exports.Shield = {
    'damage' : 0,
    'type' : 'util',
    'launcher' : 'Shield',
    'fire_rate' : 2000,
    'ammo_capacity' : 2,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 1000,
    'name' : 'Force Shield',
    'icon' : 'icon_shield.png',
    'price' : 2000,
    'duration' : 2000,
    'description' : 'Puts up a forcefield that absorbs 3 hits before disintegrating'
};

exports.Cannon = {
    'damage' : 60,
    'preload' : ['cannon_shell.png'],
    'type' : 'front_weapon',
    'launcher' : 'MissileLauncher',
    'projectile' : 'TankShell',
    'fire_rate' : 800,
    'speed' : 500,
    'ammo_capacity' : 10,
    'ammo_upgrade' : 3,
    'ammo_upgrade_price' : 1500,
    'damage_upgrade' : 10,
    'damage_upgrade_price' : 1500,
    'name' : 'Cannon',
    'icon' : 'icon_cannon.png',
    'price' : 4000,
    'description' : "Guns don't get bigger than this massive anti-tank cannon"
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"uiscenes": function(require, exports, module) {
var gamejs = require('gamejs');
var ui=require('./ui');
var utils=require('./utils');
var levels=require('./levels');
var car_descriptions=require('./car_descriptions');
var GUI=require('./gamejs-gui');
var skin=require('./skin');
var combatracer=require('./combatracer');
var renderer=require('./renderer');
var leagues=require('./leagues');
var sounds=require('./sounds');

var EURO_SYMBOL='\u20AC';
/*
var LobbyScene=exports.LobbyScene=function(game, cache, lobby_id){
    LobbyScene.superConstructor.apply(this, [game, cache]);
    this.lobby_id=lobby_id;
    this.ping=true;

    this.kick=function(){
        if(!this.playertable.selected_row_id){
            this.alert('Select a player first!');
            return;
        }
        this.game.getCommunicator().queueMessage('KICK', {'player_id':this.playertable.selected_row_id, 'lobby_id':this.lobby_id});
    };

    this.leave=function(){
        this.game.getCommunicator().queueMessage('LEAVE_LOBBY');
    };

    this.refresh_lobby=function(){
        this.game.getCommunicator().queueMessage('GET_LOBBY_INFO');
    };

    this.start=function(){
        this.game.getCommunicator().queueMessage('START_GAME');
    };

    this.selectCar=function(){
          this.game.getCommunicator().queueMessage('SELECT_CAR', {'car':this.car_selector.selected});
    };

    this.handleMessage=function(cmd, payload){
        if(cmd=='LOBBY_INFO'){
            this.playertable.setData(payload.players);
            if(payload.is_leader){
                this.kickbtn.enable();
                this.startbtn.enable();
                this.playertable.selectable=true;
            }else{
                this.kickbtn.disable();
                this.startbtn.disable();
                this.playertable.selectable=false;
            }
            this.trackdisplay.setTrack(payload.track);
        }
        else if(cmd=='LEFT_LOBBY'){
            this.game.showTitle();
            if(payload.text)this.game.title_scene.alert(payload.text);
        }else if(cmd=='START_GAME'){
            this.game.playMultiplayer(levels[payload.track]);
        }else{
            this.handleMessageDefault(cmd, payload);
        }
    };

    this.header=new ui.Label({'scene':this,
                                'position':[10, 10],
                                'text':'Lobby',
                                'font':'header'});

    var columns=[{'key':'player', 'label':'Player', 'width':200},
                 {'key':'car',    'label':'Car',     'width':120}];

    this.playertable=new ui.Table({'scene':this,
                                 'position':[10, 70],
                                 'rows':6,
                                 'columns':columns})

    this.kickbtn=new ui.Button({'scene':this,
                               'position':[10, 7*30+70+5],
                               'text':'Kick',
                               'enabled':false,
                               'onclick':this.kick});

    this.leavebtn=new ui.Button({'scene':this,
                                'position':[10, 400],
                                'text':'Leave',
                                'onclick':this.leave});

    this.startbtn=new ui.Button({'scene':this,
                                'position':[220, 400],
                                'text':'Start game',
                                'enabled':false,
                                'onclick':this.start});

    new ui.Label({'scene':this,
                 'position':[590, 30],
                 'text':'Select a car'});

    this.car_selector=new ui.CarSelector({'scene':this,
                                    'position':[590, 70],
                                    'onselect':this.selectCar,
                                    'scope':this});

    this.car_selector.select(null, 'Racer');



    this.trackdisplay=new ui.TrackInfoDisplay({'scene':this,
                                               'position':[340, 70]});

    this.refresh_lobby();
    return this;

};
gamejs.utils.objects.extend(LobbyScene, ui.UIScene);*/


var CongratulationsScene=exports.CongratulationsScene=function(){
    CongratulationsScene.superConstructor.apply(this, []);
    
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Congratulations',
                                'font':ui.getFont('header_black')});
    
    this.label=new GUI.Label({'parent':this.container,
                                'position':[30, 120],
                                'text':'You won the game!',
                                'font':ui.getFont('header')});
    
    this.text=new GUI.Text({'parent':this.container,
                            'position':[30, 180],
                            'font':ui.getFont('16_33'),
                            'width':500,
                            'text':'There are no more leagues yet, which means you win!\nCheck back soon for more cars, weapons and tracks. Follow BanditRacer on twitter!'});

}

gamejs.utils.objects.extend(CongratulationsScene, ui.UIScene);

var SPGameOverScene=exports.SPGameOverScene=function(table, place, scene){
    SPGameOverScene.superConstructor.apply(this, []);
    var win=place==1;
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Race Over',
                                'font':ui.getFont('header_black')});
    
    this.label=new GUI.Label({'parent':this.container,
                                'position':[30, 120],
                                'text':win ? 'You win! Well done.' : 'You lose! Better luck next time.',
                                'font':ui.getFont('header')});
    
    var columns=[{'key':'place', 'label':'Place', 'width':80},
              {'key':'player', 'label':'Player', 'width':200},
              {'key':'kills', 'label':'Kills', 'width':80},
              {'key':'deaths', 'label':'Deaths', 'width':80}];
    
    new ui.Table({'parent':this.container,
                  'size':[460, 300],
                  'position':[30, 200],
                  'columns':columns,
                  'data':table});
    

    
        
    var league=leagues[combatracer.game.player.singleplayer.league];
    
    
    //REWARD
    if(!(combatracer.game.return_to=='editor')){
        var reward = 0;
        
        new GUI.Label({'position':[510, 200],
                  'parent':this.container,
                  'font':ui.getFont('button2'),
                  'text':'Reward'});
        
        if(place>0&&place<4) reward=league['reward_'+place];
        
    
        if(place>0){
            var l;
            if(place==1)l='1st place:';
            else if(place==2)l='2nd place:';
            else if(place==3)l='3d place:';
            else{
                l='4th place:';
            }
            new GUI.Label({'position':[510, 240],
                          'font':ui.getFont('alias'),
                          'parent':this.container,
                          'text':l});
            
            var lbl= new GUI.Label({'position':[510, 240],
                          'font':ui.getFont('alias'),
                          'parent':this.container,
                          'text':String(reward)+EURO_SYMBOL});
            lbl.rightAlign(730);
        }
        
        new GUI.Label({'position':[510, 270],
                     'font':ui.getFont('alias'),
                     'parent':this.container,
                     'text':'Kills:'});
        
        lbl= new GUI.Label({'position':[510, 270],
                      'font':ui.getFont('alias'),
                      'parent':this.container,
                      'text':String(scene.player_car.kills*100)+EURO_SYMBOL});
        lbl.rightAlign(730);
        
        var total=reward+scene.player_car.kills*100;
        new GUI.Label({'position':[510, 300],
                     'font':ui.getFont('alias'),
                     'parent':this.container,
                     'text':'TOTAL:'});
        
        lbl= new GUI.Label({'position':[510, 300],
                      'font':ui.getFont('alias'),
                      'parent':this.container,
                      'text':String(total)+EURO_SYMBOL});
        lbl.rightAlign(730);
    
        combatracer.game.player.singleplayer.balance+=total;
    }
    
    
    //dirty hax, show congratulate scene if no more tracks/leagues remain
    this.update=function(ms){
        new ui.UIScene().update.apply(this, [ms]);
        if(this.congratulate)this.game.showCongratulations();
    };
    
    //HANDLE WIN
    if(win){
        combatracer.game.player.singleplayer.completed_tracks.push(scene.level.id);
    
        if(combatracer.game.player.singleplayer.completed_tracks.length>=league.tracks.length){
            if(leagues[combatracer.game.player.singleplayer.league+1]){
                combatracer.game.player.singleplayer.league++;
                combatracer.game.player.singleplayer.completed_tracks = [];
                this.alert('You have advanced to '+leagues[combatracer.game.player.singleplayer.league].name+'!');
            }else{
                this.alert('You win the tournament! Hell difficulty unlocked.')
                combatracer.game.player.singleplayer.league = 0;
                combatracer.game.player.singleplayer.completed_tracks = [];
                combatracer.game.player.singleplayer.completed = true;
            }
        }
    }
    
    //SAVE GAME
    if(!(combatracer.game.return_to=='editor')){
        if(combatracer.game.save()){
            new GUI.Text({'position':[30, 510],
                  'font':ui.getFont('13_green'),
                  'parent':this.container,
                  'width':460,
                  'text':'Game saved to HTML5 storage. You will be able to load it next time you play Bandit Racer on this browser.'});
        }
    }  
    
    
    var btn=new ui.Button({'parent':this.container,
                   'position':[800-150, 500],
                   'size':[150, 50],
                   'lean':'right',
                   'text':'Continue...'});
    btn.onClick(function(){
        this.game.returnTo();
    }, this);
    
    

};

gamejs.utils.objects.extend(SPGameOverScene, ui.UIScene);

/*
var JoinLobbyScene2=exports.JoinLobbyScene2=function(game, cache){
    JoinLobbyScene2.superConstructor.apply(this, [game, cache]);

    this.refresh_lobbies=function(){
        this.lobby_table.setData([]);
        this.lobby_table.no_data_text='Loading, please wait...';
        this.game.getCommunicator().queueMessage('LIST_LOBBIES', {});
    };


    this.join=function(){
        if(!this.lobby_table.selected_row_id){
            this.alert('You must select a lobby first!');
        }else{
            this.game.getCommunicator().queueMessage('JOIN_LOBBY', {'lobby_id':this.lobby_table.selected_row_id});
        }
    };

    this.handleMessage=function(cmd, payload){
        if(cmd=='LOBBY_LIST'){
            var data=payload.lobbies;
            var row;
            for(var i=0;i<data.length;i++){
                row=data[i];
                row.track=levels[row.track].title;
                row.players=row.playercount;
            }
            this.lobby_table.setData(data);
            this.lobby_table.no_data_text='No lobbies found.';
        }else if(cmd=="JOIN_LOBBY_OK"){
            this.game.joinLobby(payload.lobby_id);
        }else{
            this.handleMessageDefault(cmd, payload);
        }

    };

    new ui.Label({'scene':this,
                 'position':[10, 10],
                 'text':'Join lobby',
                 'font':'header'});

    new ui.Button({'scene':this,
                  'position':[10, 410],
                  'text':'Back',
                  'onclick':this.returnToTitle});

    new ui.Button({'scene':this,
                  'position':[220, 410],
                  'text':'Refresh',
                  'onclick':this.refresh_lobbies});

    new ui.Button({'scene':this,
                  'position':[430, 410],
                  'text':'Join',
                  'onclick':this.join});

    var columns=[{'key':'title', 'label':'Title', 'width':220},
                 {'key':'track', 'label':'Track', 'width':200},
                 {'key':'players', 'label':'Players', 'width':200}];

    this.lobby_table=new ui.Table({'scene':this,
                                  'position':[10, 70],
                                  'rows':10,
                                  'selectable':true,
                                  'columns':columns});

    this.refresh_lobbies();


};
gamejs.utils.objects.extend(JoinLobbyScene2, ui.UIScene);
*/

var CreateLobbyScene = exports.CreateLobbyScene = function(){
    CreateLobbyScene.superConstructor.apply(this, []);
    
    
    new GUI.Label({'parent':this.container,
                    'position':[210, 40],
                    'text':'Create Lobby',
                    'font':ui.getFont('header_black')});
                                
    new GUI.Label({'parent':this.container,
                   'position':[20, 150],
                   'text':'Title',
                   'font':ui.getFont('alias')
                });
                
    this.title = new GUI.TextInput({'parent':this.container,
                                   'position':[20, 190],
                                   'size':[200, 34],
                                   'text':'some game',
                                   'font':ui.getFont('alias')});
                                   
    new GUI.Label({'parent':this.container,
                   'position':[20, 250],
                   'text':'Budget',
                   'font':ui.getFont('alias')
                });
                
    this.title = new GUI.TextInput({'parent':this.container,
                                   'position':[20, 290],
                                   'size':[200, 34],
                                   'text':'10000',
                                   'font':ui.getFont('alias')});
                                                              
    this.track_selector=new ui.TrackSelector({'position':[254, 160],
                                              'parent':this.container,
                                              'tracks':levels.all,
                                              'label':'Tracks'});
                                              
                                              
    this.backbtn=new ui.Button({'size':[130, 50],
                                'parent':this.container,
                                'position':[0, 520],
                                'lean':'left',
                                'text':'BACK'});
    this.backbtn.onClick(this.back, this);
    
    this.racebtn=new ui.Button({'size':[130, 50],
                                'parent':this.container,
                                'position':[this.container.size[0]-130, 520],
                                'lean':'right',
                                'text':'CREATE'});
    this.racebtn.onClick(this.create, this);              
    
};

gamejs.utils.objects.extend(CreateLobbyScene, ui.UIScene);

CreateLobbyScene.prototype.back = function(){
    this.game.showLobbyList();  
};

CreateLobbyScene.prototype.create = function(){
    
};

var JoinLobbyScene=exports.JoinLobbyScene=function(){
    JoinLobbyScene.superConstructor.apply(this, []);
    
    
    
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Multiplayer',
                                'font':ui.getFont('header_black')});
    
    var columns=[{'key':'title', 'label':'Title', 'width':150},
                 {'key':'track', 'label':'Track', 'width':150},
                 {'key':'players', 'label':'Players', 'width':150}]
    this.table=new ui.Table({'parent':this.container,
                             'size':[450, 350],
                             'position':[300, 150],
                             'columns':columns,
                             'data':[]});
    
    this.create_btn=new ui.Button({'parent':this.container,
                                  'size':[200, 50],
                                  'lean':'left',
                                  'position':[0, 150],
                                  'text':'Create Lobby'});
    
    this.refresh_btn=new ui.Button({'parent':this.container,
                                    'size':[200, 50],
                                    'lean':'left',
                                    'position':[0, 210],
                                    'text':'Refresh'});
    
    this.back_btn=new ui.Button({'parent':this.container,
                                    'size':[200, 50],
                                    'lean':'left',
                                    'position':[0, 520],
                                    'text':'Back'});
    this.back_btn.onClick(this.returnToTitle, this);
    
    this.join_btn=new ui.Button({'parent':this.container,
                                'size':[200, 50],
                                'lean':'right',
                                'position':[this.container.size[0]-200, 520],
                                'text':'Join'});
                                
    this.handleMessage=function(cmd, payload){
        if(cmd=='LOBBY_LIST'){
            var data=payload.lobbies;
            var row;
            for(var i=0;i<data.length;i++){
                row = data[i];
                row.track=levels[row.track].title;
                row.players = row.playercount;
            }
            this.table.setData(data, 'No lobbies found.');
        }else if(cmd == "JOIN_LOBBY_OK"){
            this.game.joinLobby(payload.lobby_id);
        }else{
            this.handleMessageDefault(cmd, payload);
        }

    };
    
    this.refresh_btn.onClick(function(){
        this.game.getCommunicator().queueMessage('LIST_LOBBIES', {});
    }, this);
    
    this.create_btn.onClick(function(){
        this.game.createLobby();
    }, this);
    
    this.game.getCommunicator().queueMessage('LIST_LOBBIES', {});
};
gamejs.utils.objects.extend(JoinLobbyScene, ui.UIScene);

/*
var CreateLobbyScene=exports.CreateLobbyScene=function(game, cache){
    CreateLobbyScene.superConstructor.apply(this, [game, cache]);

    this.create=function(){
        if(!this.title.getText().length){
            this.alert('Lobby title is required!');
            return;
        }
        if(!this.selector.selected){
            this.alert('You must select a track!');
            return;
        }
        else{
            this.alert('Please wait...', false);
            this.game.getCommunicator().queueMessage('CREATE_LOBBY', {'title':this.title.getText(), 'track':this.selector.selected});

        }
    };

    this.handleMessage=function(cmd, payload){
        if(cmd=='CREATE_LOBBY_OK'){
            this.game.joinLobby(payload.lobby_id);
        }else{
            this.handleMessageDefault(cmd, payload);
        }

    };

    new ui.Label({'scene':this,
                 'position':[10, 10],
                 'text':'Create lobby',
                 'font':'header'});

    new ui.Button({'scene':this,
                  'position':[10, 400],
                  'text':'Back',
                  'onclick':this.returnToTitle});

    new ui.Button({'scene':this,
                  'position':[220, 400],
                  'text':'Create',
                  'onclick':this.create});


    new ui.Label({'scene':this,
                 'position':[10, 90],
                 'text':'Lobby title'});

    this.title=ui.TextBox({'scene':this,
                'position':[10, 130],
                'size':[220, 25],
                'text':'Some lobby'});

    this.selector=new ui.LevelSelector({'scene':this,
                         'position':[250, 90]});
};
gamejs.utils.objects.extend(CreateLobbyScene, ui.UIScene);*/

var TitleScene=exports.TitleScene=function(game, cache){
    TitleScene.superConstructor.apply(this, [game, cache]);
    
    //paint background under text box
    this.container.on(GUI.EVT_PAINT, function(){
        gamejs.draw.polygon(this.surface, skin.alias_background, [[0, 110], [420, 110], [390, 180], [0, 180]]);
    }, this.container);
    
    //logo
    new GUI.Image({'position':[40, 260],
                  'parent':this.container,
                  'image':this.cache.getUIImage('logo.png')});
    
    //name: label
    new GUI.Label({'position':[50, 115],
                  'parent':this.container,
                  'font':ui.getFont('alias_label'),
                  'text':'name:'});
    
    //name input
    this.nameinput=new ui.NameInput({'position':[178, 129],
                                     'size':[200, 40],
                                     'text':this.game.player.alias,
                                     'parent':this.container});
    
    this.nameinput.on(GUI.EVT_CHANGE, function(event){
        this.game.player.alias=event.value; 
    }, this);
    
    this.btn_single=new ui.TitleButton({'position':[440, 210],
                                        'size':[360, 65],
                                        'text':'Single player',
                                        'parent':this.container});
    
    this.btn_single.onClick(this.singleplayer, this);
    
    this.btn_multi=new ui.TitleButton({'position':[440, 300],
                                        'size':[360, 65],
                                        'text':'Multiplayer',
                                        'parent':this.container});
    
    this.btn_multi.onClick(this.joinLobby, this);
    
    this.btn_editor=new ui.TitleButton({'position':[440, 390],
                                        'size':[360, 65],
                                        'text':'Track Editor',
                                        'parent':this.container});
    
    this.btn_editor.onClick(this.editTrack, this);
    
    if(!this.game.tried_loading){
        if(this.game.haveSave()){
            this.yes_no_dialog=new ui.YesNoDialog({'parent':this.gui,
                                     'size':[550, 150],
                                     'text':'Saved game found. Do you want to load?'});
            this.yes_no_dialog.yes.onClick(function(){
                this.yes_no_dialog.close();
                if(this.game.load())this.nameinput.setText(combatracer.game.player.alias);
            }, this);
            
            this.yes_no_dialog.no.onClick(function(){
                this.yes_no_dialog.close();
            }, this);
            this.yes_no_dialog.show();
        }
        this.game.tried_loading=true;
    }
};

gamejs.utils.objects.extend(TitleScene, ui.UIScene);

TitleScene.prototype.editTrack=function(){
    this.game.showEditor();
};

TitleScene.prototype.handleMessage=function(cmd, payload){
    if(cmd=='HELLO'){
        this.game.player.uid=payload.uid;
        this.game.acquainted=true;
        this.clearAlert();
        this.game.showLobbyList();     
    }else{
        this.handleMessageDefault(cmd, payload);
    }
};

TitleScene.prototype.joinLobby=function(){
        var alias=this.game.player.alias;
        if(!alias) this.alert('You must enter your name first!');
        else{
            this.alert('Connecting. Please wait...', false);
            this.game.getCommunicator().queueMessage('HI',{'alias':alias});
        }
    };

TitleScene.prototype.singleplayer=function(){
    this.game.singleplayer();
};



var SinglePlayerScene=exports.SinglePlayerScene=function(){
    SinglePlayerScene.superConstructor.apply(this, []);
    
    this.container.header_height=130;
    this.container.background_color=skin.single_player_scene.background_color;
    this.container.refresh();
    
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Single Player',
                                'font':ui.getFont('header_black')});
    
    this.backbtn=new ui.Button({'size':[130, 50],
                                'parent':this.container,
                                'position':[0, 520],
                                'lean':'left',
                                'fill':skin.sp_button.fill,
                                'font':ui.getFont(skin.sp_button.font),
                                'hover_fill':skin.sp_button.fill_hover,
                                'text':'BACK'});
    this.backbtn.onClick(this.back, this);
    
    this.racebtn=new ui.Button({'size':[130, 50],
                                'parent':this.container,
                                'position':[this.container.size[0]-130, 520],
                                'lean':'right',
                                'fill':skin.sp_button.fill,
                                'font':ui.getFont(skin.sp_button.font),
                                'hover_fill':skin.sp_button.fill_hover,
                                'text':'RACE!'});
    this.racebtn.onClick(this.race, this);
    
    this.gotogarage=new ui.GoToGarage({'position':[14, 160],
                                       'parent':this.container});
    this.gotogarage.on(GUI.EVT_MOUSE_DOWN, function(){
        this.game.return_to='singleplayer';
        sounds.play({'filename':'button_click.wav'});
        this.game.showSPGarage();
    }, this);
    
    this.car_display=new ui.CarDisplay({'position':[14, 356],
                                        'gameinfo':combatracer.game.player.singleplayer,
                                          'parent':this.container});
    
    var tracks = [];
    
    leagues[combatracer.game.player.singleplayer.league].tracks.forEach(function(track){
        if(levels[track].title && (!utils.inArray(combatracer.game.player.singleplayer.completed_tracks, track))){
            tracks.push(levels[track]);
        }
    });

    this.track_selector=new ui.TrackSelector({'position':[254, 160],
                                              'parent':this.container,
                                              'tracks':tracks,
                                              'label':leagues[combatracer.game.player.singleplayer.league].name});
    
    this.diff_selector=new ui.DifficultySelect({'position':[14, 431],
                                               'parent':this.container,
                                               'size':[210, 65]});
    
};
gamejs.utils.objects.extend(SinglePlayerScene, ui.UIScene);

SinglePlayerScene.prototype.back=function(){
    this.game.showTitle();
};

SinglePlayerScene.prototype.race=function(){
    if(!this.track_selector.track){
        this.alert('You must select a track first!', true); 
    }else{
        this.game.playLevel(levels[this.track_selector.track], false, 'singleplayer');
    }
};

var LoadingScene=exports.LoadingScene=function(game, cache, next_scene){
    LoadingScene.superConstructor.apply(this, [game, cache]);
    this.container.destroy();
    var lbl=new GUI.Label({'position':[0, 0],
                     'parent':this.gui,
                      'text':'Loading, please wait...',
                      'font':ui.getFont('25_66')});
    this.gui.center(lbl);
    this.next_scene=next_scene;
};

gamejs.utils.objects.extend(LoadingScene, ui.UIScene);

var ControlsSplash=exports.ControlsSplash=function(game, cache, next_scene){
    ControlsSplash.superConstructor.apply(this, [game, cache]);
    this.container.destroy();
    this.next_scene=next_scene;
    this.gui.on(GUI.EVT_PAINT, function(){
        this.surface.fill(skin.ui_background);
    }, this.gui);
    
    var img=new GUI.Image({'position':[0, 0],
                  'image':cache.getUIImage('controls.png'),
                  'parent':this.gui});
    this.gui.center(img);
    var y=img.getPosition()[1]-120;
    x=img.getPosition()[0];
    img.move([x, y]);
    x-=60;
    y+=img.getSize()[1]+10;
    
    new ui.KeyExplanation({'position':[x, y],
                          'key':'x',
                          'parent':this.gui,
                          'text':'Fire front weapon'});
    y+=62;
    
    new ui.KeyExplanation({'position':[x, y],
                          'key':'c',
                          'parent':this.gui,
                          'text':'Use utility'});
    y+=62;
    
    new ui.KeyExplanation({'position':[x, y],
                          'key':'v',
                          'parent':this.gui,
                          'text':'Fire rear weapon'});
    y+=62;
    
    new ui.KeyExplanation({'position':[x, y],
                          'key':'ESC',
                          'parent':this.gui,
                          'text':'Menu'});
    y+=62;
    
    
    
   this.lbl=new GUI.Label({'position':[x-30, y],
                            'parent':this.gui,
                            'text':'Loading. Please wait...',
                            'font':ui.getFont('25_66')});
   this.loaded=false;
   this.first=false;
   
   this.update=function(msDuration){
        ui.UIScene().update.apply(this, [msDuration]);
        if(!this.first){
            this.first=true;
        }else{
            if(!this.loaded){
                this.game.cacheCarSprites(this.next_scene);
                this.lbl.setText('Press any key or click to continue...');
                this.gui.despatchEvent({'type':GUI.EVT_FOCUS});
                this.gui.on(GUI.EVT_MOUSE_DOWN, this.next, this);
                this.gui.on(GUI.EVT_KEY_DOWN, this.next, this);
                this.loaded=true;
            }
        }
   }
};

gamejs.utils.objects.extend(ControlsSplash, ui.UIScene);


ControlsSplash.prototype.next=function(){
    this.game.director.replaceScene(this.next_scene);  
};


}}, ["gamejs", "ui", "utils", "levels", "car_descriptions", "gamejs-gui", "skin", "combatracer", "renderer", "leagues", "sounds"]);/* This file has been generated by yabbler.js */
require.define({
"main": function(require, exports, module) {
var gamejs = require('gamejs');
var combatracer=require('./combatracer');
var settings=require('./settings');
var skin=require('./skin');
var levels=require('./levels');
var engine=require('./engine');

gamejs.display.setCaption("Bandit Racer");
var img;

function main(){
   var canvas = document.createElement('canvas');
   canvas.width = img.naturalWidth || img.width;
   canvas.height = img.naturalHeight || img.height;
   var context = canvas.getContext('2d');
   context.drawImage(img, 0, 0);
   img.getSize = function() { return [img.naturalWidth, img.naturalHeight]; };
   var loading_img = new gamejs.Surface(img.getSize());
   loading_img._canvas = canvas;
   
   var progfn;
   var canvas=null;
   var display=null;
   //var font=new gamejs.font.Font(skin.fonts.loading[0]);
   var loading_img_size=loading_img.getSize();
   
   function loadTick(){
      var display_size=display.getSize()
      gamejs.draw.rect(display, '#FFF', new gamejs.Rect([0, 0], display_size));
      var loading_pt=[display_size[0]/2-loading_img_size[0]/2, display_size[1]/2-loading_img_size[1]/2-100];
      display.blit(loading_img, loading_pt);
      if(progfn){
         var progress=progfn();
         progress=Math.min(Math.max(progress-0.5, 0)*2, 1);
         gamejs.draw.rect(display, 'black', new gamejs.Rect([loading_pt[0]-100, loading_pt[1]+260], [loading_img_size[0]+200, 40]), 2);
         gamejs.draw.rect(display, 'black', new gamejs.Rect([loading_pt[0]-100, loading_pt[1]+260], [(loading_img_size[0]+200)*progress, 40]), 0);
      }
   };
   
   settings.init();
   display=gamejs.display.setMode([settings.get('SCREEN_WIDTH'), settings.get('SCREEN_HEIGHT')]);
   gamejs.time.fpsCallback(loadTick, this, 50);
   gamejs.preload(combatracer.get_preload_list());
   levels.init();
   progfn = gamejs.ready(function(){   
      var game=new combatracer.init();
      gamejs.time.deleteCallback(loadTick, 50);
      game.start(display);
   });
};

//load logo first
var loadlogo=function(){
   img = new Image();
   img.addEventListener('load', main, true);
   img.src =(window.$g && $g.resourceBaseHref || '.')+'/images/ui/logo.png';
}
//load logo
loadlogo();
}}, ["gamejs", "combatracer", "settings", "skin", "levels", "engine"]);/* This file has been generated by yabbler.js */
require.define({
"garage": function(require, exports, module) {
var gamejs = require('gamejs');
var ui=require('./ui');
var utils=require('./utils');
var levels=require('./levels');
var sounds=require('./sounds');
var car_descriptions=require('./car_descriptions');
var weapon_descriptions=require('./weapon_descriptions');
var GUI=require('./gamejs-gui');
var skin=require('./skin');
var combatracer=require('./combatracer');
var renderer=require('./renderer');

var EURO_SYMBOL='\u20AC';

var SLOT_TO_LABEL={'front_weapon':'Front weapon slot',
                    'util':'Utility slot',
                    'rear_weapon':'Rear weapon slot'};
                    
var UPGRADE_ACC='acc_upgrades';
var UPGRADE_SPEED='speed_upgrades';
var UPGRADE_ARMOR='armor_upgrades';
    
var UPGRADE_TYPE_TO_LABEL={};
UPGRADE_TYPE_TO_LABEL[UPGRADE_ACC]='Acceleration';
UPGRADE_TYPE_TO_LABEL[UPGRADE_SPEED]='Top Speed';
UPGRADE_TYPE_TO_LABEL[UPGRADE_ARMOR]='Armor';

var GarageScene=exports.GarageScene=function(player_data){
    GarageScene.superConstructor.apply(this, []);
    this.player_data=player_data;
    this.car_descr=car_descriptions[this.player_data.car.type];
    this.container.header_height=130;
    this.container.background_color=skin.garage.background_color;
    this.container.refresh();
    this.container.on(GUI.EVT_PAINT, this.paintBackground, this);
    this.container.on(GUI.EVT_AFTER_PAINT, this.afterPaint, this);
    this.selected_item=null;
    this.selected_slot=null;
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Garage',
                                'font':ui.getFont('header_black')});
    
    this.backbtn=new ui.Button({'parent':this.container,
                               'size':[130, 50],
                               'position':[670, 530],
                               'font':ui.getFont(skin.garage.back_button.font),
                               'hover_font':ui.getFont(skin.garage.back_button.hover_font),
                               'fill':skin.garage.back_button.fill,
                               'hover_fill':skin.garage.back_button.hover_fill,
                               'text':'BACK',
                               'lean':'right'});
    
    this.buy_car_btn=new ui.Button({'parent':this.container,
                                   'size':[300, 50],
                                   'position':[350, 530],
                                   'font':ui.getFont('button2_hover'),
                                   'fill':'#006837',
                                   'hover_fill':'#00381C',
                                   'text':'BUY NEW CAR',
                                   'lean':'both'});
    
    this.buy_car_btn.onClick(function(){
        this.game.showCarDealer(this.player_data);
    }, this);
    
    this.balance_label=new GUI.Label({'parent':this.container,
                                     'font':ui.getFont(skin.garage.balance_font),
                                     'position':[8, 172],
                                     'text':'Balance '+this.player_data.balance+'\u20AC'})
    
    //car title
    new GUI.Label({'parent':this.container,
                  'position':[52, 234],
                  'font':ui.getFont(skin.garage.car_title_font),
                  'text':this.car_descr.name});

    
    this.weapon_info=new WeaponInfo({'parent':this.container,
                                    'scene':this,
                                    'position':[270, 160]});
    
    this.tuning=new Tuning({'parent':this.container,
                           'scene':this,
                           'position':[537, 160]});
    
    this.weapon_info.buy_s.button.onClick(this.buyItem, this);
    
    this.backbtn.onClick(function(){
        this.game.returnTo();
    }, this);
    
    this.shop=new Shop({'parent':this.container,
                       'scene':this,
                'position':[275,440]});
    
    this.shop.on('select', this.selectWeapon, this);
    
    
    this.slots={};
    this.slots['front_weapon']=new EquipmentSlot({'parent':this.container,
                                                    'position':[144, 295],
                                                    'scene':this,
                                                    'slot_type':'front_weapon'});
    
    this.slots['util']=new EquipmentSlot({'parent':this.container,
                                        'position':[80, 390],
                                        'scene':this,
                                        'slot_type':'util'});
    
    this.slots['rear_weapon']=new EquipmentSlot({'parent':this.container,
                                                    'position':[107, 505],
                                                    'scene':this,
                                                    'slot_type':'rear_weapon'});
    
    for(var t in this.slots){
        this.slots[t].on('select', this.selectSlot, this);
    }
    this.slots.front_weapon.select();
    
};
gamejs.utils.objects.extend(GarageScene, ui.UIScene);

GarageScene.prototype.selectSlot=function(event){
    this.shop.selectRow(event.item.slot_type);
    this.selected_slot=event.item;
    this.selected_item=event.item;
    this.weapon_info.setItem(event.item);
};

GarageScene.prototype.credit=function(amount){
    if((this.player_data.balance-amount) <0 ){
        this.alert('Insufficient funds!');
        return false;
    }
    
    this.player_data.balance-=amount;
    this.balance_label.setText('Balance '+this.player_data.balance+'\u20AC');
    return true;
};

GarageScene.prototype.buyItem=function(){
    if ((this.player_data.car[this.selected_slot.slot_type]) && (this.selected_item.weapon==this.player_data.car[this.selected_slot.slot_type].type)){
        this.alert('This weapon is already equipped!');
    }
    if(this.credit(this.selected_item.descr.price)){
        this.player_data.car[this.selected_slot.slot_type]={
            'type':this.selected_item.weapon,
            'ammo_upgrades':0,
            'damage_upgrades':0
        };
        this.selected_slot.deselect();
        this.selected_slot.select();
    }
};

GarageScene.prototype.deselectSlots=function(){
    for(var st in this.slots) this.slots[st].deselect();
};

GarageScene.prototype.deselectAll=function(){
    this.shop.deselectAll();
    this.deselectSlots();
};

GarageScene.prototype.selectWeapon=function(event){
    this.deselectSlots();
    var wt=event.item.weapon;
    for(var st in this.slots){
        if((this.player_data.car[this.slots[st].slot_type]) && (event.item.weapon==this.player_data.car[this.slots[st].slot_type].type)){
            event.item.deselect();
            this.slots[st].select();
            return;
        }
    }
    this.weapon_info.setItem(event.item);
    this.selected_item=event.item;
};

GarageScene.prototype.afterPaint=function(){
    //links to selected slot
    if(this.selected_slot){
        var ptlist=[];
        if(this.selected_slot.slot_type=='front_weapon'){
            ptlist=[[270, 290], [230, 290], [230, 315], [195, 315],
                    [195, 320], [230, 320], [230, 460], [270, 460], [270, 455],
                    [235, 455],                    
                    [235, 295], [270, 295]];
        }else if(this.selected_slot.slot_type=='util'){ //315 ->410 320->415
            ptlist=[[270, 290], [230, 290], [230, 410], [130, 410],
                    [130, 415], [230, 415], [230, 460], [270, 460], [270, 455],
                    [235, 455],                    
                    [235, 295], [270, 295]];
        }else if(this.selected_slot.slot_type=='rear_weapon'){//315 ->525 320->530
            ptlist=[[270, 290], [230, 290], [230, 525], [157, 525],
                    [157, 530], [235, 530], [235, 460],  [270, 460], [270, 455],
                    [235, 455],                    
                    [235, 295], [270, 295]];
        }
        if(ptlist){
            gamejs.draw.polygon(this.container.surface, skin.garage.slot_path, ptlist);
        }
    }
};

GarageScene.prototype.paintBackground=function(){
    //balance background
    var ptlist=[[0, 160], [250, 160], [240, 210], [0, 210]];
    gamejs.draw.polygon(this.container.surface, skin.garage.balance_background, ptlist);
    
    //car title background
    gamejs.draw.rect(this.container.surface, skin.garage.car_title_background, new gamejs.Rect([45, 230], [170, 30]));
    
    //car background
    gamejs.draw.rect(this.container.surface, skin.garage.car_background, new gamejs.Rect([45, 260], [170, 310]))
    
    //car image    
    var img=renderer.cache['static'][this.car_descr.art_filename];
    var sz=img.getSize();
    var size=[parseInt((290/sz[1]) * sz[0]), 290];
    this.container.surface.blit(img, [parseInt(45+(170-size[0])/2), 270]);

    //store background
    gamejs.draw.rect(this.container.surface, skin.garage.store_background, new gamejs.Rect([270, 435], [515, 60]));
    
    //store border
    gamejs.draw.rect(this.container.surface, skin.garage.store_border, new gamejs.Rect([273, 438], [509, 54]), 5);
    
    //link from car to tuning
    gamejs.draw.rect(this.container.surface, '#333333', new gamejs.Rect([215, 242], [322, 5]));
    
};

EquipmentSlot=exports.EquipmentSlot=function(pars){
    pars.size=[50, 50];
    EquipmentSlot.superConstructor.apply(this, [pars]);
    this.type='equipment_slot';
    this.slot_type=pars.slot_type;
    this.selected=false;
    this.scene=pars.scene;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
    this.on(GUI.EVT_MOUSE_DOWN, function(){sounds.play({'filename':'button_click.wav'})});
}
gamejs.utils.objects.extend(EquipmentSlot, GUI.View);

EquipmentSlot.prototype.select=function(){
    if(!this.selected){
        this.scene.deselectAll();
        this.selected=true;
        this.despatchEvent({'type':'select', 'item':this});
        this.refresh();
    }
};

EquipmentSlot.prototype.deselect=function(){
    if(this.selected){
        this.selected=false;
        this.refresh();
    }
};

EquipmentSlot.prototype.paint=function(){
    this.surface.clear();
    this.surface.fill(this.selected ? skin.garage.slot_bg_selected : skin.garage.slot_bg);
    gamejs.draw.rect(this.surface, skin.garage.slot_border, new gamejs.Rect([1, 1], [48, 48]), 2)
    
    if(this.scene.player_data.car[this.slot_type]){
        var img=renderer.cache['static'][weapon_descriptions[this.scene.player_data.car[this.slot_type].type].icon];
        var sz=img.getSize();
        this.surface.blit(img, [parseInt((50-sz[0])/2),parseInt((50-sz[1])/2) ]);
    }
}

var WhiteButton=function(pars){
    pars.fill=skin.garage.white_button.bg;
    pars.hover_fill=skin.garage.white_button.bg_hover;
    pars.font=ui.getFont(skin.garage.white_button.font);
    pars.hover_font=ui.getFont(skin.garage.white_button.hover_font);
    pars.lean='none';
    WhiteButton.superConstructor.apply(this, [pars]);  
};

gamejs.utils.objects.extend(WhiteButton, ui.Button);


var BlackButton=function(pars){
    pars.fill='#4D4D4D';
    pars.hover_fill='#F2F2F2';
    pars.font=ui.getFont(skin.garage.white_button.hover_font);
    pars.hover_font=ui.getFont(skin.garage.white_button.font);
    pars.lean='none';
    BlackButton.superConstructor.apply(this, [pars]);  
};

gamejs.utils.objects.extend(BlackButton, ui.Button);

var WeaponInfoBuySpace=function(pars){
    pars.size=[230, 45];
    WeaponInfoBuySpace.superConstructor.apply(this, [pars]);
    
    new GUI.Image({'parent':this,
                  'position':[10, 8],
                  'image':renderer.cache['static']['ico_ammo.png']});
    
    this.ammo_label=new GUI.Label({'position':[50, 14],
                             'parent':this,
                             'text':'0',
                             'font':ui.getFont(skin.garage.weapon_label_font)});
    
    this.damage_icon=new GUI.Image({'parent':this,
                  'position':[85, 8],
                  'image':renderer.cache['static']['ico_damage.png']});
    
    this.damage_label=new GUI.Label({'position':[125, 14],
                             'parent':this,
                             'text':'0',
                             'font':ui.getFont(skin.garage.weapon_label_font)});
    
    this.button=new WhiteButton({'position':[175, 5],
                                'parent':this,
                                'size':[50, 35],
                                'text':'BUY'});
    
    
};

gamejs.utils.objects.extend(WeaponInfoBuySpace, GUI.View);

WeaponInfoBuySpace.prototype.paint=function(){
    this.surface.fill('#CCCCCC');
};



var Tuning=function(pars){
    pars.size=[250, 240];
    Tuning.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    
    this.label=new GUI.Label({'parent':this,
                            'font':ui.getFont('g_white_title'),
                            'position':[20, 10],
                            'text':'Tuning'});
    
    new TuningUpgradeSpace({'parent':this,
                           'position':[10,  45],
                           'upgrade_type':UPGRADE_ACC,
                           'scene':this.scene});
    
    new TuningUpgradeSpace({'parent':this,
                           'position':[10,  110],
                           'upgrade_type':UPGRADE_SPEED,
                           'scene':this.scene});
    
    new TuningUpgradeSpace({'parent':this,
                           'position':[10,  175],
                           'upgrade_type':UPGRADE_ARMOR,
                           'scene':this.scene});
};

gamejs.utils.objects.extend(Tuning, GUI.View);

Tuning.prototype.paint=function(){
    //tuning title background
    gamejs.draw.rect(this.surface, skin.garage.tuning_title_background, new gamejs.Rect([0, 0], [250, 40]));
    
    //tuning background
    gamejs.draw.rect(this.surface, skin.garage.tuning_background, new gamejs.Rect([0, 40], [250, 200]));
};

var WeaponInfo=function(pars){
    pars.size=[250, 240];
    WeaponInfo.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'parent':this,
                            'font':ui.getFont(skin.garage.weapon_label_font),
                            'position':[20, 10],
                            'text':'I'});
    this.label.setText(' ');
    this.text=new GUI.Text({'parent':this,
                        'width':220,
                       'font':ui.getFont(skin.garage.weapon_info_text_font),
                       'position':[15, 45],
                       'text':'I'});
    this.scene=pars.scene;
    
    
    this.price_label=new GUI.Label({'position':[10, 10],
                             'parent':this,
                             'text':'? \u20AC',
                             'font':ui.getFont(skin.garage.weapon_label_font)});
    
    this.price_label.on(GUI.EVT_RESIZE, function(){
        this.price_label.move([this.getSize()[0]-this.price_label.getSize()[0]-10, this.price_label.getPosition()[1]]);
    }, this);
    
    this.buy_s=new WeaponInfoBuySpace({'parent':this,
                                      'visible':false,
                                      'position':[10, 185]});
    
    this.damage_upgrade=new UpgradeSpace({'parent':this,
                                         'visible':false,
                                         'scene':this.scene,
                                         'upgrade_type':'damage',
                                         'position':[10, 110]});
    
    this.ammo_upgrade=new UpgradeSpace({'parent':this,
                                         'visible':false,
                                         'scene':this.scene,
                                         'upgrade_type':'ammo',
                                         'position':[10, 165]})
};

gamejs.utils.objects.extend(WeaponInfo, GUI.View);

WeaponInfo.prototype.paint=function(){
    //weapon info title background
    gamejs.draw.rect(this.surface, skin.garage.weapon_info_title_background, new gamejs.Rect([0, 0], [250, 40]));
    
    //weapon info background
    gamejs.draw.rect(this.surface, skin.garage.weapon_info_background, new gamejs.Rect([0, 40], [250, 200]));
};

WeaponInfo.prototype.setItem=function(item){
    var descr=false;
    this.item=item;
    if(item.type=='shop_item'){
        descr=item.descr;
        this.buy_s.show();
        this.ammo_upgrade.hide();
        this.damage_upgrade.hide();
        this.price_label.show();
        this.price_label.setText(descr.price+' '+EURO_SYMBOL);
        this.buy_s.ammo_label.setText(String(descr.ammo_capacity));
        
        if(descr.damage_upgrade){
            this.buy_s.damage_label.show();
            this.buy_s.damage_icon.show();
            this.buy_s.damage_label.setText(String(descr.damage));
        }else{
            this.buy_s.damage_label.hide();
            this.buy_s.damage_icon.hide();
        }
    }
    else if(item.type=='equipment_slot'){
        this.buy_s.hide();       
        this.price_label.hide();
        if(this.scene.player_data.car[item.slot_type]){
            descr=weapon_descriptions[this.scene.player_data.car[item.slot_type].type];
            this.ammo_upgrade.show();
            this.ammo_upgrade.setDescr(this.scene.player_data.car[item.slot_type]);
            if(descr.damage_upgrade){
                this.damage_upgrade.show();
                this.damage_upgrade.setDescr(this.scene.player_data.car[item.slot_type]);
            }else{
                this.damage_upgrade.hide();
            }
        }else{
            this.ammo_upgrade.hide();
            this.damage_upgrade.hide();
            this.label.setText(SLOT_TO_LABEL[item.slot_type]);
            this.text.setText('This slot is empty. Buy something from the shop below to fill it!');
        }
    }
    
    if(descr){
        this.label.setText(descr.name);
        this.text.setText(descr.description);
    }
};

var Shop=exports.Shop=function(pars){
    this.rows={};
    this.items=[];
    pars.size=[510, 50];
    this.scene=pars.scene;
    Shop.superConstructor.apply(this, [pars]);
    
    var row=new ShopItemRow({'parent':this,
                            'size':this.getSize(),
                            'position':[0, 0],
                            'type':'front_weapon',
                            'visible':false});
    this.rows['front_weapon']=row;
    
    row=new ShopItemRow({'parent':this,
                        'size':this.getSize(),
                        'position':[0, 0],
                        'type':'util',
                        'visible':false});
    this.rows['util']=row;
    
    row=new ShopItemRow({'parent':this,
                        'size':this.getSize(),
                        'position':[0, 0],
                        'type':'rear_weapon',
                        'visible':false});
    this.rows['rear_weapon']=row;
    
    var descr, item;
    for(var weapon in weapon_descriptions){
        descr=weapon_descriptions[weapon];
        row=this.rows[descr.type];
        if(row.children.length){
            new ShopItemSep({'parent':row});
        }
        item=new ShopItem({'parent':row,
                            'weapon':weapon,
                            'descr':descr});
        item.on('select', this.selectItem, this);
        this.items.push(item);  
    }
    
    for(var type in this.rows){
        GUI.layout.horizontal(this.rows[type].children);
    }
    
};
gamejs.utils.objects.extend(Shop, GUI.View);



Shop.prototype.deselectAll=function(){
    this.items.forEach(function(item){
        item.deselect();
    });
};

Shop.prototype.selectItem=function(event){
    this.despatchEvent(event);  
};

Shop.prototype.selectRow=function(type){
    for(var t in this.rows){
        if(t==type){
            this.rows[t].show();
        }
        else{
            this.rows[t].hide();
        }
    }
};

var ShopItemSep=exports.ShopItemSep=function(pars){
    pars.size=[5, 50];
    ShopItemSep.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(ShopItemSep, GUI.View);

ShopItemSep.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.rect(this.surface, skin.garage.store_border, new gamejs.Rect([0, 8], [5, 34]));
};

var ShopItemRow=exports.ShopItemRow=function(pars){
    this.type=pars.type;
    ShopItemRow.superConstructor.apply(this, [pars]);   
};
gamejs.utils.objects.extend(ShopItemRow, GUI.View);
/**
 *
 *descr - weapon description
 */
var ShopItem=exports.ShopItem=function(pars){
    this.descr=pars.descr;
    this.weapon=pars.weapon;
    pars.size=[50, 50];
    ShopItem.superConstructor.apply(this, [pars]);
    this.type='shop_item';
    this.img=renderer.cache['static'][this.descr.icon];
    this.selected=false;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
    this.on(GUI.EVT_MOUSE_DOWN, function(){sounds.play({'filename':'button_click.wav'});});
};
gamejs.utils.objects.extend(ShopItem, GUI.View);

ShopItem.prototype.select=function(){
    if(!this.selected){
        this.parent.parent.scene.deselectAll();
        this.selected=true;
        this.despatchEvent({'type':'select', 'item':this});
        this.refresh();
    }
};

ShopItem.prototype.paint=function(){
    GUI.View.prototype.paint.apply(this, []);
    if(this.selected) this.surface.fill(skin.garage.selected_shop_item_bg);
    var sz=this.img.getSize();
    this.surface.blit(this.img, [parseInt((50-sz[0])/2), parseInt((50-sz[1])/2)]);
};

ShopItem.prototype.deselect=function(){
    if(this.selected){
        this.selected=false;
        this.refresh();
    }
};

var TuningUpgradeSpace=function(pars){
    pars.size=[230, 60];
    this.scene=pars.scene;
    this.upgrade_type=pars.upgrade_type;
    this.descr=car_descriptions[this.scene.player_data.car.type];
    TuningUpgradeSpace.superConstructor.apply(this, [pars]);
   
    new GUI.Label({'parent':this,
                  'position':[20, 0],
                  'parent':this,
                  'font':ui.getFont('g_white_title'),
                  'text':UPGRADE_TYPE_TO_LABEL[this.upgrade_type]});
    
    this.stars=new ui.Stars({'position':[2, 25],
                            'parent':this,
                            'stars':this.getValue()});
    
    this.price_label=new GUI.Label({'position':[0, 29],
                               'parent':this,
                               'text':this.descr.upgrade_price+EURO_SYMBOL,
                               'font':ui.getFont('g_white_title'),
                               'visible':this.getValue()<5});
    
    this.button=new BlackButton({'position':[135, 20],
                                'parent':this,
                                'size':[90, 35],
                                'text':'UPGRADE',
                                'visible':this.getValue()<5});
    
    
    
    this.button.onClick(this.buy, this);
    
    this.price_label.on(GUI.EVT_RESIZE, function(){
        this.price_label.move([this.getSize()[0]-this.button.getSize()[0]-this.price_label.getSize()[0]-10, this.price_label.getPosition()[1]]);
    }, this);
    this.price_label.resize(this.price_label.getSize());
    
};

gamejs.utils.objects.extend(TuningUpgradeSpace, GUI.View);

TuningUpgradeSpace.prototype.getValue=function(){
    return this.scene.player_data.car[this.upgrade_type];
};


TuningUpgradeSpace.prototype.buy=function(){
    if(this.getValue()>=5){
        this.scene.alert('Upgrade maxed out!');
        return;
    }
    
    if(this.scene.credit(this.descr.upgrade_price)){
        this.scene.player_data.car[this.upgrade_type]++;
        this.stars.setStars(this.getValue());
        if(this.getValue()>=5){
            this.price_label.hide();
            this.button.hide();
        }
    }
};

TuningUpgradeSpace.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.rect(this.surface, '#333333', new gamejs.Rect([0, 15], [this.getSize()[0], this.getSize()[1]-15]));
};

var UpgradeSpace=function(pars){
    pars.size=[230, 60];
    this.upgrade_type=pars.upgrade_type;
    this.descr=null;
    this.weapon_descr=null;
    this.scene=pars.scene;
    UpgradeSpace.superConstructor.apply(this, [pars]);
    
    new GUI.Image({'parent':this,
                  'position':[5, 23],
                  'image':renderer.cache['static']['ico_'+this.upgrade_type+'.png']});
    
    this.stars=new ui.Stars({'position':[40, 0],
                            'parent':this,
                            'stars':0})
    
    this.label=new GUI.Label({'position':[35, 29],
                             'parent':this,
                             'text':'0',
                             'font':ui.getFont(skin.garage.weapon_label_font)});
    
    this.price_label=new GUI.Label({'position':[0, 29],
                               'parent':this,
                               'text':'0 '+EURO_SYMBOL,
                               'font':ui.getFont(skin.garage.weapon_label_font)})
    
    
    
    this.button=new WhiteButton({'position':[135, 20],
                                'parent':this,
                                'size':[90, 35],
                                'text':'UPGRADE'});
    
    
    
    this.button.onClick(this.buy, this);
    
    this.price_label.on(GUI.EVT_RESIZE, function(){
        this.price_label.move([this.getSize()[0]-this.button.getSize()[0]-this.price_label.getSize()[0]-10, this.price_label.getPosition()[1]]);
    }, this);
};


gamejs.utils.objects.extend(UpgradeSpace, GUI.View);

UpgradeSpace.prototype.setDescr=function(descr){
    this.descr=descr;
    if(descr){
        this.weapon_descr=weapon_descriptions[this.descr.type];
        var upgrades=this.descr[this.upgrade_type+'_upgrades'];
        this.stars.setStars(upgrades);
        this.label.setText(String(this.getCurValue()));
        this.price_label.setText(this.weapon_descr[this.upgrade_type+'_upgrade_price']+EURO_SYMBOL);
        if(upgrades<5){
            this.button.show();
            this.price_label.show();
        } else {
            this.button.hide();
            this.price_label.hide();
        }
    }
};

UpgradeSpace.prototype.buy=function(){
    if(this.descr[this.upgrade_type+'_upgrades']>=5) return;
    if(this.scene.credit(this.weapon_descr[this.upgrade_type+'_upgrade_price'])){
        this.descr[this.upgrade_type+'_upgrades']++;
        this.setDescr(this.descr);
    }
};  

UpgradeSpace.prototype.getCurValue=function(){
  return (this.upgrade_type=='damage' ? this.weapon_descr.damage : this.weapon_descr.ammo_capacity)+(this.descr[this.upgrade_type+'_upgrades']* this.weapon_descr[this.upgrade_type+'_upgrade'])};


UpgradeSpace.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.rect(this.surface, '#CCCCCC', new gamejs.Rect([0, 15], [this.getSize()[0], this.getSize()[1]-15]));
};


var BuyCarScene=exports.BuyCarScene=function(player_data){
    BuyCarScene.superConstructor.apply(this, []);
    this.player_data=player_data;
    this.container.header_height=130;
    this.container.background_color=skin.garage.background_color;
    this.container.on(GUI.EVT_PAINT, this.paint, this);
    this.container.refresh();
    
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Car Deal',
                                'font':ui.getFont('header_black')});
    
    this.backbtn=new ui.Button({'parent':this.container,
                               'size':[130, 50],
                               'position':[0, 540],
                               'font':ui.getFont(skin.garage.back_button.font),
                               'hover_font':ui.getFont(skin.garage.back_button.hover_font),
                               'fill':skin.garage.back_button.fill,
                               'hover_fill':skin.garage.back_button.hover_fill,
                               'text':'BACK',
                               'lean':'left'});
    
    this.backbtn.onClick(function(){
        this.game.showGarage(this.player_data);
    }, this);
    
    
    this.car_list=new CarList({'position':[25, 160],
                              'parent':this.container,
                              'scene':this});
    
    this.carinfo=new CarInfo({'position':[800-350, 160],
                             'parent':this.container,
                             'scene':this});
    
    this.balance_label=new GUI.Label({'parent':this.container,
                                     'font':ui.getFont(skin.garage.balance_font),
                                     'position':[260, 550],
                                     'text':'Balance '+this.player_data.balance+'\u20AC'});
    
    this.buy_car_btn=new ui.Button({'parent':this.container,
                                   'size':[100, 50],
                                   'position':[700, 540],
                                   'font':ui.getFont('button2_hover'),
                                   'fill':'#006837',
                                   'hover_fill':'#00381C',
                                   'text':'BUY',
                                   'lean':'right',
                                   'visible':false});
    
    this.buy_car_btn.onClick(this.buy, this);
};

gamejs.utils.objects.extend(BuyCarScene, ui.UIScene);

BuyCarScene.prototype.paint=function(){
    gamejs.draw.rect(this.container.surface, '#B3B3B3',
                     new gamejs.Rect([250, 540], [300, 50]));
};

BuyCarScene.prototype.buy=function(){
    if(this.carinfo.descr){
        if(this.credit(this.carinfo.descr.price)){
            this.player_data.car.type=this.carinfo.descr.id;
            this.player_data.car.acc_upgrades=0;
            this.player_data.car.speed_upgrades=0;
            this.player_data.car.armor_upgrades=0;
            this.game.showGarage(this.player_data);
        }
    };
};

BuyCarScene.prototype.credit=function(amount){
    if((this.player_data.balance-amount) <0 ){
        this.alert('Insufficient funds!');
        return false;
    }
    
    this.player_data.balance-=amount;
    this.balance_label.setText('Balance '+this.player_data.balance+'\u20AC');
    return true;
};

var CarListSep=function(pars){
    CarListSep.superConstructor.apply(this, [pars]);
};
gamejs.utils.objects.extend(CarListSep, GUI.View);

CarListSep.prototype.paint=function(){
    this.surface.fill('#CCCCCC');
};

var CarListItem=function(pars){
    this.descr=pars.descr;
    CarListItem.superConstructor.apply(this, [pars]);
    var w=this.getSize()[0];
    var h=this.getSize()[1];
    
    var img=renderer.cache.getCarSprite(this.descr.filenames[0], 0);
    new GUI.Image({'parent':this,
                    'image':img,
                    'position':[5+parseInt(((50)-img.getSize()[0])/2), 5+parseInt(((h-10)-img.getSize()[1])/2)]});
              
    new GUI.Label({'parent':this,
                  'font':ui.getFont('16_33'),
                  'text':this.descr.name,
                  'position':[60, 5]});
    
    new GUI.Text({'parent':this,
                 'font':ui.getFont('13_grayish'),
                 'text':this.descr.description,
                 'width':w-h,
                 'position':[60, 28]});
    
    var lbl= new GUI.Label({'parent':this,
                  'font':ui.getFont('16_33'),
                  'text':this.descr.price+EURO_SYMBOL,
                  'position':[w-100, h-25]});
    
    lbl.move([this.getSize()[0]-lbl.getSize()[0]-10, lbl.getPosition()[1]]);
    
    this.on(GUI.EVT_MOUSE_DOWN, function(){
        sounds.play({'filename':'button_click.wav'});
        this.parent.parent.scene.carinfo.setDescr(this.descr);
    }, this);
    
};

gamejs.utils.objects.extend(CarListItem, GUI.View);

CarListItem.prototype.paint=function(){
    if(this.isHovered()){
        this.surface.fill('#E2E2E2');
    }else{
        this.surface.clear();
    }
};

var CarList=function(pars){
    pars.size=[330, 360];
    this.scene=pars.scene;
    CarList.superConstructor.apply(this, [pars]);
    
    this.scw=new GUI.ScrollableView({'parent':this,
                                    'position':[5, 5],
                                    'size':[this.getSize()[0]-25, this.getSize()[1]-10]});
    
    var scrollbar=new GUI.VerticalScrollbar({'parent':this,
                                            'position':[this.getSize()[0]-20, 5],
                                            'size':[20, this.getSize()[1]-10]});
    this.scw.setVerticalScrollbar(scrollbar);
    
    var descrs=[];
    for(var id in car_descriptions){
        descrs.push(car_descriptions[id]);
    }
    
    descrs.sort(function(a, b){
        return a.price-b.price;
    });
    
    descrs.forEach(function(descr){
        if(this.scw.children.length){
            new CarListSep({'parent':this.scw,
                           'position':[10, 0],
                           'size':[this.scw.getSize()[0]-20, 5]});
        }
        new CarListItem({'parent':this.scw,
                        'size':[this.scw.getSize()[0], 100],
                        'descr':descr});
    }, this);
    GUI.layout.vertical(this.scw.children);
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(CarList, GUI.View);

CarList.prototype.paint=function(){
    this.surface.clear();
    var h=this.getSize()[1];
    var w=this.getSize()[0];
    gamejs.draw.rect(this.surface, '#999999', new gamejs.Rect([0, 0], [w, 5]));
    gamejs.draw.rect(this.surface, '#999999', new gamejs.Rect([0, h-5], [w, 5]));
    
    gamejs.draw.rect(this.surface, '#999999', new gamejs.Rect([0, 5], [5, h-10]));
   // gamejs.draw.rect(this.surface, '#CCCCCC', new gamejs.Rect([w-20, 5], [20, h-10]));
    
    gamejs.draw.rect(this.surface, '#F2F2F2', new gamejs.Rect([5, 5], [w-5, h-10]));
};

var CarInfo=function(pars){
    pars.size=[330, 360];
    this.scene=pars.scene;
    this.descr=null;
    CarInfo.superConstructor.apply(this, [pars]);
    this.carimg=null;
    
    this.cartitle=new GUI.Label({'parent':this,
                                'position':[20, 178],
                                'text':'Car not selected',
                                'font':ui.getFont('alias')});
    
    this.cardescr=new GUI.Text({'parent':this,
                               'position':[20, 213],
                               'width':310,
                               'font':ui.getFont('16_33'),
                               'text':'Select a car!'});
    
    this.pricelabel=new GUI.Label({'parent':this,
                                  'position':[230, 178],
                                  'font':ui.getFont('alias'),
                                  'text':'0'+EURO_SYMBOL,
                                  'visible':false});
    
    this.acceleration_label=new GUI.Label({'parent':this,
                                 'position':[20, 240],
                                 'font':ui.getFont('16_33'),
                                 'text':'Acceleration:',
                                 'visible':false});
    
    this.acceleration_stars=new ui.Stars({'parent':this,
                                         'position':[135, 240],
                                         'stars':0,
                                        'visible':false});
    
    this.speed_label=new GUI.Label({'parent':this,
                                 'position':[20, 270],
                                 'font':ui.getFont('16_33'),
                                 'text':'Top Speed:',
                                 'visible':false});
    
    this.speed_stars=new ui.Stars({'parent':this,
                                         'position':[135, 270],
                                         'stars':0,
                                 'visible':false});
    
    this.armor_label=new GUI.Label({'parent':this,
                                 'position':[20, 300],
                                 'font':ui.getFont('16_33'),
                                 'text':'Armor:',
                                 'visible':false});
    
    this.armor_stars=new ui.Stars({'parent':this,
                                    'position':[135, 300],
                                    'stars':0,
                                 'visible':false});
    
    this.handling_label=new GUI.Label({'parent':this,
                                 'position':[20, 330],
                                 'font':ui.getFont('16_33'),
                                 'text':'Handling:',
                                 'visible':false});
    
    this.handling_stars=new ui.Stars({'parent':this,
                                    'position':[135, 330],
                                    'stars':0,
                                 'visible':false});
    
    
    
    
    this.pricelabel.on(GUI.EVT_RESIZE, function(){
        this.pricelabel.move([this.getSize()[0]-this.pricelabel.getSize()[0]-10, this.pricelabel.getPosition()[1]]);
    }, this);
};

gamejs.utils.objects.extend(CarInfo, GUI.View);


CarInfo.prototype.paint=function(){
    this.surface.fill('#B3B3B3');
    gamejs.draw.rect(this.surface, '#F5F5F5', new gamejs.Rect([0, 0], [this.getSize()[0], 180]));
    if(this.carimg){
        this.surface.blit(this.carimg, [20, 5]);
    }
    
    
};

CarInfo.prototype.setDescr=function(descr){
    this.descr=descr;
    this.carimg=gamejs.transform.rotate(renderer.cache['static'][this.descr.art_filename], 90);
    this.cartitle.setText(descr.name);
    this.cardescr.setText(descr.description);
    this.pricelabel.show();
    if(this.scene.player_data.car.type!=descr.id){
        this.pricelabel.setText(descr.price+EURO_SYMBOL);
        this.scene.buy_car_btn.show();
    }else{
        this.pricelabel.setText('OWNED');
        this.scene.buy_car_btn.hide();
    }
    this.acceleration_stars.setStars(descr.acceleration_stars);
    this.speed_stars.setStars(descr.speed_stars);
    this.armor_stars.setStars(descr.armor_stars);
    this.handling_stars.setStars(descr.handling_stars);
    
    this.acceleration_label.show();
    this.armor_label.show();
    this.speed_label.show();
    this.handling_label.show();
    this.acceleration_stars.show();
    this.speed_stars.show();
    this.armor_stars.show();
    this.handling_stars.show();
    
    
    
    this.refresh();
};
}}, ["gamejs", "ui", "utils", "levels", "sounds", "car_descriptions", "weapon_descriptions", "gamejs-gui", "skin", "combatracer", "renderer"]);/* This file has been generated by yabbler.js */
require.define({
"levels": function(require, exports, module) {
var resources=require('./resources');
var gamejs=require('gamejs');

exports.all = [];
exports.init=function(){
    var lname='';
    for(var i=0; i<resources.levels.length;i++){
        lname=resources.levels[i];
        var level = gamejs.http.load('/levels/'+lname+'.json');
        level.id = lname;
        exports[lname] = level;
        exports.all.push(level);
    }
}

}}, ["resources", "gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"animation": function(require, exports, module) {
var utils = require('./utils');
var gamejs = require('gamejs');
var engine = require('./engine');

var Animation=exports.Animation=function(pars){
    /*
    pars:
    filename, duration, repeat

    */
    this.filename=pars.filename;
    this.age=0;
    this.duration=pars.duration;
    this.type='animation';
 
    this.finished=false;
    this.repeat=pars.repeat ? true : false;
    
    this.resize_from=0;
    this.resize_to=0;
    this.resize_age=0;
    this.resize_duration=0;
    
    this.onFinish = function(){};
    
    this.restart = function(){
        this.age = 0;
    };
    
    this.resize = function(from, to, duration){
    	this.resize_from = from;
    	this.resize_to = to;
    	this.resize_duration = duration;
    	this.resize_age = 0;
    };

    this.update = function(msDuration) {
        this.age += msDuration;
        if(this.resize_age < this.resize_duration)
            this.resize_age += msDuration;
        if(this.age > this.duration) {
            this.onFinish();
            if(this.repeat) {
                this.restart();
            } else {
                this.finished = true;
            }
        }
    };



    this.draw = function(renderer, position){
        var frames = renderer.cache.getAnimationFrameCount(this.filename);
        var sz = null;
        if(this.resize_age < this.resize_duration){
            sz = this.resize_from+parseInt((this.resize_to - this.resize_from) * (this.resize_age / this.resize_duration));
        }    
        renderer.drawAnimation(this.filename, position, Math.min(parseInt(this.age / (this.duration / frames)), frames - 1), sz);
    };
    return this;
};

var AnimationObject = exports.AnimationObject = function(pars){
    AnimationObject.superConstructor.apply(this, [pars]);
    this.add_tag('animation_object');
    this.anim = new Animation(pars);
    this.position = pars.position;
    this.world = pars.world;
    this.duration = pars.duration;

    this.follow_obj = pars.follow_obj;
    if(pars.resize){
    	this.anim.resize(pars.resize.from, pars.resize.to, pars.resize.duration);
    }
};

gamejs.utils.objects.extend(AnimationObject, engine.Object);

engine.register_class(AnimationObject);

AnimationObject.prototype.update = function(msDuration){
    this.anim.update(msDuration);
    if(this.anim.finished){
        this.world.destroy(this);
    }
};

AnimationObject.prototype.draw = function(renderer){
    var position = this.follow_obj ? this.follow_obj.get_position() : this.position;
    this.anim.draw(renderer, position);
};

exports.animations={'small_explosion':{'filename':'explosion_small.png',
                                        'duration':500},
                    'smoke':{'filename':'smoke.png',
                            'duration':300},
                    'explosion':{'filename':'explosion.png',
                                 'duration':1000},
                    'explosion2':{'filename':'explosion2.png',
                    			  'duration':1000},
                    'shockwave':{'filename':'sw.png',
                                'duration':200,
                                'resize':{'from':40, 
                                		  'to':200, 
                                		  'duration':200}},
                    'heal':{'filename':'heal.png',
                            'duration':500},
                    'fire':{'filename':'fire64.png',
                    		'duration':500},
                    'shield':{'filename':'forcefield.png',
                    		'duration':2000}
                    };

}}, ["utils", "gamejs", "engine"]);/* This file has been generated by yabbler.js */
require.define({
"cars": function(require, exports, module) {
var gamejs = require('gamejs');
var utils = require('./utils');
var sounds = require('./sounds');
var buffs=require('./buffs');
var car_descriptions = require('./car_descriptions');
var combatracer=require('./combatracer');
var weapons = require('./weapons');
var weapon_descriptions = require('./weapon_descriptions');
var engine = require('./engine');
var settings = require('./settings');
var box2d = engine.box2d;
var vec=utils.vec;
var arr=utils.arr;

var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
radians=math.radians;
degrees=math.degrees;

var animation=require('./animation');

var STEER_NONE=exports.STEER_NONE=0;
var STEER_RIGHT=exports.STEER_RIGHT=1;
var STEER_LEFT=exports.STEER_LEFT=2;

var ACC_NONE=exports.ACC_NONE=0;
var ACC_ACCELERATE=exports.ACC_ACCELERATE=1;
var ACC_BRAKE=exports.ACC_BRAKE=2;

var Wheel = exports.Wheel = function(pars){
    this.car = pars.car;
    this.local_position = pars.position;
    
    var par_list = [    
                        ['revolving', false],
                        ['powered', false]
                   ];
               
    engine.utils.process_parameters(pars, par_list);
    
    pars.position = this.car.get_world_point(this.local_position);
    pars.angle = this.car.get_angle();
    pars.sensor = true;
    Wheel.superConstructor.apply(this, [pars]);
    this.prev_position = this.position;
    this.add_tag('wheel');
    
    //create joint to connect wheel to body
    if(this.parameters.revolving){
        var jointdef = new box2d.b2RevoluteJointDef();
        jointdef.Initialize(this.car.body, this.body, this.body.GetWorldCenter());
        jointdef.enableMotor = false;
        jointdef.referenceAngle = 0;
    }else{
        var jointdef = new box2d.b2PrismaticJointDef();
        jointdef.Initialize(this.car.body, this.body, this.body.GetWorldCenter(), vec([1, 0]));
        jointdef.enableLimit = true;
        jointdef.lowerTranslation = jointdef.upperTranslation = jointdef.referenceAngle=0;
    }
    this.world.b2world.CreateJoint(jointdef);
};

gamejs.utils.objects.extend(Wheel, engine.Entity);


Wheel.prototype.reset_angle = function() {
    this.set_angle(this.car.get_angle());
};

Wheel.prototype.set_relative_angle = function(angle) {
    this.set_angle(this.car.get_angle()+angle);
};

Wheel.prototype.get_world_position=function() {
    return this.car.get_world_point(this.local_position);
};

Wheel.prototype.draw = function(renderer) {
    renderer.drawCar(this.parameters.filename, 
                    this.car.get_world_point(this.local_position), 
                    this.get_angle());
    if(this.alive){
        if(this.prev_position && 
          (gamejs.utils.vectors.angle(this.get_linear_velocity(), 
                                      this.get_world_vector([0, -1])) > gamejs.utils.math.radians(20))){
            var ps = settings.get('PHYS_SCALE');
            var pp = this.prev_position;
            var  p= this.position;
            var a1 = [-this.parameters.size[0] / 2, 0];
            var a2 = [this.parameters.size[0] / 2, 0];
            var angle = radians(this.get_angle());
            a1 = gamejs.utils.vectors.rotate(a1, angle);
            a2 = gamejs.utils.vectors.rotate(a2, angle);
            var points=[[(a1[0]+pp[0])*ps, (a1[1]+pp[1])*ps],
                        [(a1[0]+p[0])*ps, (a1[1]+p[1])*ps],
                        [(a2[0]+p[0])*ps, (a2[1]+p[1])*ps],
                        [(a2[0]+pp[0])*ps, (a2[1]+pp[1])*ps]];
            gamejs.draw.polygon(renderer.background, '#282828', points)
        };
       
        this.prev_position = this.position;
   }
};

Wheel.prototype.get_local_velocity = function(){
    return this.get_local_vector(this.car.get_linear_velocity(this.local_position));
};

Wheel.prototype.get_kill_velocity_vector = function(){
    var velocity = this.get_linear_velocity();
    var sideways_axis = this.get_direction_vector();
    var dotprod = vectors.dot(velocity, sideways_axis);
    return vectors.multiply(sideways_axis, dotprod);
};

Wheel.prototype.kill_sideways_velocity = function(){
    var kv = this.get_kill_velocity_vector();
    this.k_velocity = kv;
    this.set_linear_velocity(kv);
};

Wheel.prototype.die = function(){
    this.alive = false;
    this.set_linear_velocity([0, 0]);
    this.prev_position = null;
};

Wheel.prototype.get_local_angle=function(){   
    var retv= math.normaliseDegrees(this.get_angle()-this.car.get_angle());
    if(retv > 180) retv -= 360;
    return retv;
};

Wheel.prototype.respawn = function(){
    this.alive = true;
};


var Car = exports.Car = function(parameters){
    /*
    pars is object with keys:

    width             - width in meters
    height            - height in meters
    filename          - sprite file name
    world             - world object
    position          -[x, y]  position in world
    angle             -start angle in degrees
    power             -engine power in newtons
    max_steer_angle   -max steering angle, degrees
    max_speed         -max speed, km/h
    wheels            -wheel definitins: {'x', 'y', 'rotart', 'powered'}
    front_weapon           -first weapon
    rear_weapon           -second weapon
    util
    health            -max health
    alias             -player alias
    car_type
    speed_upgrades
    armor_upgrades
    acc_upgrades

    */
    this.descr = car_descriptions[parameters.car_type];
   
    parameters.size = [this.descr.width, this.descr.height];
   
    var par_list = [    
                        ['filename',        ''],
                        'car_type',
                        ['mod_speed',       0],
                        ['engine_sound',    false],
                        ['turn_msec',       200],
                        ['front_weapon',    null],
                        ['rear_weapon',     null],
                        ['util',            null],
                        ['alias',           ''],
                        ['speed_upgrades',  0],
                        ['armor_upgrades',  0],
                        ['acc_upgrades',    0]
                   ];
               
    engine.utils.process_parameters(parameters, par_list);
    
    this.health = this.max_health =  parameters.max_health = this.descr.health + parameters.armor_upgrades * this.descr.armor_upgrade;
    this.max_speed = this.descr.max_speed + parameters.speed_upgrades * this.descr.speed_upgrade;
    
    Car.superConstructor.apply(this, [parameters]);
    
    var carpos = this.world.get_objects_by_tag('car').length;
    this.filename = this.descr.filenames[carpos % this.descr.filenames.length];

    this.add_tag('car');
    this.active = true;
    
    this.alias = this.parameters.alias;
    this.next_checkpoint_no = 1;
    this.lap = 0;
    this.time_to_respawn = 0;
    this.respawn_location = this.position;
    this.respawn_angle = 0;
    this.respawn_time = 2000;
    this.kills = 0;
    this.deaths = 0;

    //WEAPONS
    this.front_weapon = null;
    this.rear_weapon = null;
    this.util = null;
    
    if(this.parameters.front_weapon){
        var pars = utils.copy(this.parameters.front_weapon, {});
        pars.car = this;
        pars.slot = 'front_weapon';
        pars.world = this.world;
        this.world.create(weapons[weapon_descriptions[pars.type].launcher], pars);
    }
    if(this.parameters.rear_weapon){
        var pars = utils.copy(this.parameters.rear_weapon, {});
        pars.car = this;
        pars.world = this.world;
        pars.slot = 'rear_weapon';
        this.world.create(weapons[weapon_descriptions[pars.type].launcher], pars);
    }
    if(this.parameters.util) {
        var pars = utils.copy(this.parameters.util, {});
        pars.car = this;
        pars.world = this.world;
        pars.slot = 'util';
        this.world.create(weapons[weapon_descriptions[pars.type].launcher], pars);
    }

    //ACTIONS
    this.fire_front_weapon = false;
    this.fire_rear_weapon = false;
    this.fire_util = false;
    this.accelerate = ACC_NONE;
    this.steer = STEER_NONE;

    //PHYSICAL
    this.max_steer_angle = this.descr.max_steer_angle;
    this.power = this.descr.power + this.parameters.acc_upgrades * this.descr.power_upgrade;
    this.max_speed = this.descr.max_speed + this.parameters.speed_upgrades * this.descr.speed_upgrade;
    this.turn_msec = this.parameters.turn_msec;
    this.local_engine_pos = [0, -(this.parameters.height/2)];
    this.cur_wheel_angle = 0;
    this.mod_speed = this.parameters.mod_speed;
    

    //ANIM
    this.smoke_cd = 0;
    
    //initialize wheels
    this.wheels=[]
    var wheeldef, i;
    this.descr.wheels.forEach(function(wheeldef){
        wheeldef = utils.copy(wheeldef, {});
        wheeldef.position = [wheeldef.x, wheeldef.y];
        wheeldef.size = [wheeldef.width, wheeldef.length];
        wheeldef.car = this;
        wheeldef.world = this.world;
        this.wheels.push( new Wheel(wheeldef) );
    }, this);
};   

gamejs.utils.objects.extend(Car, engine.Entity);

engine.register_class(Car);

Car.prototype.impact = function(obj, cpoint, direction){
    if(obj.has_tag('car')){
        this.world.play_sound('thud.wav', this.get_position());
    }
};

Car.prototype.cross_finish_line = function(){
    if(this.front_weapon) this.front_weapon.reload();
    if(this.rear_weapon) this.rear_weapon.reload();
    if(this.util) this.util.reload();
};
    
Car.prototype.get_power = function(){
    var power = this.power;
    this.buffs.forEach(function(buff){
        if(buff.effect == buffs.EFFECT_ENGINE){          
            power += buff.value;
        }
    }, this);
    return parseInt(power);
};

Car.prototype.get_max_speed = function(){
    var max_speed=this.max_speed;
    this.buffs.forEach(function(buff){
        if(buff.effect == buffs.EFFECT_ENGINE){
            max_speed += buff.value;
        }
    }, this);
    return parseInt(max_speed + this.mod_speed);
};

Car.prototype.update_checkpoint = function(){
      var cp = this.world.checkpoints[this.next_checkpoint_no];
      var pos = this.get_position();
      if(pos[0] >= cp.pt1[0] && pos[0] <= cp.pt2[0] && pos[1] >= cp.pt1[1] && pos[1] <= cp.pt2[1]){
          if(this.next_checkpoint_no == 1){
             this.lap++;
             this.cross_finish_line();
          }
    
          if(this.next_checkpoint_no == this.world.max_checkpoint){
             this.next_checkpoint_no = 1;
          }
          else{
             this.next_checkpoint_no++;
          }
    
      }
};

Car.prototype.get_race_position = function(){
        var pos = this.world.objects_by_tag['car'].length;
        var i, c;
        //check each car in the race
        for(i = 0; i < this.world.objects_by_tag['car'].length; i++){
            c = this.world.objects_by_tag['car'][i];
            if(!(c === this)){
                //if this cars lap is greater, it is ahead
                if( this.lap > c.lap ){
                    pos--;
                //if this cars lap is equal, but checkpoint is greater, it is ahead
                }else if(this.lap == c.lap && ((this.next_checkpoint_no > c.next_checkpoint_no) || (this.next_checkpoint_no == 1 && c.next_checkpoint_no != 1))){
                    pos--;
                //if this cars lap and checkpoint are equal, but distance to checkpoint is less, it is ahead
                }else if((this.lap == c.lap)&&
                         (this.next_checkpoint_no==c.next_checkpoint_no) &&
                         (vectors.distance(this.alive ? this.get_position() : this.respawn_location, this.world.checkpoints[this.next_checkpoint_no].center) <
                          vectors.distance(c.alive ? c.get_position() : c.respawn_location, this.world.checkpoints[c.next_checkpoint_no].center)) ){
                    pos--;
                }
            }
        }
        return pos;
};

Car.prototype.get_powered_wheels = function(){
    var retv=[];
    this.wheels.forEach(function(wheel){
        if(wheel.parameters.powered) retv.push(wheel);
    });        
    return retv;
};

Car.prototype.get_revolving_wheels = function(){
    var retv = [];
    this.wheels.forEach(function(wheel){
        if(wheel.parameters.revolving) retv.push(wheel);
    });
    return retv;
};

Car.prototype.get_speed_KMH = function(){
    var velocity = this.get_linear_velocity();
    var len=vectors.len(velocity);
    return (len/1000)*3600;
};

Car.prototype.draw = function(renderer){
    if(this.alive && this.active){
        this.wheels.forEach(function(wheel){
            wheel.draw(renderer);
        });
        var bp = this.get_position();
        renderer.drawCar(this.filename, bp, this.get_angle());

        //only draw alias on multiplayer games
        //if(this.alias){
        //    renderer.drawText(this.alias, 'alias', renderer.getScreenPoint([bp[0]-this.width, bp[1]-this.height]));
        //}
    }
};

Car.prototype.teleport=function(position, angle){
    angle= angle ? angle : this.get_angle();
    this.set_position(position);
    this.set_angle(angle);
    this.wheels.forEach(function(wheel){
        wheel.set_position(this.get_world_point(wheel.local_position));
    }, this);
};

Car.prototype.die=function(){
    this.alive = false;
    this.deaths += 1;
    this.time_to_respawn = this.respawn_time;
    this.respawn_location = this.get_position();
    this.world.spawn_animation('explosion', this.get_position());
    this.world.play_sound('explosion.wav', this.get_position());
    this.respawn_angle = this.get_angle();
    this.teleport([0, 0]);
    this.set_linear_velocity([0, 0]);
    this.wheels.forEach(function(wheel){ wheel.die();});
    this.clear_buffs();
};

Car.prototype.respawn = function(){
    this.alive = true;
    this.wheels.forEach(function(wheel){wheel.respawn();});
    this.teleport(this.respawn_location, this.respawn_angle);
    this.health = this.max_health;
};

Car.prototype.kill=function(car){
    this.kills += 1;
};

Car.prototype.apply_damage = function(damage, owner){
	for(var i=0; i< this.buffs.length; i++){
        if(!this.buffs[i].process_hit(damage, owner)) return;
    }
    
    if(this.alive){
        this.health = Math.min(this.health-damage, this.max_health);
        if(this.health <= 0){
            this.die();
            if(owner) owner.kill(this);
        }
    }
};

Car.prototype.update=function(msDuration){
    if(this.active){
        if(this.alive){
            if(this.alive) this.update_alive(msDuration);
        }
        else{
            this.time_to_respawn-=msDuration;
            if(this.time_to_respawn<=0){
                this.respawn();
            }
        }
    }
};

Car.prototype.update_alive = function(msDuration){
    this.update_checkpoint();
    var steer = this.steer;
    var acceleration = this.accelerate;
    var speed = this.get_speed_KMH();
    var local_velocity = this.get_local_vector(this.get_linear_velocity());
    var max_speed = this.get_max_speed();
    
    //go slower backwards
    max_speed = (local_velocity[1] > 0 ? 0.5 * max_speed : max_speed);

    //kill sideways velocity
    if(!this.has_effect(buffs.EFFECT_NO_GRIP)){
        this.wheels.forEach(function(wheel){wheel.kill_sideways_velocity();});
    }

    //SET STEER
    //need to calculate maximum allowed steer angle first
    var max_wheel_angle = this.max_steer_angle;
    //for speed < 100 it is increased, up to 40. This enables the car to make tighter turns at lower speeds
        if(speed<100){
            max_wheel_angle = max_wheel_angle+ (40-max_wheel_angle) * (1 - speed / 100);
        }      
   

    //TURN WHEELS
    var incr = (this.max_steer_angle / this.turn_msec) * msDuration
    var wheels = this.get_revolving_wheels();
    var angle;
    for( i = 0; i < wheels.length; i++) {
        wheel = wheels[i];
        if(steer == STEER_RIGHT) {
            this.cur_wheel_angle = Math.min(Math.max(this.cur_wheel_angle, 0) + incr, max_wheel_angle)
            wheel.set_relative_angle(this.cur_wheel_angle);
        } else if(steer == STEER_LEFT) {
            this.cur_wheel_angle = Math.max(Math.min(this.cur_wheel_angle, 0) - incr, -max_wheel_angle)
            wheel.set_relative_angle(this.cur_wheel_angle);
        } else {
            this.cur_wheel_angle = 0;
            wheel.reset_angle();
        }
    }

    //apply engine force
    var base_vect;
    if((acceleration == ACC_ACCELERATE) && (speed < max_speed)) base_vect = [0, -1];
    else if(acceleration == ACC_BRAKE){
        //braking, lotsa force
        if(this.get_local_velocity()[1] < 0) base_vect = [0, 1.2];
        //reversing, less force
        else base_vect = [0, 0.7];
    }
    else base_vect = [0, 0];
    var fvect = vectors.multiply(base_vect, this.get_power());

    this.get_powered_wheels().forEach(function(wheel){
       wheel.apply_force(fvect, [0, 0]);
    }, this);
    
    //if going very slow, stop - to prevend sliding
    if( (this.get_speed_KMH() < 4) && (acceleration == ACC_NONE)){
        this.set_speed(0);
    }

    //fire weapons
    if(this.front_weapon){
        this.front_weapon.update(msDuration);
        if(this.fire_front_weapon)this.front_weapon._fire();
    }

    if(this.rear_weapon){
        this.rear_weapon.update(msDuration);
        if(this.fire_rear_weapon)this.rear_weapon._fire();
    }
    
    if(this.util){
        this.util.update(msDuration);
        if(this.fire_util)this.util._fire();
    }

    //spawn smoke if health <40
    if(this.health <= 40){
        if(this.smoke_cd <= 0){
            this.world.spawn_animation('smoke', this.get_world_point([0, -1.5]));
            this.smoke_cd = 100;
        }else{
            this.smoke_cd -= msDuration;
        }
    }else this.smoke_cd = 0;
};

Car.prototype.initialize_shape = function(){
    // make the front of the car pointy, so it slides of walls
    var shape = new box2d.b2PolygonShape();
    var w=this.descr.width / 2;
    var h=this.descr.height / 2;
    shape.SetAsArray([vec(w,h),
                    vec(-w,h),
                    vec(-w, -h),
                    vec(0, -h-0.5),
                    vec(w, -h)]);
    return shape;
};

Car.prototype.get_buff = function(effect){
    for(var i = 0; i < this.buffs.length; i++){
        if(this.buffs[i].effect == effect){
            return this.buffs[i];
        }
    }
    return null;
};
    
Car.prototype.has_effect = function(effect){
    for(var i=0; i<this.buffs.length; i++){
        if(this.buffs[i].effect == effect){
            return true;
        }
    }
    return false;
};
    
Car.prototype.clear_buffs = function(){
    this.buffs.forEach(function(buff){
        this.world.destroy(buff);
    }, this);
};

exports.get_car_parameters=function(position, angle, carpars, alias, engine_sound){
  
    var retv = {
        'car_type' : carpars.type,
        'position' : position,
        'angle' : angle,
        'alias' : alias,
        'handling_upgrades' : carpars.handling_upgrades ? carpars.handling_upgrades : 0,
        'engine_sound' : engine_sound,
        'acc_upgrades' : carpars.acc_upgrades,
        'speed_upgrades' : carpars.speed_upgrades,
        'armor_upgrades' : carpars.armor_upgrades,
        'front_weapon' : carpars.front_weapon ? utils.copy(carpars.front_weapon, {}) : null,
        'util' : carpars.util ? utils.copy(carpars.util, {}) : null,
        'rear_weapon' : carpars.rear_weapon ? utils.copy(carpars.rear_weapon, {}) : null
    };

    return retv;
};

}}, ["gamejs", "utils", "sounds", "buffs", "car_descriptions", "combatracer", "weapons", "weapon_descriptions", "engine", "settings", "animation"]);/* This file has been generated by yabbler.js */
require.define({
"editor": function(require, exports, module) {
var GUI = require('./gamejs-gui');
var ui = require('./ui');
var combatracer = require('./combatracer');
var settings=require('./settings');
var gamejs=require('gamejs');
var renderer=require('./renderer');
var resources=require('./resources');
var skin=require('./skin');

var EXAMPLE='{"size":[2100,1100],"title":"Example Raceway","bgtile":"sand.png","props":[{"p":[413,159],"f":1,"a":270},{"p":[687,158],"f":1,"a":270},{"p":[960,157],"f":1,"a":270},{"p":[310,259],"f":2,"a":240},{"p":[283,350],"f":2,"a":180},{"p":[282,442],"f":2,"a":180},{"p":[283,515],"f":2,"a":150},{"p":[360,579],"f":2,"a":105},{"p":[469,596],"f":2,"a":90},{"p":[561,596],"f":2,"a":90},{"p":[654,596],"f":2,"a":90},{"p":[706,561],"f":2,"a":15},{"p":[725,475],"f":2,"a":15},{"p":[768,388],"f":2,"a":225},{"p":[857,355],"f":2,"a":75},{"p":[957,261],"f":1,"a":270},{"p":[1232,352],"f":2,"a":90},{"p":[1321,351],"f":2,"a":90},{"p":[1310,276],"f":2,"a":330},{"p":[1238,278],"f":3,"a":0},{"p":[1272,278],"f":3,"a":0},{"p":[1307,282],"f":3,"a":0},{"p":[1608,587],"f":2,"a":270},{"p":[1704,586],"f":2,"a":270},{"p":[1577,628],"f":2,"a":150},{"p":[1669,686],"f":2,"a":90},{"p":[1729,626],"f":2,"a":45},{"p":[1802,618],"f":3,"a":0},{"p":[1103,-73],"f":1,"a":270},{"p":[832,-74],"f":1,"a":270},{"p":[562,-73],"f":1,"a":270},{"p":[1367,19],"f":2,"a":285},{"p":[1449,49],"f":2,"a":300},{"p":[1516,115],"f":2,"a":330},{"p":[1558,204],"f":2,"a":345},{"p":[1578,304],"f":2,"a":0},{"p":[1610,361],"f":2,"a":270},{"p":[1702,359],"f":2,"a":270},{"p":[1794,359],"f":2,"a":270},{"p":[1877,359],"f":2,"a":285},{"p":[1943,410],"f":2,"a":330},{"p":[1988,498],"f":2,"a":345},{"p":[2006,598],"f":2,"a":0},{"p":[1992,685],"f":2,"a":15},{"p":[1956,767],"f":2,"a":30},{"p":[1901,839],"f":2,"a":45},{"p":[1833,894],"f":2,"a":75},{"p":[1752,921],"f":2,"a":90},{"p":[1660,927],"f":2,"a":90},{"p":[1557,909],"f":2,"a":105},{"p":[1462,870],"f":2,"a":120},{"p":[1389,810],"f":2,"a":135},{"p":[1352,738],"f":2,"a":165},{"p":[1349,655],"f":2,"a":180},{"p":[1380,622],"f":3,"a":0},{"p":[1352,612],"f":3,"a":0},{"p":[1080,493],"f":1,"a":270},{"p":[988,585],"f":2,"a":90},{"p":[953,645],"f":2,"a":0},{"p":[913,717],"f":2,"a":30},{"p":[853,783],"f":2,"a":60},{"p":[781,826],"f":2,"a":90},{"p":[503,739],"f":1,"a":270},{"p":[410,828],"f":2,"a":90},{"p":[320,825],"f":2,"a":90},{"p":[219,802],"f":2,"a":105},{"p":[133,754],"f":2,"a":135},{"p":[75,689],"f":2,"a":150},{"p":[45,613],"f":2,"a":165},{"p":[-42,349],"f":1,"a":0},{"p":[48,257],"f":2,"a":180},{"p":[53,154],"f":2,"a":210},{"p":[106,74],"f":2,"a":225},{"p":[182,24],"f":2,"a":240},{"p":[289,21],"f":2,"a":270},{"p":[383,19],"f":2,"a":270},{"p":[472,18],"f":2,"a":270}],"decals":[{"p":[114,84],"f":4,"a":0},{"p":[426,36],"f":5,"a":0},{"p":[714,36],"f":5,"a":0},{"p":[1002,36],"f":5,"a":0},{"p":[1290,84],"f":4,"a":90},{"p":[1386,396],"f":6,"a":0},{"p":[1410,636],"f":4,"a":270},{"p":[1716,636],"f":4,"a":180},{"p":[1812,420],"f":7,"a":90},{"p":[1668,420],"f":8,"a":90},{"p":[1578,420],"f":8,"a":90},{"p":[1194,420],"f":9,"a":90},{"p":[1002,420],"f":9,"a":90},{"p":[786,420],"f":7,"a":0},{"p":[762,636],"f":7,"a":180},{"p":[474,612],"f":5,"a":0},{"p":[114,540],"f":4,"a":270},{"p":[114,402],"f":8,"a":180},{"p":[114,342],"f":8,"a":180},{"p":[378,660],"f":8,"a":270},{"p":[1446,372],"f":10,"a":90},{"p":[1524,372],"f":10,"a":90},{"p":[1614,450],"f":10,"a":180},{"p":[1614,540],"f":10,"a":180},{"p":[1062,90],"f":11,"a":90},{"p":[1062,168],"f":11,"a":90},{"p":[1014,102],"f":12,"a":90},{"p":[924,210],"f":12,"a":90},{"p":[822,102],"f":12,"a":90},{"p":[720,210],"f":12,"a":90},{"p":[600,102],"f":12,"a":90},{"p":[480,210],"f":12,"a":90}],"ai_waypoints":[{"p":[1362,212],"n":1},{"p":[1492,504],"n":2},{"p":[1559,750],"n":3},{"p":[928,554],"n":6},{"p":[1849,727],"n":4},{"p":[1814,544],"n":5},{"p":[1109,443],"n":6},{"p":[739,675],"n":7},{"p":[343,688],"n":8},{"p":[228,463],"n":9},{"p":[237,277],"n":10},{"p":[444,186],"n":11}],"checkpoints":[{"p":[1107,45],"n":1},{"p":[1377,648],"n":2},{"p":[1763,409],"n":3},{"p":[787,413],"n":4},{"p":[118,577],"n":5},{"p":[167,67],"n":6}],"start_positions":[{"p":[965,95],"n":1,"a":90},{"p":[872,203],"n":2,"a":90},{"p":[771,98],"n":3,"a":90},{"p":[668,206],"n":4,"a":90},{"p":[546,94],"n":5,"a":90},{"p":[426,202],"n":6,"a":90}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"ilgas.png","6":"kryzius.png","7":"lenktas.png","8":"trumpas.png","9":"paprastas.png","10":"arrow.png","11":"startbar.png","12":"white_bar.png"}}';
var LEFT_PANEL_WIDTH=200;
var BOT_PANEL_HEIGHT=150;
var CHECKPOINT_SIZE=[280, 280];
var MIN_DIMENSION=1000;
var DIMENSION_INCREMENT=100;
var LOAD_HELP_TEXT='To save, copy level code below and save it as a text file on your computer or however is convenient. To load, paste level code into textarea below and click "load".';

var instance_id=1;

function snap(pos){
    return [Math.floor(pos[0]/6)*6,
            Math.floor(pos[1]/6)*6];
};

var drawqueue=['decalinstance', 'propinstance', 'checkpointinstance', 'startpositioninstance', 'aiwaypointinstance'];

var getLevelTemplate=function(size){
    return {'size':size,
            'title':'New track',
            'bgtile':'sand.png',
            'props':[],
            'decals':[],
            'laps':3,
            'ai_waypoints':[],
            'checkpoints':[],
            'start_positions':[]};
            
};



function getLevelProblems(level){
    //validation, returns list of problems (strings), if list empty, level is ok
    var problems=[];
    if(level.start_positions.length<6){
        problems.push('All six starting positions must be placed.');
    }
    if(level.ai_waypoints.length<2){
        problems.push('At least two AI waypoints must be placed.');
    }
    if(level.checkpoints.length<2){
        problems.push('At least two checkpoints must be placed.');
    }
    if(!level.title){
        problems.push('Level must have a title.');
    }
    console.log(problems);
    return problems;
};

function structifyLevel(level){
    var retv=getLevelTemplate([2500, 2500]);
    retv.size=level.size;
    retv.bgtile=level.bgtile;
    retv.title=level.title;
    retv.laps=level.laps;
    retv.dict={};
    var revdict={};
    var i=1;
    function trans(x){
        if(revdict[x]==undefined){
            revdict[x]=i;
            retv.dict[i]=x;
            i++;
        }
        return revdict[x];
    }
    level.props.forEach(function(prop){
       retv.props.push({'p':prop.position,
                       'f':trans(prop.original.filename),
                       'a':prop.angle});
    });
    
    level.decals.forEach(function(decal){
       retv.decals.push({'p':decal.position,
                       'f':trans(decal.original.filename),
                       'a':decal.angle});
    });
    
    level.ai_waypoints.forEach(function(wp){
        retv.ai_waypoints.push({'p':wp.position,
                               'n':wp.number});
    });
    
    level.checkpoints.forEach(function(cp){
        retv.checkpoints.push({'p':cp.position,
                              'n':cp.number});
    });
    
    level.start_positions.forEach(function(sp){
        retv.start_positions.push({'p':sp.position,
                              'n':sp.number,
                              'a':sp.angle});
    });
    return retv;
};

function stringifyLevel(level){
    return JSON.stringify(structifyLevel(level));
};



ToolViewSelectItem=exports.ToolViewSelectItem=function(pars){
    pars.size=[LEFT_PANEL_WIDTH, 22];
    this.what=pars.what;
    ToolViewSelectItem.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'position':[0, 0],
                         'parent':this,
                         'font':ui.getFont(skin.track_selector.item_font),
                         'text':pars.text});
    this.center(this.label);
    this.label.move([this.size[0]-this.label.size[0]-16, this.label.position[1]]);
    this.selected=false;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
};

gamejs.utils.objects.extend(ToolViewSelectItem, GUI.View);

ToolViewSelectItem.prototype.select=function(){
    this.selected=true;
    this.refresh();
    this.despatchEvent({'type':'select', 'what':this.what});
};

ToolViewSelectItem.prototype.deselect=function(){
    this.selected=false;
    this.refresh();
};

ToolViewSelectItem.prototype.paint=function(){
    this.surface.fill(this.selected ? skin.track_selector.front_color : this.isHovered() ? skin.track_selector.item_hover_color : skin.track_selector.back_color);
};

var ToolView=exports.ToolView=function(pars){
    ToolView.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    
    this.scw=new GUI.ScrollableView({'parent':this,
                                    'size':[this.size[0], this.size[1]-20],
                                    'position':[0, 0]});

    var scb=new GUI.HorizontalScrollbar({'parent':this,
                                        'size':[this.size[0], 20],
                                        'position':[0, this.size[1]-20]});
    this.scw.setHorizontalScrollbar(scb);
};
gamejs.utils.objects.extend(ToolView, GUI.View);

var DecalView=exports.DecalView=function(pars){
    DecalView.superConstructor.apply(this, [pars]);
    this.filename_to_decal={};
    resources.decals.forEach(function(filename){
        var tool=new Decal({'filename':filename,
                           'size':[100, 100],
                           'position':[0, 3],
                           'scene':this.scene,
                           'parent':this.scw});
        this.scene.tools.push(tool);
        this.filename_to_decal[filename]=tool;
        tool.on('select', this.scene.selectTool, this.scene);
    }, this);
    GUI.layout.horizontal(this.scw.children, 2, 2);
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(DecalView, ToolView);

//MARKER VIEW

var MarkerView=exports.MarkerView=function(pars){
    this.scene=pars.scene;
    MarkerView.superConstructor.apply(this, [pars]);
    var lbl1=new GUI.Label({'parent':this,
                           'font':ui.getFont('16_33'),
                           'text':'AI Waypoints',
                           'position':[20, 2]});
    
    
    //ai waypoint
    this.ai_waypoint=new AIWaypoint({'parent':this,
                                     'position':[40, 45],
                                     'size':[40, 40],
                                     'scene':this.scene});
    this.scene.tools.push(this.ai_waypoint);
    this.ai_waypoint.on('select', this.scene.selectTool, this.scene);
    
    this.ai_waypoint_up=new ui.IncrementButton({'direction':'up',
                                            'position':[100, 30],
                                            'size':[40, 30],
                                            'parent':this});
    
    this.ai_waypoint_up.onClick(function(){
        this.setNumber(this.number+1);
    }, this.ai_waypoint);
    
    this.ai_waypoint_down=new ui.IncrementButton({'direction':'down',
                                                'position':[100, 70],
                                                'size':[40, 30],
                                                'parent':this});
    
    this.ai_waypoint_down.onClick(function(){
        this.setNumber(this.number-1);
    }, this.ai_waypoint);
    
    //checkpoint
    var lbl2=new GUI.Label({'parent':this,
                           'font':ui.getFont('16_33'),
                           'text':'Checkpoints',
                           'position':[150, 2]});
    
    
    this.checkpoint=new Checkpoint({'parent':this,
                                     'position':[170, 45],
                                     'size':[170, 40],
                                     'scene':this.scene});
    this.scene.tools.push(this.checkpoint);
    this.checkpoint.on('select', this.scene.selectTool, this.scene);
    
    this.checkpoint_up=new ui.IncrementButton({'direction':'up',
                                            'position':[230, 30],
                                            'size':[40, 30],
                                            'parent':this});
    
    this.checkpoint_up.onClick(function(){
        this.setNumber(this.number+1);
    }, this.checkpoint);
    
    this.checkpoint_down=new ui.IncrementButton({'direction':'down',
                                                'position':[230, 70],
                                                'size':[40, 30],
                                                'parent':this});
    
    this.checkpoint_down.onClick(function(){
        this.setNumber(this.number-1);
    }, this.checkpoint);
    
    //start position
    var lbl3=new GUI.Label({'parent':this,
                           'font':ui.getFont('16_33'),
                           'text':'Start Positions',
                           'position':[280, 2]});
    
    
    this.start_position=new StartPosition({'parent':this,
                                     'position':[300, 35],
                                     'size':[60, 60],
                                     'scene':this.scene});
    this.scene.tools.push(this.start_position);
    this.start_position.on('select', this.scene.selectTool, this.scene);
    
    this.start_position_up=new ui.IncrementButton({'direction':'up',
                                            'position':[370, 30],
                                            'size':[40, 30],
                                            'parent':this});
    
    this.start_position_up.onClick(function(){
        this.setNumber(this.number+1);
    }, this.start_position);
    
    this.start_position_down=new ui.IncrementButton({'direction':'down',
                                                'position':[370, 70],
                                                'size':[40, 30],
                                                'parent':this});
    
    this.start_position_down.onClick(function(){
        this.setNumber(this.number-1);
    }, this.start_position);
    
    
};

gamejs.utils.objects.extend(MarkerView, GUI.View)

//PROPERTIES VIEW
var PropertiesView=exports.PropertiesView=function(pars){
    PropertiesView.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    var lbl=new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Title',
                    'position':[100, 2]});
    
    this.title=new GUI.TextInput({'parent':this.scw,
                                 'font':ui.getFont('16_33'),
                                 'text':this.scene.level.title,
                                 'position':[40, 50],
                                 'size':[180, 30]});
    
    this.title.on(GUI.EVT_CHANGE, this.titleChange, this);
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Width, PX',
                    'position':[260, 2]});
    
    this.widthlbl=new GUI.Label({'parent':this.scw,
                                'font':ui.getFont('16_33'),
                                'text':String(this.scene.level.size[0]),
                                'position':[260, 50]});
    
    this.width_up_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[350, 20],
                                          'size':[40, 40],
                                          'direction':'up'});
    
    this.width_up_btn.onClick(function(){
        this.scene.level.size[0]=Math.max(MIN_DIMENSION, this.scene.level.size[0]+DIMENSION_INCREMENT);
        this.scene.resizeLevelView();
    }, this);
    
    this.width_down_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[350, 70],
                                          'size':[40, 40],
                                          'direction':'down'});
    
    this.width_down_btn.onClick(function(){
        this.scene.level.size[0]=Math.max(MIN_DIMENSION, this.scene.level.size[0]-DIMENSION_INCREMENT);
        this.scene.resizeLevelView();
    }, this);
    
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Height, PX',
                    'position':[420, 2]});
    
    this.heightlbl=new GUI.Label({'parent':this.scw,
                                'font':ui.getFont('16_33'),
                                'text':String(this.scene.level.size[1]),
                                'position':[420, 50]});
    
    this.height_up_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[520, 20],
                                          'size':[40, 40],
                                          'direction':'up'});
    
    this.height_up_btn.onClick(function(){
        this.scene.level.size[1]=Math.max(MIN_DIMENSION, this.scene.level.size[1]+DIMENSION_INCREMENT);
        this.scene.resizeLevelView();
    }, this);
    
    this.height_down_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[520, 70],
                                          'size':[40, 40],
                                          'direction':'down'});
    this.height_down_btn.onClick(function(){
        this.scene.level.size[1]=Math.max(MIN_DIMENSION, this.scene.level.size[1]-DIMENSION_INCREMENT);
        this.scene.resizeLevelView();
    }, this);
    
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Laps',
                    'position':[590, 2]});
    
    this.lapslbl=new GUI.Label({'parent':this.scw,
                                'font':ui.getFont('16_33'),
                                'text':String(this.scene.level.laps),
                                'position':[600, 50]});
    
    this.laps_up_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[700, 20],
                                          'size':[40, 40],
                                          'direction':'up'});
    
    this.laps_up_btn.onClick(function(){
        this.scene.level.laps=Math.max(1, this.scene.level.laps+1);
        this.lapslbl.setText(String(this.scene.level.laps));
    }, this);
    
    this.laps_down_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[700, 70],
                                          'size':[40, 40],
                                          'direction':'down'});
    this.laps_down_btn.onClick(function(){
        this.scene.level.laps=Math.max(1, this.scene.level.laps-1);
        this.lapslbl.setText(String(this.scene.level.laps));
    }, this);
    
    this.scw.autoSetScrollableArea();
    
    
}
gamejs.utils.objects.extend(PropertiesView, ToolView)

PropertiesView.prototype.titleChange=function(event){
    this.scene.level.title=event.value;  
};

//PROP VIEW

var PropView=exports.PropView=function(pars){
    PropView.superConstructor.apply(this, [pars]);
    this.filename_to_prop={};
    resources.props.forEach(function(filename){
        var tool=new Prop({'filename':filename,
                           'size':[100, 100],
                           'position':[0, 3],
                           'scene':this.scene,
                           'parent':this.scw});
        this.scene.tools.push(tool);
        this.filename_to_prop[filename]=tool;
        tool.on('select', this.scene.selectTool, this.scene);
    }, this);
    GUI.layout.horizontal(this.scw.children, 2, 2);
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(PropView, ToolView);

//LAYER VIEW

var LayerView=exports.LayerView=function(pars){
    LayerView.superConstructor.apply(this, [pars]);
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Decals',
                    'position':[10, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'decals',
                      'scene':this.scene,
                      'position':[10, 50]});
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Props',
                    'position':[160, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'props',
                      'scene':this.scene,
                      'position':[160, 50]});
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'AI Waypoints',
                    'position':[320, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'ai_waypoints',
                      'scene':this.scene,
                      'position':[320, 50]});
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Checkpoints',
                    'position':[470, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'checkpoints',
                      'scene':this.scene,
                      'position':[470, 50]});
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Start pos.',
                    'position':[620, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'start_positions',
                      'scene':this.scene,
                      'position':[620, 50]});
    
    
    
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(LayerView, ToolView);

//BGVIEW

var BgView=exports.BgView=function(pars){
    BgView.superConstructor.apply(this, [pars]);
    resources.tiles.forEach(function(filename){
        var tool=new BackgroundTile({'filename':filename,
                                    'size':[100, 100],
                                    'position':[0, 3],
                                    'scene':this.scene,
                                    'parent':this.scw});
    }, this);
    GUI.layout.horizontal(this.scw.children, 2, 2);
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(BgView, ToolView);


var Instance=exports.Instance=function(pars){
    Instance.superConstructor.apply(this, [pars]);
    this.instance_id=instance_id++;
    this.angle=pars.angle;
    this.original=pars.original;
    this.subtype='instance';
    this.selected=false;
    this.scene=pars.scene;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
    this.on('select', this.scene.selectInstance, this.scene);
};
gamejs.utils.objects.extend(Instance, GUI.View);

Instance.prototype.select=function(){
    if(!this.selected){
        if(!(this.scene.selected && this.scene.selected.subtype=='tool')){
            this.selected=true;
            this.despatchEvent({'type':'select', 'instance':this});
            this.refresh();
        }
    }
};

Instance.prototype.move=function(pos){
  if(this.selected) GUI.View.prototype.move.apply(this, [pos]);  
};

function removeInstance(instance, list){
    for(var i=0;i<list.length;i++){
        if(list[i].instance_id==instance.instance_id){
            list.splice(i, 1);
            return;
        }
    }
};

Instance.prototype.deselect=function(){
    this.selected=false;
    this.refresh();
};

Instance.prototype.paint=function(){
    this.surface.clear();
    var img=this.original.getCursorImage(this.angle);
    this.surface.blit(img, [(this.size[0]-img.getSize()[0])/2, (this.size[1]-img.getSize()[1])/2]);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

var CheckpointInstance=function(pars){
    CheckpointInstance.superConstructor.apply(this, [pars]);
    GUI.draggable(this);
    this.type='checkpointinstance';
    this.number=pars.number;
      this.on('select', function(){
        this.scene.marker_view.checkpoint.setNumber(this.number);
    }, this);  
};

gamejs.utils.objects.extend(CheckpointInstance, Instance);

CheckpointInstance.prototype.destroy=function(recalc){
    if(recalc===undefined)recalc=true;
    Instance.prototype.destroy.apply(this, []);
    if(recalc){
        removeInstance(this, this.scene.level.checkpoints);
        this.scene.level.checkpoints.forEach(function(cp){
            if(cp.number>this.number){
                cp.number--;
                cp.refresh();
            }
        }, this);
    }
};

CheckpointInstance.prototype.paint=function(){
    this.surface.clear();
    this.surface.blit(this.original.genHugeImage(this.number), [0, 0]);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

//START POSITION INSTANCE
var StartPositionInstance=function(pars){
    StartPositionInstance.superConstructor.apply(this, [pars]);
   // GUI.draggable(this);
    this.type='startpositioninstance';
    this.number=pars.number;
      this.on('select', function(){
        this.scene.marker_view.start_position.setNumber(this.number);
    }, this);
    
};

gamejs.utils.objects.extend(StartPositionInstance, Instance);

StartPositionInstance.prototype.move=function(pos){
  Instance.prototype.move.apply(this, [snap(pos)]);  
};

StartPositionInstance.prototype.destroy=function(recalc){
    
    if(recalc===undefined)recalc=true;
    Instance.prototype.destroy.apply(this, []);
    if(recalc){
        removeInstance(this, this.scene.level.start_positions);
        this.scene.level.start_positions.forEach(function(sp){
            if(sp.number>this.number){
                sp.number--;
                sp.refresh();
            }
        }, this);
    }
};

StartPositionInstance.prototype.paint=function(){
    this.surface.clear();
    this.surface.blit(this.original.genImage(this.number, this.angle), [0, 0]);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

//AI WAYPOINT INSTANCE
var AIWaypointInstance=function(pars){
    AIWaypointInstance.superConstructor.apply(this, [pars]);
    GUI.draggable(this);
    this.type='aiwaypointinstance';
    this.number=pars.number;
      this.on('select', function(){
        this.scene.marker_view.ai_waypoint.setNumber(this.number);
    }, this);
    
};

gamejs.utils.objects.extend(AIWaypointInstance, Instance);

AIWaypointInstance.prototype.destroy=function(recalc){
    if(recalc===undefined)recalc=true;
    Instance.prototype.destroy.apply(this, []);
    if(recalc){
        removeInstance(this, this.scene.level.ai_waypoints);
        this.scene.level.ai_waypoints.forEach(function(wp){
            if(wp.number==this.number) recalc=false;
        }, this);
        if(recalc){
            this.scene.level.ai_waypoints.forEach(function(wp){
                if(wp.number>this.number){
                    wp.number--;
                    wp.refresh();
                }
            }, this);
        }
    }
};

AIWaypointInstance.prototype.paint=function(){
    this.surface.clear();
    this.surface.blit(this.original.genImage(this.number), [0, 0]);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

//DECAL INSTANCE

var DecalInstance=function(pars){
    DecalInstance.superConstructor.apply(this, [pars]);
    this.type='decalinstance';
};

gamejs.utils.objects.extend(DecalInstance, Instance);

DecalInstance.prototype.destroy=function(){
    Instance.prototype.destroy.apply(this, []);
    removeInstance(this, this.scene.level.decals);
};

DecalInstance.prototype.move=function(pos){
  Instance.prototype.move.apply(this, [snap(pos)]);  
};


var PropInstance=function(pars){
    PropInstance.superConstructor.apply(this, [pars]);
    GUI.draggable(this);
    this.type='propinstance';
};

gamejs.utils.objects.extend(PropInstance, Instance);

PropInstance.prototype.destroy=function(){
    Instance.prototype.destroy.apply(this, []);
    removeInstance(this, this.scene.level.props);
};

var BackgroundTile=function(pars){
    this.filename=pars.filename;
    pars.image=renderer.cache.getTile(pars.filename);
    BackgroundTile.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
};
gamejs.utils.objects.extend(BackgroundTile, GUI.Image);

BackgroundTile.prototype.select=function(){
    this.scene.level.bgtile=this.filename;
    this.scene.level_view.refresh();
};

var Tool=exports.Tool=function(pars){
    Tool.superConstructor.apply(this, [pars]);
    this.selected=false;
    this.angle=0;
    this.rotate_angle=pars.rotate_angle;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
    this.subtype='tool';
    this.scene=pars.scene;
};

gamejs.utils.objects.extend(Tool, GUI.Image);

Tool.prototype.select=function(){
    this.selected=true;
    this.despatchEvent({'type':'select', 'tool':this});
    this.refresh();
};

Tool.prototype.rotateLeft=function(){
    this.angle-=this.rotate_angle;
    if(this.angle<0)this.angle+=360;
    this.refresh();
};

Tool.prototype.rotateRight=function(){
    this.angle+=this.rotate_angle;
    if(this.angle>=360)this.angle-=360;
    this.refresh();
};

Tool.prototype.deselect=function(){
    this.selected=false;
    this.refresh();
};

Tool.prototype.paint=function(){
    GUI.Image.prototype.paint.apply(this, []);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

//CHECKPOINT
var Checkpoint=exports.Checkpoint=function(pars){
    pars.image=this.genImage(1);
    pars.rotate_angle=0;
    pars.size=[40, 40];
    pars.rotate_angle=0;
    Checkpoint.superConstructor.apply(this, [pars]);
    this.number=1;
    this.type='checkpoint';
}

gamejs.utils.objects.extend(Checkpoint, Tool);


Checkpoint.prototype.genImage=function(number){
    var s=new gamejs.Surface([40, 40]);
    var font=ui.getFont('editor_checkpoint');
    gamejs.draw.rect(s, 'RGBA(255, 86, 86, 0.2)', new gamejs.Rect([0, 0], s.getSize()));
    font.render(s, String(number), [12, 12]);
    gamejs.draw.rect(s, '#FF5656', new gamejs.Rect([0, 0], s.getSize()), 3);
    return s;
};

Checkpoint.prototype.genHugeImage=function(number){
    var s=new gamejs.Surface([280, 280]);
    var font=ui.getFont('editor_checkpoint');
    gamejs.draw.rect(s, 'RGBA(255, 86, 86, 0.2)', new gamejs.Rect([0, 0], s.getSize()));
    font.render(s, String(number), [130, 130]);
    gamejs.draw.rect(s, '#FF5656', new gamejs.Rect([0, 0], s.getSize()), 3);
    return s;
};

Checkpoint.prototype.getCursorImage=function(){
    return this.genHugeImage(this.number); 
};

Checkpoint.prototype.setNumber=function(number){
    this.number=Math.max(1, number);
    this.setImage(this.genImage(this.number));
};

Checkpoint.prototype.place=function(position){
    var img=this.getCursorImage();
    var sz=CHECKPOINT_SIZE;
    
    var wp;
    //remove previous waypoints w. this number
    for(var i=0;i<this.scene.level.checkpoints.length;i++){
        wp=this.scene.level.checkpoints[i];
        if(wp.number==this.number){
            wp.destroy(false);
        }
    }
    var instance=new CheckpointInstance({'parent':this.scene.level_view,
                                        'size':sz,
                                        'scene':this.scene,
                                        'angle':0,
                                        'original':this,
                                        'number':this.number,
                                        'position':[position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)]});
    this.scene.level.checkpoints.push(instance);
    this.setNumber(this.number+1);
    this.refresh();
};

//START POSITION
var StartPosition=exports.StartPosition=function(pars){
    pars.image=this.genImage(1);
    pars.rotate_angle=90;
    StartPosition.superConstructor.apply(this, [pars]);
    this.type='startposition';
    this.number=1;
}

gamejs.utils.objects.extend(StartPosition, Tool);

StartPosition.prototype.genImage=function(number, angle){
    var s=new gamejs.Surface([60, 60]);
    var font=ui.getFont('editor_start_pos');
    
    
    //ptlist
    var w=s.getSize()[0];
    var h=s.getSize()[1];
    var ptlist=[[10, 10],
                [20, 0],
                [w-20, 0],
                [w-10, 10],
                [w-10, h],
                [10, h]];
                
    
    gamejs.draw.polygon(s, '#3AFF51', ptlist, 3);
    if(angle===undefined) angle=this.angle;
    s=gamejs.transform.rotate(s, angle);
    font.render(s, String(number), [20, 20]);
    return s;
};

StartPosition.prototype.getCursorImage=function(){
    return this.genImage(this.number); 
};

StartPosition.prototype.setNumber=function(number){
    this.number=Math.min(Math.max(1, number), 6);
    this.setImage(this.genImage(this.number));
};

StartPosition.prototype.place=function(position){
    var img=this.getCursorImage();
    var sz=this.size;
    
    var sp;
    //remove previous waypoints w. this number
    for(var i=0;i<this.scene.level.start_positions.length;i++){
        sp=this.scene.level.start_positions[i];
        if(sp.number==this.number){
            sp.destroy(false);
        }
    }

    var instance=new StartPositionInstance({'parent':this.scene.level_view,
                                        'size':sz,
                                        'scene':this.scene,
                                        'angle':this.angle,
                                        'original':this,
                                        'number':this.number,
                                        'position':snap([position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)])});
    this.scene.level.start_positions.push(instance);
    this.setNumber(this.number+1);
    this.refresh();
};

//AI WAYPOINT

var AIWaypoint=exports.AIWaypoint=function(pars){
    pars.image=this.genImage(1);  
    pars.rotate_angle=0;
    AIWaypoint.superConstructor.apply(this, [pars]);
    GUI.draggable(this);
    this.type='aiwaypoint';
    this.number=1;
  
};

gamejs.utils.objects.extend(AIWaypoint, Tool);

AIWaypoint.prototype.genImage=function(number){
    var s=new gamejs.Surface([40, 40]);
    var font=ui.getFont('editor_ai_wp');
    font.render(s, String(number), [12, 12]);
    gamejs.draw.rect(s, '#0094FF', new gamejs.Rect([0, 0], s.getSize()), 3);
    return s;
};

AIWaypoint.prototype.getCursorImage=function(){
    return this.genImage(this.number); 
};

AIWaypoint.prototype.setNumber=function(number){
    this.number=Math.max(1, number);
    this.setImage(this.genImage(this.number));
};

AIWaypoint.prototype.place=function(position){
    var img=this.getCursorImage();
    var sz=img.getSize();
    
    var wp;
    //remove previous waypoints w. this number
    for(var i=0;i<this.scene.level.ai_waypoints.length;i++){
        wp=this.scene.level.ai_waypoints[i];
        if(wp.number>=this.number){
            wp.number++;
        }
    }
    var instance=new AIWaypointInstance({'parent':this.scene.level_view,
                                        'size':sz,
                                        'scene':this.scene,
                                        'angle':0,
                                        'original':this,
                                        'number':this.number,
                                        'position':[position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)]});
    this.scene.level.ai_waypoints.push(instance);
    this.setNumber(this.number+1);
    this.refresh();
};

//DECAL

var Decal=exports.Decal=function(pars){
    pars.image=renderer.cache.getDecalSprite(pars.filename, 0);
    pars.rotate_angle=90;
    Decal.superConstructor.apply(this, [pars]);
    this.type='decal';
    this.filename=pars.filename;
};

gamejs.utils.objects.extend(Decal, Tool);

Decal.prototype.getCursorImage=function(angle){
    if(angle==undefined)angle=this.angle;
    return renderer.cache.getDecalSprite(this.filename, angle);  
};

Decal.prototype.place=function(position){
    var img=this.getCursorImage();
    var sz=img.getSize();
    var instance=new DecalInstance({'parent':this.scene.level_view,
                               'size':sz,
                               'scene':this.scene,
                               'angle':this.angle,
                               'original':this,
                               'position':snap([position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)])});
    this.scene.level.decals.push(instance);
};

//PROP

var Prop=exports.Prop=function(pars){
    pars.image=renderer.cache.getPropSprite(pars.filename, 0);
    pars.rotate_angle=5;
    Prop.superConstructor.apply(this, [pars]);
    this.type='prop';
    this.filename=pars.filename;
    this.scene=pars.scene;
};

gamejs.utils.objects.extend(Prop, Tool);

Prop.prototype.getCursorImage=function(angle){
    if(angle==undefined)angle=this.angle;
    return renderer.cache.getPropSprite(this.filename, angle);  
};

Prop.prototype.place=function(position){
    var img=this.getCursorImage(this.angle);
    var sz=img.getSize();
    var instance=new PropInstance({'parent':this.scene.level_view,
                               'size':sz,
                               'scene':this.scene,
                               'angle':this.angle,
                               'original':this,
                               'position':[position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)]});
    this.scene.level.props.push(instance);
};

//LEVEL VIEW
var LevelView=exports.LevelView=function(pars){
    this.scene=pars.scene;
    LevelView.superConstructor.apply(this, [pars]);
    this.mpos=[0, 0];
    
    this.on(GUI.EVT_MOUSE_MOTION, function(event){
        this.mpos=event.pos;
        this.refresh();
    }, this);
};
gamejs.utils.objects.extend(LevelView, GUI.View);


LevelView.prototype.paint=function(){
    var tile=renderer.cache.getTile(this.scene.level.bgtile);
    var ts=tile.getSize();
    for(var x=0;x<this.size[0];x+=ts[0]){
        for(var y=0;y<this.size[1];y+=ts[1]){
            this.surface.blit(tile, [x, y]);
        }
    }
};

LevelView.prototype.post_paint=function(){
    if(this.isHovered() && this.scene.selected && this.scene.selected.subtype=='tool' && this.scene.selected.getCursorImage){
        var img=this.scene.selected.getCursorImage();
        var sz=img.getSize();
        
        var pos=[parseInt(this.mpos[0]-sz[0]/2), parseInt(this.mpos[1]-sz[1]/2)];
        if(this.scene.selected.type=='decal' || this.scene.selected.type=='startposition'){
            pos=snap(pos);
        }
        this.surface.blit(img, pos);
    }
};

LevelView.prototype.draw=function(){
    var painted=false; //has something been repainted in this view?
    //does this view need repainting?
  
    this.children.forEach(function(child){
        //draw children if this view has been repainted or child has been repainted
        if(child.draw() || this._refresh){
            painted=true;
        }
    }, this);
    
    if(this._refresh || painted){
        this.paint();
        var type;
        for(var i=0;i<drawqueue.length;i++){
            type=drawqueue[i];
            this.children.forEach(function(child){
                if(child.type==type){
                    if(child.visible) this.blitChild(child);
                }
            }, this);
        }
        this.scene.minimap.image.blit(this.surface, new gamejs.Rect([0, 0], this.scene.minimap.image.getSize()),
                                      new gamejs.Rect([0, 0], this.surface.getSize()));
        this.scene.minimap.refresh();
        this.post_paint();
        
        this.despatchEvent({'type':GUI.EVT_PAINT, 'surface':this.surface});
        painted=true;
        this._refresh=false;
    }
    
    return painted;
};

var EditorScene=exports.EditorScene=function(){
    document.getElementById('gjs-canvas').oncontextmenu=new Function("return false");
    this.gui=new GUI.GUI(combatracer.game.display);
    this.gui.on(GUI.EVT_PAINT, function(){
        this.surface.clear();
    }, this.gui);
    
    this.alertdialog=new ui.Dialog({'parent':this.gui,
                           'size':[600, 150]});

    
    this.tools=[];
    
    this.minimap=new GUI.Image({'position':[0, 0],
                               'size':[LEFT_PANEL_WIDTH, LEFT_PANEL_WIDTH],
                               'parent':this.gui,
                               'image':new gamejs.Surface([LEFT_PANEL_WIDTH, LEFT_PANEL_WIDTH])});
    
    this.saveloadbtn=new ui.Button({'position':[0, 210],
                                    'size':[190, 50],
                                    'parent':this.gui,
                                    'text':'Save / Load',
                                    'lean':'left'});
    this.saveloadbtn.onClick(function(){
        this.textarea.value=stringifyLevel(this.level);
        $(this.dialogel).dialog('open');
    }, this);
    
    this.playdialog=new PlayDialog({'parent':this.gui,
                                   'scene':this});
    
    this.playbtn=new ui.Button({'position':[0, 270],
                                    'size':[190, 50],
                                    'parent':this.gui,
                                    'text':'Play',
                                    'lean':'left'});
    
    this.playbtn.onClick(function(){this.show();}, this.playdialog);
    
    this.helpbtn=new ui.Button({'position':[0, 330],
                                    'size':[190, 50],
                                    'parent':this.gui,
                                    'text':'Help',
                                    'lean':'left'});
    
    this.helpbtn.onClick(function(){
        window.open('http://www.banditracer.eu/index.php?page=track-editor-help');
    }, this);
    
    this.backbtn=new ui.Button({'position':[0, 390],
                                    'size':[190, 50],
                                    'parent':this.gui,
                                    'text':'Back',
                                    'lean':'left'});
    
    this.backbtn.onClick(function(){
        combatracer.game.showTitle();
    }, this);
    
    
    
    this.dialog=new ui.Dialog({'parent':this.gui,
                                'size':[450, 150]});
    
    this.scw=new GUI.ScrollableView({'parent':this.gui,
                                    'position':[LEFT_PANEL_WIDTH, 0],
                                    'size':[this.gui.size[0]-LEFT_PANEL_WIDTH-20, this.gui.size[1]-BOT_PANEL_HEIGHT-20]});
    
    this.hscrollbar=new GUI.HorizontalScrollbar({'parent':this.gui,
                                                'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT-20],
                                                'size':[this.gui.size[0]-LEFT_PANEL_WIDTH-20, 20]});
    this.scw.setHorizontalScrollbar(this.hscrollbar);
    
    this.vscrollbar=new GUI.VerticalScrollbar({'parent':this.gui,
                                              'position':[this.gui.size[0]-20, 0],
                                              'size':[20, this.gui.size[1]-BOT_PANEL_HEIGHT-20]});
    this.scw.setVerticalScrollbar(this.vscrollbar);
    
    this.level=getLevelTemplate([2500, 2500]);
    
    this.level_view=new LevelView({'parent':this.scw,
                                    'size':[20, 20],
                                    'scene':this,
                                    'position':[0, 0]});
    
    
    this.decal_view=new DecalView({'parent':this.gui,
                                 'scene':this,
                                 'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                 'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    
    this.prop_view=new PropView({'parent':this.gui,
                                 'scene':this,
                                 'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                 'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    this.prop_view.hide();
    
    this.marker_view=new MarkerView({'parent':this.gui,
                                 'scene':this,
                                 'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                 'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    this.marker_view.hide();
    
    this.bg_view=new BgView({'parent':this.gui,
                            'scene':this,
                            'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                            'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    this.bg_view.hide();
    
    this.layer_view=new LayerView({'parent':this.gui,
                            'scene':this,
                            'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                            'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    
    this.layer_view.hide();
    
    this.properties_view=new PropertiesView({'parent':this.gui,
                                            'scene':this,
                                            'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                            'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    this.properties_view.hide();
    
    this.select_decal_view=new ToolViewSelectItem({'parent':this.gui,
                                                  'what':'decalView',
                                                  'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                                  'text':'Decals'});
    this.select_decal_view.on('select', this.selectView, this);
    this.select_decal_view.selected=true;
    
    this.select_prop_view=new ToolViewSelectItem({'parent':this.gui,
                                                  'what':'propView',
                                                  'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22],
                                                  'text':'Props'});
    this.select_prop_view.on('select', this.selectView, this);
    
    this.select_marker_view=new ToolViewSelectItem({'parent':this.gui,
                                                  'what':'markerView',
                                                  'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22*2],
                                                  'text':'Markers'});
    this.select_marker_view.on('select', this.selectView, this);
    
    this.select_bg_view=new ToolViewSelectItem({'parent':this.gui,
                                               'what':'bgView',
                                               'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22*3],
                                               'text':'Background'});
    this.select_bg_view.on('select', this.selectView, this);
    
    this.select_properties_view=new ToolViewSelectItem({'parent':this.gui,
                                               'what':'propertiesView',
                                               'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22*4],
                                               'text':'Properties'});
    this.select_properties_view.on('select', this.selectView, this);
    
    this.select_layer_view=new ToolViewSelectItem({'parent':this.gui,
                                               'what':'layerView',
                                               'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22*5],
                                               'text':'Layers'});
    this.select_layer_view.on('select', this.selectView, this);
    
    
    this.gui.on(GUI.EVT_MOUSE_WHEEL, this.mouseWheel, this);
    this.level_view.on(GUI.EVT_MOUSE_DOWN, this.viewMouseDown, this);
    this.gui.on(GUI.EVT_MOUSE_DOWN, this.mouseDown, this);
    this.level_view.on(GUI.EVT_KEY_DOWN, this.keyDown, this);
    
    //init jquery dialog
    this.dialogel=document.getElementById('saveload_dialog');
    if(!this.dialogel){
        this.dialogel=document.createElement('div');
        this.dialogel.id='saveload_dialog';
        var p=document.createElement('p');
        p.innerHTML=LOAD_HELP_TEXT;
        this.dialogel.appendChild(p);
        this.textarea=document.createElement('textarea');
        this.textarea.style.width='400px';
        this.textarea.style.height='300px';
        this.dialogel.appendChild(this.textarea);
        document.body.appendChild(this.dialogel);
        $(this.dialogel).click(function(event){
            event.stopPropagation();
            // do something
          });  
    }
    $(this.dialogel).dialog({ autoOpen: false ,
                            title:'Save / Load',
                            width:460,
                       buttons: [
    {
        text: 'New',
        'click':function(){
            combatracer.game.editor_scene.loadLevel(getLevelTemplate([2500, 2500]));
            $(this).dialog("close");
        }
        
    },
    {
        text: "Load example",
        click: function() { combatracer.game.editor_scene.loadExample();
                            $(this).dialog("close");}
    },
    {
        text: "Load",
        click: function() { combatracer.game.editor_scene.load();
                            $(this).dialog("close");}
    },
    {
        text: "Close",
        click: function() { $(this).dialog("close"); }
    }]});
    
    $(this.dialogel).scene=this;
    
    this.loadLevel(this.level);

};

EditorScene.prototype.selectView=function(event){
    if(event.what=='decalView'){
        this.decal_view.show();
    }else{
        this.decal_view.hide();
        this.select_decal_view.deselect();
    }
    
    if(event.what=='propView'){
        this.prop_view.show();
    }else{
        this.prop_view.hide();
        this.select_prop_view.deselect();
    }
    
    if(event.what=='markerView'){
        this.marker_view.show();
    }else{
        this.marker_view.hide();
        this.select_marker_view.deselect();   
    }
    
    if(event.what=='bgView'){
        this.bg_view.show();
    }else{
        this.bg_view.hide();
        this.select_bg_view.deselect();
    }
    
    if(event.what=='propertiesView'){
        this.properties_view.show();
    }else{
        this.properties_view.hide();
        this.select_properties_view.deselect();
    }
    
    if(event.what=='layerView'){
        this.layer_view.show();
    }else{
        this.layer_view.hide();
        this.select_layer_view.deselect();
    }
    
    
};

EditorScene.prototype.mouseDown=function(event){
    if(event.button==2){
        this.deselectEverything();
        this.selected=null;
    }
};

EditorScene.prototype.destroyInstance=function(instance){
    instance.destroy();
    this.deselectEverything(this.instance);
    if(this.selected.subtype=='instance' && this.selected.instance_id==instance.instance_id) this.selected=null;
};

EditorScene.prototype.keyDown=function(event){
    if(this.selected && this.selected.subtype=='instance' && event.key==46){
        this.destroyInstance(this.selected);
    }
};

EditorScene.prototype.viewMouseDown=function(event){
    if(event.button==0){
        if(this.selected && this.selected.place){
            this.selected.place(event.pos);
        }
    }
};

EditorScene.prototype.selectTool=function(event){
    var tool=this.selected=event.tool;
    this.deselectEverything(tool);
};

EditorScene.prototype.deselectEverything=function(obj){
    this.tools.forEach(function(tool){
        if(!obj ||(!((tool.type==obj.type) && (tool.filename==obj.filename)))){
            tool.deselect();
        }
    }, this);
    
    this.level_view.children.forEach(function(instance){
        if(!obj || (!((instance.instance_id==obj.instance_id)))){
            instance.deselect();
        }
    }, this);
};

EditorScene.prototype.selectInstance=function(event){
    
    var instance=this.selected=event.instance;
    this.deselectEverything(instance);
    
};

EditorScene.prototype.mouseWheel=function(event){
    if(this.selected){
        if(event.delta<0){
            if(this.selected.rotateRight)for(var i=0;i<Math.abs(event.delta);i++) this.selected.rotateRight();
        }
        else if (event.delta>0){
            if(this.selected.rotateLeft)for(var i=0;i<Math.abs(event.delta);i++) this.selected.rotateLeft();
        }
    }
};

EditorScene.prototype.loadExample=function(){
  try{
    this.loadLevel(JSON.parse(EXAMPLE));
  }catch(e){
    alert('failed! '+e);
  }
};



EditorScene.prototype.load=function(){
  try{
    this.loadLevel(JSON.parse(this.textarea.value));
  }catch(e){
    alert('failed! '+e);
  }
};

EditorScene.prototype.resizeLevelView=function(){
    var size=this.level.size;
    var w=size[0], h=size[1];
    this.level_view.resize(size);
    this.scw.autoSetScrollableArea();
    this.properties_view.widthlbl.setText(String(w));
    this.properties_view.heightlbl.setText(String(h));
    var q=Math.max(w, h)/(LEFT_PANEL_WIDTH-2);
    var minimap_size=[parseInt(w/q), parseInt(h/q)];
    this.minimap.resize(minimap_size);
    this.minimap.image=new gamejs.Surface(minimap_size);
};

EditorScene.prototype.loadLevel=function(level){
    this.level=getLevelTemplate(level.size);
    this.level.bgtile=level.bgtile;
    this.level.title=level.title;
    if(level.laps) this.level.laps=level.laps;
    this.properties_view.title.setText(level.title);
    this.properties_view.lapslbl.setText(String(this.level.laps));
    this.resizeLevelView();
    this.level_view.children=[];
    
    var prop, decal, instance;
    level.decals.forEach(function(dip){
        decal=this.decal_view.filename_to_decal[level.dict[dip.f]];
        instance=new DecalInstance({'parent':this.level_view,
                               'size':decal.getCursorImage().getSize(),
                               'scene':this,
                               'angle':dip.a,
                               'original':decal,
                               'position':dip.p});
        this.level.decals.push(instance);
    }, this);
    
    level.props.forEach(function(pid){
        prop=this.prop_view.filename_to_prop[level.dict[pid.f]];
        instance=new PropInstance({'parent':this.level_view,
                               'size':prop.getCursorImage(pid.a).getSize(),
                               'scene':this,
                               'angle':pid.a,
                               'original':prop,
                               'position':pid.p});
        this.level.props.push(instance);
    }, this);
    
    
    
    var max_ai_n=0, max_cp_n=0, max_sp_n=0;
    
    level.ai_waypoints.forEach(function(aip){
        instance=new AIWaypointInstance({'parent':this.level_view,
                                        'size':this.marker_view.ai_waypoint.getCursorImage().getSize(),
                                        'scene':this,
                                        'angle':0,
                                        'number':aip.n,
                                        'original':this.marker_view.ai_waypoint,
                                        'position':aip.p});
        this.level.ai_waypoints.push(instance);
        max_ai_n=Math.max(max_ai_n, aip.n);
    }, this);
    this.marker_view.ai_waypoint.setNumber(max_ai_n+1);
    
    level.checkpoints.forEach(function(cp){
        
        instance = new CheckpointInstance({'parent':this.level_view,
                                        'size':CHECKPOINT_SIZE,
                                        'scene':this,
                                        'angle':0,
                                        'original':this.marker_view.checkpoint,
                                        'number':cp.n,
                                        'position':cp.p});
        this.level.checkpoints.push(instance);
        max_cp_n=Math.max(max_cp_n, cp.n);
    }, this);
    this.marker_view.checkpoint.setNumber(max_cp_n+1);
    
    level.start_positions.forEach(function(sp){
        instance=new StartPositionInstance({'parent':this.level_view,
                                       'size':this.marker_view.start_position.size,
                                       'scene':this,
                                       'angle':sp.a,
                                       'original':this.marker_view.start_position,
                                       'number':sp.n,
                                       'position':sp.p});
        this.level.start_positions.push(instance);
        max_sp_n=Math.max(max_sp_n, sp.n);
    }, this);
    this.marker_view.start_position.setNumber(max_sp_n+1);
    this.level_view.refresh();
};

EditorScene.prototype.alert=function(){
    this.dialog.show(text, button);
};

EditorScene.prototype.clearAlert=function(){
    this.dialog.close();
};

EditorScene.prototype.handleEvent=function(event){
    this.gui.despatchEvent(event);  
};

EditorScene.prototype.alert=function(text, button){
    this.alertdialog.show(text, button);
};
    
EditorScene.prototype.clearAlert=function(){
    this.alertdialog.close();
};
    

EditorScene.prototype.update=function(msDuration){
    if(this.ping){
        this.ms_to_ping-=msDuration;
        if(this.ms_to_ping<=0){
            this.game.getCommunicator().queueMessage('PING');
            this.ms_to_ping=10000;
        }
    }
    this.gui.update(msDuration);
};

EditorScene.prototype.draw=function(display){
    this.gui.draw();  
};

function LayerOnOffBtn(pars){
    pars.text='On';
    pars.size=[100, 40];
    LayerOnOffBtn.superConstructor.apply(this, [pars]);
    this.layer=pars.layer;
    this.scene=pars.scene;
    this.is_on=true;
    this.onClick(this.onclick, this);
};

gamejs.utils.objects.extend(LayerOnOffBtn, ui.Button);

LayerOnOffBtn.prototype.onclick=function(){
    if(this.is_on){
        this.scene.level[this.layer].forEach(function(obj){
           obj.hide(); 
        });
        this.is_on=false;
        this.setText('Off');
    }
    else{
        this.scene.level[this.layer].forEach(function(obj){
           obj.show(); 
        });
        this.is_on=true;
        this.setText('On');
    }
};

function PlayDialog(pars){
    pars.size=[220, 300];
    PlayDialog.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    
    this.playbtn=new ui.Button({'parent':this,
                                'text':'Play',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 20]});
    
    this.playbtn.onClick(function(){
        this.close();
        var problems=getLevelProblems(this.scene.level);
        if(problems.length){
            this.scene.alert(problems[0]);
        }
        else combatracer.game.playLevel(structifyLevel(this.scene.level), false, false, 'editor');
    }, this);
    
    this.testaibtn=new ui.Button({'parent':this,
                                'text':'Test AI',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 70]});
    
    this.testaibtn.onClick(function(){
        this.close();
        var problems=getLevelProblems(this.scene.level);
        if(problems.length){
            this.scene.alert(problems[0]);
        }
        else combatracer.game.playLevel(structifyLevel(this.scene.level), true, false, 'editor');
    }, this);
    
    this.cancelbtn=new ui.Button({'parent':this,
                                'text':'Cancel',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 120]});
    
    this.cancelbtn.onClick(function(){
        this.close();
    }, this);
    
};

gamejs.utils.objects.extend(PlayDialog, GUI.Dialog);


}}, ["gamejs-gui", "ui", "combatracer", "settings", "gamejs", "renderer", "resources", "skin"]);/* This file has been generated by yabbler.js */
require.define({
"sounds": function(require, exports, module) {
var gamejs = require('gamejs');
var resources = require('./resources');
var settings = require('./settings');
var engine = require('./engine');
var _sounds = {};
var _playing = 0;

function Engine() {
    this.audios={}
    this.playing=null;
    var s;

    this.play=function(pitch){
        if(this.playing!=pitch){
            for(var p=0;p<=5;p++){
                if(p!=pitch){
                    this.audios[p].stop();
                }else{       
                    this.audios[p].play();
                    this.playing=this.audios[p];
                }
            }    
        }
    };
    
    this.play_by_speed=function(speed, max_speed){
        if(speed < 5){
            this.play(0) //idle
        }
        else{
            this.play(Math.min(parseInt(Math.ceil((speed*10)/(max_speed*2))), 5));   
        }
    };
    
    this.stop=function(){
        return;
        for(var p in this.audios){
            this.audios[p].stop();
        }
        this.playing=null;
    };
    
    for(var i = 0; i <= 5; i++){
        this.audios[i] = new engine.Sound('sounds/engine/loop_'+i+'.wav', true);
    }
}
exports.play = function(pars){
    if(settings.get('sound'))engine.play_sound('sounds/fx/'+pars.filename); 
};
exports.engine = null;

exports.init = function(){
    //exports.engine = new Engine();
};


}}, ["gamejs", "resources", "settings", "engine"]);/* This file has been generated by yabbler.js */
require.define({
"gamescenes": function(require, exports, module) {
var gamejs=require('gamejs');
var utils=require('./utils');
var sounds=require('./sounds');
var combatracer=require('./combatracer');
var cars=require('./cars');
var bots=require('./bots');
var GUI = require('./gamejs-gui');
var vec=utils.vec;
var arr=utils.arr;
var ui=require('./ui');
var leagues=require('./leagues');

var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
radians=math.radians;
degrees=math.degrees;

var world=require('./world');
var renderer=require('./renderer');
var settings=require('./settings');
var controllers=require('./controllers');
var car_descriptions=require('./car_descriptions');

var LevelScene=exports.LevelScene=function(level){
    this.game=combatracer.game;
    this.level=level;
    this.cache=renderer.cache;
    this.started=false;
    this.paused=false;
    this.time_to_start=3000;
    this.controllers=[];
    this.keys_down={};
    this.started=false;
    this.max_laps=level.laps? level.laps : 3;
    this.world = world.build_world(level, world.MODE_STANDALONE);
    this.gui=new GUI.GUI(this.game.display);
    var i;
    //BUILD BACKGROUND FROM TILES
    this.background=utils.renderLevelBackground(level, true);

    this.renderer=new renderer.RaceRenderer(settings.get('SCREEN_WIDTH'), 
                                            settings.get('SCREEN_HEIGHT'), 
                                            this.world, 
                                            this.background, 
                                            this.cache);

    this.handleEvent=function(event){
        if (event.type === gamejs.event.KEY_DOWN) {
            this.keys_down[event.key] = true;
            if(event.key===gamejs.event.K_SPACE){
               this.paused=(!this.paused);
            };
            if(event.key===gamejs.event.K_ESC){
                if(this.dialog){
                    if(!this.dialog.visible){
                        this.paused=true;
                        this.dialog.show();
                    }else{
                        this.paused=false;
                        this.dialog.hide();
                    }
                };
            };
        } else if (event.type === gamejs.event.KEY_UP) {
            this.keys_down[event.key] = false;
        };
        this.gui.despatchEvent(event);
    };

    this.updateZoom=function(msDuration){
        //upd zoom
        if(this.keys_down[gamejs.event.K_p]) this.renderer.increaseZoom();
        else if(this.keys_down[gamejs.event.K_l]) this.renderer.decreaseZoom();
    };
    
    this.destroy=function(){
        //if(settings.get('SOUND')) sounds.engine.stop();  
    };
};


var MultiplayerLevelScene=exports.MultiplayerLevelScene=function(game, level, cache){
    MultiplayerLevelScene.superConstructor.apply(this, [game, level, cache]);
    this.game=game;
    this.processed_events={};
    this.world.mode=world.MODE_CLIENT;
    this.last_event_no=0; //the last event that was processed
    this.last_known_event_no=0; //the last known event
    this.queued_updates=[];
    this.time_to_start=3000;
    this.player_car=null;
    this.upds_stacked=0;
    this.time=0;
    this.delta=0;
    this.last_t=null;
    this.deltas=[];
    this.delta_q=0;
    this.states={};
    this.queued_events={};
    this.extradelay=50;
    this.last_upd_time=0;
    this.carid=null;
    this.bfs=0;//bad frames;
    this.send_update=true; //send update to server?
    this.time_since_last_update_sent=0;
    this.state=1; // 1 - participating, 2- finished

    this.controllers[this.controllers.length]=this.controller=new controllers.MultiplayerController();

    this.setState=function(target_time){
        /*
        set state of object for target server time
        */

        //find the two nearest known states from both sides of target time
        var mint=0;
        var maxt=0;
        for(var t in this.states){
            if(t==target_time){
                mint=t;
                maxt=0;
                break;
            }
            if(t<target_time && t > mint)mint=t;
            else if(t>target_time && (t<maxt || maxt===0))maxt=t;
        }
        
        if(mint||maxt){
            var minst=this.states[mint];
            var maxst=maxt ? this.states[maxt] : null;
            var q=0;

            //if both states are known, calc difference coeficient
            if(mint&&maxt){
                q=(target_time-mint)/(maxt-mint);
            }

            //for each object in first state
            var state, obj;
            for(var objid in minst){
                obj=this.world.getObjectById(objid);
                if(obj){
                    //if second state is known and object is interpolatable, get interpolated state
                    if(maxst && maxst[objid] && obj.interpolate){
                        state=obj.interpolate(minst[objid], maxst[objid], q);
                        this.last_upd_time=target_time;
                    }
                    //else state is min state
                    else{
                        this.bfs++;
                        state=minst[objid];
                        this.last_upd_time=mint;
                    }
                    obj.setState(state);
                }
            }
        }else{
            console.log('no known state!');
        }
    };

    this.update=function(msDuration){
        this.time+=msDuration;
        this.handleWorldUpdate();
        this.paused=false;
        this.updateZoom(msDuration);

        if(this.time_to_start<0)this.started=true;

        var target_time=this.time+this.delta-10;
        this.processEvents(target_time);

        if(this.started){
            //set object state
            this.setState(target_time);

            if(target_time>this.last_upd_time){
                var d=target_time-this.last_upd_time
                this.world.b2world.Step(d/1000, 10, 8);
                this.world.b2world.ClearForces();
                this.last_upd_time=target_time;
            }

            //update controllers
            this.controllers.forEach(function(c) {
                if(c.update(this.keys_down, msDuration)) this.send_update = true;
            }, this);
            //update world
            this.world.update(msDuration);
        }

        this.time_since_last_update_sent+=msDuration;
        if(this.time_since_last_update_sent>1000 && (!this.send_update))this.send_update=true;
        this.sendInfo();
     };

    this.sendInfo=function(){
        //if(this.upds_stacked<5){
         if(this.send_update){
            this.game.getCommunicator().queueMessage('GAME_UPDATE', {'actions':this.controller.actions, 'eventno':this.last_known_event_no});
           // console.log('sent update');
            this.send_update=false;
            this.time_since_last_update_sent=0;
        }
    };

    this.processEvents=function(target_time){
        while(this.queued_events[this.last_event_no+1]&&(this.queued_events[this.last_event_no+1].t<=target_time)){
            var event=this.queued_events[this.last_event_no+1];
            this.world.handleEvent(event.type, event.descr);
            this.last_event_no=event.no;
           // this.send_update=true;
            delete this.queued_events[event.no];
            if((!this.player_car) && this.carid){
                obj=this.world.getObjectById(this.carid);
                if(obj){
                    this.player_car=obj;
                    this.renderer.follow(obj);
                    this.game.getCommunicator().queueMessage('GAME_READY',{});
                }
            }
        }
    };

    this.handleWorldUpdate=function(){
        this.queued_updates.forEach(function(update) {
            this.time_to_start=update.tts;
            this.state=update.st;
            update.events.forEach(function(event) {
                if(event.no>this.last_event_no && (!this.queued_events[event.no])){
                    event.t=update.t;
                    this.queued_events[event.no]=event;
                    this.last_known_event_no=event.no;
                }
            }, this);
            this.carid=update.carid;
            //put this state in states array
            this.states[update.t]=update.states;
            this.last_t=update.t;
            this.upds_stacked=0;
        }, this);

        //remove old states, taking care to leave at least one

        for(var t in this.states){
            if((t < (this.time+this.delta-300)) &&(t!=this.last_t)){
                delete this.states[t];
            }
        }


        if(this.queued_updates.length){
            var update = this.queued_updates[0];
            var delta=this.time-update.t;
            this.deltas.push(delta);
            dlen=this.deltas.length;
            this.delta_q+=delta;
            if(dlen>60){
                this.delta_q-=this.deltas.shift();
                dlen=60;
            }
            this.delta=parseInt(this.delta_q/dlen);
        }
        this.queued_updates=[];
    };

    this.draw=function(display, msDuration){
        //render world
        this.renderer.render(display);
       
        //play engine sounds
        /*if(settings.get('SOUND') && settings.get('ENGINE_SOUND')){
            if(this.renderer.follow_object && (this.renderer.follow_object.type=='car'))
                sounds.engine.play_by_speed(this.renderer.follow_object.getSpeedKMH(), this.renderer.follow_object.max_speed);
                
        }*/

        //if finished, spectate a live player
        if(this.state==2){
            if(this.renderer.follow_object.active==false){
                this.world.objects.car.some(function(car) {
                    if(car.active){
                        this.renderer.follow_object=car;
                        return true;
                    }
                    return false;
                }, this);
            }
        }

       //render HUD
       this.renderer.renderHUD(display, {'car':this.player_car,
                                         'max_laps':this.max_laps,
                                         'time_to_start':this.time_to_start,
                                         'paused':this.paused,
                                         'delta':this.delta,
                                         'msDuration':msDuration,
                                         'bfs':this.bfs,
                                         'message':this.state==2 ? 'Finished!' : ''});
    };

    this.handleMessage=function(cmd, payload){
        if(cmd=='GAME_UPDATE'){
            this.queued_updates[this.queued_updates.length]=payload;
        }
        else if(cmd=='GAME_OVER'){
            this.game.showGameOver(payload.table);
        }
        else if(cmd=='CRITICAL_ERR'){
            this.returnToTitle();
            this.game.title_scene.alert(payload.text);
        }
    };
};
gamejs.utils.objects.extend(MultiplayerLevelScene, LevelScene);

var SingleplayerLevelScene=exports.SingleplayerLevelScene=function(level, ai_test){
    SingleplayerLevelScene.superConstructor.apply(this, [level]);
    
    this.dialog=new SinglePlayerDialog({'parent':this.gui,
                                       'scene':this});

    this.test_ai=ai_test;

    //PLAYER CAR
    //carEventFromDescription=function(position, carpars, alias, engine_sound){
    var pars = cars.get_car_parameters([this.world.start_positions[1].x, this.world.start_positions[1].y],this.world.start_positions[1].angle,
                                        combatracer.game.player.singleplayer.car,
                                        combatracer.game.player.alias,
                                        true);
    this.player_car = this.world.create(cars.Car, pars);
    
    if(!this.test_ai) this.controllers.push(new controllers.PlayerCarController(this.player_car));
    else this.controllers.push(new controllers.AIController(this.player_car, this.world, this));


    var league=leagues[this.game.player.singleplayer.league];
    if(!this.test_ai){
    //BUILD AI CARS
        var aicar;
        for(i=1;i<4;i++){
            if(this.world.start_positions[i+1]){
                var descr = bots[league.bots[i-1]];
                var pars = cars.get_car_parameters([this.world.start_positions[i+1].x, this.world.start_positions[i+1].y],this.world.start_positions[i+1].angle,
                                                    descr,
                                                    descr.name,
                                                    false);
                                                            
                //hell difficulty: buff all stats & weapons
			    if(combatracer.game.player.singleplayer.difficulty == 4){
			    	pars.acc_upgrades = 5;
			    	pars.speed_upgrades = 5;
			    	pars.armor_upgrades = 5;
			    	(['util', 'rear_weapon', 'front_weapon']).forEach(function(t){
			    		if(this[t]){
			    			this[t].ammo_upgrades = Math.min(this[t].ammo_upgrades+2, 5);
			    			this[t].damage_upgrades = Math.min(this[t].damage_upgrades+2, 5);
			    		}
			    	}, pars);
			    }                                            
                                                            
                aicar = this.world.create(cars.Car, pars);
                this.controllers.push(new controllers.AIController(aicar, this.world, this));
            }
        }
    }
    

    this.renderer.follow(this.player_car);

    this.update = function(msDuration) {
        this.updateZoom(msDuration);
        if(this.time_to_start>-1000){
            this.time_to_start-=msDuration;
            if(this.time_to_start<0)this.started=true;
        }
        
        if(!this.paused && this.started){
            //update controllers
            this.controllers.forEach(function(c) {
               c.update(this.keys_down, msDuration);
            }, this);
            
            //update world
            this.world.update(msDuration);
        
            //update physics
            this.world.b2world.Step(msDuration / 1000, 10, 8);
            this.world.b2world.ClearForces();
        }

        //if we reached max laps, end race
        if(this.player_car.lap > this.max_laps){        
            this.game.showSPGameOver(this.genScoreTable(), this.player_car.get_race_position(), this);
            return;
        };
    };

    this.draw = function(display, msDuration) {
        //render world
        this.renderer.render(display);
        
        //play engine sounds
       /* if(settings.get('SOUND')){            
            if(this.renderer.follow_object && (this.renderer.follow_object.has_tag('car')))
                sounds.engine.play_by_speed(this.renderer.follow_object.get_speed_KMH(), this.renderer.follow_object.max_speed);
                
        }*/
  
        //render HUD
        this.renderer.renderHUD(display, {'car':this.player_car,
                                        'max_laps':this.max_laps,
                                        'msDuration':msDuration,
                                        'time_to_start':this.time_to_start,
                                        'paused':this.paused});
        
        if(this.dialog.visible) this.gui.draw(true);
   };
   
   this.genScoreTable=function(){
        var table= this.world.get_objects_by_tag('car').map(function(car, idx) {
             return {'place':car.get_race_position(),
                    'id':idx,
                    'player':car.alias,
                    'kills':car.kills,
                    'deaths': car.deaths
            }
         });
        table.sort(function(a, b){
           if(a.place>b.place) return 1;
           else if(a.place<b.place) return -1;
           return 0;
        });
        
        return table;
   };

   this.handleMessage=function(cmd, payload){
        return; //single player: just ignore server messages.
    };
};
gamejs.utils.objects.extend(SingleplayerLevelScene, LevelScene);



function SinglePlayerDialog(pars){
    pars.size=[220, 200];
    SinglePlayerDialog.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    
    this.quitbtn=new ui.Button({'parent':this,
                                'text':'Quit',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 20]});
    
    this.quitbtn.onClick(function(){
        this.close();      
        this.scene.game.showSPGameOver(this.scene.genScoreTable(), 0, this.scene);
    }, this);
    
    
    this.continuebtn=new ui.Button({'parent':this,
                                'text':'Continue',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 70]});
    
    this.continuebtn.onClick(function(){
        this.close();
        this.scene.paused=false;
    }, this);
    
};

gamejs.utils.objects.extend(SinglePlayerDialog, GUI.Dialog);
}}, ["gamejs", "utils", "sounds", "combatracer", "cars", "bots", "gamejs-gui", "ui", "leagues", "world", "renderer", "settings", "controllers", "car_descriptions"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/image": function(require, exports, module) {
var gamejs = require('../gamejs');

/**
 * @fileoverview Load images as Surfaces.
 *
 * Sounds & Images are loaded relative to your game's html page
 * (the html which includes the GameJs code) or relative to the 
 * property `window.$g.resourceBaseHref`
 * if it is set.
 *
 *
 */

var CACHE = {};

/**
 * need to export preloading status for require
 * @ignore
 */
var _PRELOADING = false;

/**
 * Load image and return it on a Surface.
 *
 * All images must be preloaded before they can be used.
 * @example
 
 *     gamejs.preload(["./images/ship.png", "./images/sunflower.png"]);
 *     // ...later...
 *     display.blit(gamejs.image.load('images/ship.png'))
 *
 * @param {String|dom.Image} uriOrImage resource uri for image
 * @returns {gamejs.Surface} surface with the image on it.
 */
exports.load = function(key) {
   var img;
   if (typeof key === 'string') {
      img = CACHE[key];
      if (!img) {
         // TODO sync image loading
			throw new Error('Missing "' + key + '", gamejs.preload() all images before trying to load them.');
      }
   } else {
      img = key;
   }
   var canvas = document.createElement('canvas');
   // IEFIX missing html5 feature naturalWidth/Height
   canvas.width = img.naturalWidth || img.width;
   canvas.height = img.naturalHeight || img.height;
   var context = canvas.getContext('2d');
   context.drawImage(img, 0, 0);
   img.getSize = function() { return [img.naturalWidth, img.naturalHeight]; };
   var surface = new gamejs.Surface(img.getSize());
   // NOTE hack setting protected _canvas directly
   surface._canvas = canvas;
   surface._context = context;
   return surface;
};


/**
 * add all images on the currrent page into cache
 * @ignore
 */
exports.init = function() {
   return;
};

/**
 * preload the given img URIs
 * @returns {Function} which returns 0-1 for preload progress
 * @ignore
 */
exports.preload = function(imgIdents) {

   var countLoaded = 0;
   var countTotal = 0;

   function incrementLoaded() {
      countLoaded++;
      if (countLoaded == countTotal) {
         _PRELOADING = false;
      }
      if (countLoaded % 10 === 0) {
         gamejs.log('gamejs.image: preloaded  ' + countLoaded + ' of ' + countTotal);
      }
   }

   function getProgress() {
      return countTotal > 0 ? countLoaded / countTotal : 1;
   }

   function successHandler() {
      addToCache(this);
      incrementLoaded();
   }
   function errorHandler() {
      incrementLoaded();
      throw new Error('Error loading ' + this.src);
   }

   for (var key in imgIdents) {
      var lowerKey = key.toLowerCase();
      if (lowerKey.indexOf('.png') == -1 &&
            lowerKey.indexOf('.jpg') == -1 &&
            lowerKey.indexOf('.jpeg') == -1 &&
            lowerKey.indexOf('.svg') == -1 &&
            lowerKey.indexOf('.gif') == -1) {
         continue;
      }
      var img = new Image();
      img.addEventListener('load', successHandler, true);
      img.addEventListener('error', errorHandler, true);
      img.src = imgIdents[key];
      img.gamejsKey = key;
      countTotal++;
   }
   if (countTotal > 0) {
      _PRELOADING = true;
   }
   return getProgress;
};

/**
 * add the given <img> dom elements into the cache.
 * @private
 */
var addToCache = function(img) {
   CACHE[img.gamejsKey] = img;
   return;
};

}}, ["gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/sprite": function(require, exports, module) {
var gamejs = require('../gamejs');
var arrays = require('./utils/arrays');
var $o = require('./utils/objects');
var $v = require('./utils/vectors');

/**
 * @fileoverview Provides `Sprite` the basic building block for any game and
 * `SpriteGroups`, which are an efficient
 * way for doing collision detection between groups as well as drawing layered
 * groups of objects on the screen.
 *
 */

/**
 * Your visible game objects will typically subclass Sprite. By setting it's image
 * and rect attributes you can control its appeareance. Those attributes control
 * where and what `Sprite.draw(surface)` will blit on the the surface.
 *
 * Your subclass should overwrite `update(msDuration)` with its own implementation.
 * This function is called once every game tick, it is typically used to update
 * the status of that object.
 * @constructor
 */
var Sprite = exports.Sprite = function() {
   /** @ignore */
   this._groups = [];
   /** @ignore */
   this._alive = true;

   /**
    * Image to be rendered for this Sprite.
    * @type gamejs.Surface
    */
   this.image = null;
   /**
    * Rect describing the position of this sprite on the display.
    * @type gamejs.Rect
    */
   this.rect = null;

   /**
    * List of all groups that contain this sprite.
    */
   $o.accessor(this, 'groups', function() {
      return this._groups;
   });

   return this;
};

/**
 * Kill this sprite. This removes the sprite from all associated groups and
 * makes future calls to `Sprite.isDead()` return `true`
 */
Sprite.prototype.kill = function() {
   this._alive = false;
   this._groups.forEach(function(group) {
      group.remove(this);
   }, this);
   return;
};

/**
 * Remove the sprite from the passed groups
 * @param {Array|gamejs.sprite.Group} groups One or more `gamejs.Group`
 * instances
 */
Sprite.prototype.remove = function(groups) {
   if (!(groups instanceof Array)) {
      groups = [groups];
   }

   groups.forEach(function(group) {
      group.remove(this);
   }, this);
   return;
};

/**
 * Add the sprite to the passed groups
 * @param {Array|gamejs.sprite.Group} groups One or more `gamejs.sprite.Group`
 * instances
 */
Sprite.prototype.add = function(groups) {
   if (!(groups instanceof Array)) {
      groups = [groups];
   }

   groups.forEach(function(group) {
      group.add(this);
   }, this);
   return;
};


/**
 * Returns an array of all the Groups that contain this Sprite.
 * @returns {Array} an array of groups
 */
Sprite.prototype.groups = function() {
   return this._groups.slice(0);
}

/**
 * Draw this sprite onto the given surface. The position is defined by this
 * sprite's rect.
 * @param {gamejs.Surface} surface The surface to draw on
 */
Sprite.prototype.draw = function(surface) {
   surface.blit(this.image, this.rect);
   return;
};

/**
 * Update this sprite. You **should** override this method with your own to
 * update the position, status, etc.
 */
Sprite.prototype.update = function() {};

/**
 * @returns {Boolean} True if this sprite has had `Sprite.kill()` called on it
 * previously, otherwise false
 */
Sprite.prototype.isDead = function() {
   return !this._alive;
};

/**
 * Sprites are often grouped. That makes collision detection more efficient and
 * improves rendering performance. It also allows you to easly keep track of layers
 * of objects which are rendered to the screen in a particular order.
 *
 * `Group.update()` calls `update()` on all the contained sprites; the same is true for `draw()`.
 * @constructor
 */
var Group = exports.Group = function() {
   /** @ignore */
   this._sprites = [];


   if (arguments[0] instanceof Sprite ||
      (arguments[0] instanceof Array &&
       arguments[0].length &&
       arguments[0][0] instanceof Sprite
   )) {
      this.add(arguments[0]);
   }
   return this;
};

/**
 * Update all the sprites in this group. This is equivalent to calling the
 * update method on each sprite in this group.
 */
Group.prototype.update = function() {
   var updateArgs = arguments;

   this._sprites.forEach(function(sp) {
      sp.update.apply(sp, updateArgs);
   }, this);
   return;
};

/**
 * Add one or more sprites to this group
 * @param {Array|gamejs.sprite.Sprite} sprites One or more
 * `gamejs.sprite.Sprite` instances
 */
Group.prototype.add = function(sprites) {
   if (!(sprites instanceof Array)) {
      sprites = [sprites];
   }

   sprites.forEach(function(sprite) {
      this._sprites.push(sprite);
      sprite._groups.push(this);
   }, this);
   return;
};

/**
 * Remove one or more sprites from this group
 * @param {Array|gamejs.sprite.Sprite} sprites One or more
 * `gamejs.sprite.Sprite` instances
 */
Group.prototype.remove = function(sprites) {
   if (!(sprites instanceof Array)) {
      sprites = [sprites];
   }

   sprites.forEach(function(sp) {
      arrays.remove(sp, this._sprites);
      arrays.remove(this, sp._groups);
   }, this);
   return;
};

/**
 * Check for the existence of one or more sprites within a group
 * @param {Array|gamejs.sprite.Sprite} sprites One or more
 * `gamejs.sprite.Sprite` instances
 * @returns {Boolean} True if every sprite is in this group, false otherwise
 */
Group.prototype.has = function(sprites) {
   if (!(sprites instanceof Array)) {
      sprites = [sprites];
   }

   return sprites.every(function(sp) {
      return this._sprites.indexOf(sp) !== -1;
   }, this);
};

/**
 * Get the sprites in this group
 * @returns {Array} An array of `gamejs.sprite.Sprite` instances
 */
Group.prototype.sprites = function() {
   return this._sprites;
};

/**
 * Draw all the sprites in this group. This is equivalent to calling each
 * sprite's draw method.
 */
Group.prototype.draw = function() {
   var args = arguments;
   this._sprites.forEach(function(sprite) {
      sprite.draw.apply(sprite, args);
   }, this);
   return;
};

/**
 * Draw background (`source` argument) over each sprite in the group
 * on the `destination` surface.
 *
 * This can, for example, be used to clear the
 * display surface to a a static background image in all the places
 * occupied by the sprites of all group.
 *
 * @param {gamejs.Surface} destination the surface to draw on
 * @param {gamejs.Surface} source surface
 */
Group.prototype.clear = function(destination, source) {
   this._sprites.forEach(function(sprite) {
      destination.blit(source, sprite.rect);
   }, this);
};

/**
 * Remove all sprites from this group
 */
Group.prototype.empty = function() {
   this._sprites = [];
   return;
};

/**
 * @returns {Array} of sprites colliding with the point
 */
Group.prototype.collidePoint = function() {
   var args = Array.prototype.slice.apply(arguments);
   return this._sprites.filter(function(sprite) {
      return sprite.rect.collidePoint.apply(sprite.rect, args);
   }, this);
};

/**
 * Loop over each sprite in this group. This is a shortcut for
 * `group.sprites().forEach(...)`.
 */
Group.prototype.forEach = function(callback, thisArg) {
   return this._sprites.forEach(callback, thisArg);
};

/**
 * Check whether some sprite in this group passes a test. This is a shortcut
 * for `group.sprites().some(...)`.
 */
Group.prototype.some = function(callback, thisArg) {
   return this._sprites.some(callback, thisArg);
};

/**
 * Find sprites in a group that intersect another sprite
 * @param {gamejs.sprite.Sprite} sprite The sprite to check
 * @param {gamejs.sprite.Group} group The group to check
 * @param {Boolean} doKill If true, kill sprites in the group when collided
 * @param {function} collided Collision function to use, defaults to `gamejs.sprite.collideRect`
 * @returns {Array} An array of `gamejs.sprite.Sprite` instances that collided
 */
exports.spriteCollide = function(sprite, group, doKill, collided) {
   collided = collided || collideRect;
   doKill = doKill || false;

   var collidingSprites = [];
   group.sprites().forEach(function(groupSprite) {
      if (collided(sprite, groupSprite)) {
         if (doKill) {
            groupSprite.kill();
         }
         collidingSprites.push(groupSprite);
      }
   });
   return collidingSprites;
};

/**
 * Find all Sprites that collide between two Groups.
 *
 * @example
 * groupCollide(group1, group2).forEach(function (collision) {
 *    var group1Sprite = collision.a;
 *    var group2Sprite = collision.b;
 *    // Do processing here!
 * });
 *
 * @param {gamejs.sprite.Group} groupA First group to check
 * @param {gamejs.sprite.Group} groupB Second group to check
 * @param {Boolean} doKillA If true, kill sprites in the first group when
 * collided
 * @param {Boolean} doKillB If true, kill sprites in the second group when
 * collided
 * @param {function} collided Collision function to use, defaults to `gamejs.sprite.collideRect`
 * @returns {Array} A list of objects where properties 'a' and 'b' that
 * correspond with objects from the first and second groups
 */
exports.groupCollide = function(groupA, groupB, doKillA, doKillB, collided) {
   doKillA = doKillA || false;
   doKillB = doKillB || false;

   var collideList = [];
   var collideFn = collided || collideRect;
   groupA.sprites().forEach(function(groupSpriteA) {
      groupB.sprites().forEach(function(groupSpriteB) {
         if (collideFn(groupSpriteA, groupSpriteB)) {
            if (doKillA) {
               groupSpriteA.kill();
            }
            if (doKillB) {
               groupSpriteB.kill();
            }

            collideList.push({
               'a': groupSpriteA,
               'b': groupSpriteB
            });
         }
      });
   });

   return collideList;
};

/**
 * Check for collisions between two sprites using their rects.
 *
 * @param {gamejs.sprite.Sprite} spriteA First sprite to check
 * @param {gamejs.sprite.Sprite} spriteB Second sprite to check
 * @returns {Boolean} True if they collide, false otherwise
 */
var collideRect = exports.collideRect = function (spriteA, spriteB) {
   return spriteA.rect.collideRect(spriteB.rect);
};

/**
 * Collision detection between two sprites utilizing the optional `mask`
 * attribute on the sprites. Beware: expensive operation.
 *
 * @param {gamejs.sprite.Sprite} spriteA Sprite with 'mask' property set to a `gamejs.mask.Mask`
 * @param {gamejs.sprite.Sprite} spriteB Sprite with 'mask' property set to a `gamejs.mask.Mask`
 * @returns {Boolean} True if any mask pixels collide, false otherwise
 */
exports.collideMask = function(spriteA, spriteB) {
   if (!spriteA.mask || !spriteB.mask) {
      throw new Error("Both sprites must have 'mask' attribute set to an gamejs.mask.Mask");
   }
   var offset = [
      spriteB.rect.left - spriteA.rect.left,
      spriteB.rect.top - spriteA.rect.top
   ];
   return spriteA.mask.overlap(spriteB.mask, offset);
};

/**
 * Collision detection between two sprites using circles at centers.
 * There sprite property `radius` is used if present, otherwise derived from bounding rect.
 * @param {gamejs.sprite.Sprite} spriteA First sprite to check
 * @param {gamejs.sprite.Sprite} spriteB Second sprite to check
 * @returns {Boolean} True if they collide, false otherwise
 */
exports.collideCircle = function(spriteA, spriteB) {
   var rA = spriteA.radius || Math.max(spriteA.rect.width, spriteA.rect.height);
   var rB = spriteB.radius || Math.max(spriteB.rect.width, spriteB.rect.height);
   return $v.distance(spriteA.rect.center, spriteB.rect.center) <= rA + rB;
};

}}, ["gamejs", "gamejs/utils/arrays", "gamejs/utils/objects", "gamejs/utils/vectors"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/pathfinding/astar": function(require, exports, module) {
/**
 * @fileoverview
 * AStar Path finding algorithm
 *
 * Use the `findRoute(map, from, to, [timeout])` function to get the linked list
 * leading `from` a point `to` another on the given `map`.
 *
 * The map must implement interface `gamejs.pathfinding.Map`. This
 * class really holds an example implementation & data for you to study. If you
 * understand what this calls provides, you understand this module.
 *
 * Optionally, the search is canceld after `timeout` in millseconds.
 *
 * If there is no route `null` is returned.
 *
 * @see http://eloquentjavascript.net/chapter7.html
 */
var BinaryHeap = require('../utils/binaryheap').BinaryHeap;

/**
 * helper function for A*
 */
function ReachedList(hashFn) {
   var list = {};

   this.store = function(point, route) {
      list[hashFn(point)] = route;
      return;
   };

   this.find = function(point) {
      return list[hashFn(point)];
   };
   return this;
}


/** A* search function.
 *
 * This function expects a `Map` implementation and the origin and destination
 * points given. If there is a path between the two it will return the optimal
 * path as a linked list. If there is no path it will return null.
 *
 * The linked list is in reverse order: the first item is the destination and
 * the path to the origin follows.
 *
 * @param {Map} map map instance, must follow interface defined in {Map}
 * @param {Array} origin
 * @param {Array} destination
 * @param {Number} timeout milliseconds after which search should be canceled
 * @returns {Object} the linked list leading from `to` to `from` (sic!).
 **/
exports.findRoute = function(map, from, to, timeout) {
   var open = new BinaryHeap(routeScore);
   var hashFn = typeof map.hash === 'function' ? map.hash : defaultHash;
   var reached = new ReachedList(hashFn);

   function routeScore(route) {
      if (route.score === undefined) {
         route.score = map.estimatedDistance(route.point, to) + route.length;
      }
      return route.score;
   }
   function addOpenRoute(route) {
      open.push(route);
      reached.store(route.point, route);
   }

   function processNewPoints(direction) {
      var known = reached.find(direction);
      var newLength = route.length + map.actualDistance(route.point, direction);
      if (!known || known.length > newLength){
         if (known) {
            open.remove(known);
         }
         addOpenRoute({
            point: direction,
            from: route,
            length: newLength
         });
      }
   }
   var startMs = Date.now();
   var route = null;
   addOpenRoute({
      point: from,
      from: null,
      length: 0
   });
   var equalsFn = typeof map.equals === 'function' ? map.equals : defaultEquals;
   while (open.size() > 0 && (!timeout || Date.now() - startMs < timeout)) {
      route = open.pop();
      if (equalsFn(to, route.point)) {
         return route;
      }
      map.adjacent(route.point).forEach(processNewPoints);
   } // end while
   return null;
};

var defaultEquals = function(a, b) {
   return a[0] === b[0] && a[1] === b[1];
};

var defaultHash = function(a) {
   return a[0] + '-' + a[1];
};

/**
 * This is the interface for a Map that can be passed to the `findRoute()`
 * function. `Map` is not instantiable - see the unit tests for an example
 * implementation of Map.
 */
var Map = exports.Map = function() {
   throw new Error('not instantiable, this is an interface');
};

/**
 * @param {Array} origin
 * @returns {Array} list of points accessible from given Point
 */
Map.prototype.adjacent = function(origin) {
};

/**
 * @param {Object} a one of the points ot test for equality
 * @param {Object} b ... the other point
 * @returns Wheter the two points are equal.
 */
Map.prototype.equals = defaultEquals;

/**
 * @param {Object} a point
 * @returns {String} hash for the point
 */
Map.prototype.hash = defaultHash;

/**
 * Estimated lower bound distance between two points.
 * @param {Object} pointA
 * @param {Object} pointB
 * @returns {Number} the estimated distance between two points
 */
Map.prototype.estimatedDistance = function(pointA, pointB) {
   return 1;
};

/**
 * Actual distance between two points.
 * @param {Object} pointA
 * @param {Object} pointB
 * @returns {Number} the actual distance between two points
 */
Map.prototype.actualDistance = function(pointA, pointB) {
   return 1;
};

}}, ["gamejs/utils/binaryheap"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/font": function(require, exports, module) {
var Surface = require('../gamejs').Surface;
var objects = require('./utils/objects');

/**
 * @fileoverview Methods for creating Font objects which can render text
 * to a Surface.
 *
 * @example
 *     // create a font
 *     var font = new Font('20px monospace');
 *     // render text - this returns a surface with the text written on it.
 *     var helloSurface = font.render('Hello World')
 */

/**
 * Create a Font to draw on the screen. The Font allows you to
 * `render()` text. Rendering text returns a Surface which
 * in turn can be put on screen.
 *
 * @constructor
 * @property {Number} fontHeight the line height of this Font
 *
 * @param {String} fontSettings a css font definition, e.g., "20px monospace"
 * @param {STring} backgroundColor valid #rgb string, "#ff00cc"
 */
var Font = exports.Font = function(fontSettings, backgroundColor) {
    /**
     * @ignore
     */
   this.sampleSurface = new Surface([10,10]);
   this.sampleSurface.context.font = fontSettings;
   this.sampleSurface.context.textAlign = 'start';
   // http://diveintohtml5.org/canvas.html#text
   this.sampleSurface.context.textBaseline = 'bottom';
   this.backgroundColor = backgroundColor || false;
   return this;
};

/**
 * Returns a Surface with the given text on it.
 * @param {String} text the text to render
 * @param {String} color a valid #RGB String, "#ffcc00"
 * @returns {gamejs.Surface} Surface with the rendered text on it.
 */
Font.prototype.render = function(text, color) {
   var dims = this.size(text);
   var surface = new Surface(dims);
   var ctx = surface.context;
   ctx.save();
   if ( this.backgroundColor ) {
       ctx.fillStyle = this.backgroundColor;
       ctx.fillRect(0, 0, surface.rect.width, surface.rect.height);
   }
   ctx.font = this.sampleSurface.context.font;
   ctx.textBaseline = this.sampleSurface.context.textBaseline;
   ctx.textAlign = this.sampleSurface.context.textAlign;
   ctx.fillStyle = ctx.strokeStyle = color || "#000000";
   ctx.fillText(text, 0, surface.rect.height, surface.rect.width);
   ctx.restore();
   return surface;
};

/**
 * Determine the width and height of the given text if rendered
 * with this Font.
 * @param {String} text the text to measure
 * @returns {Array} the [width, height] of the text if rendered with this Font
 */
Font.prototype.size = function(text) {
   var metrics = this.sampleSurface.context.measureText(text);
   // FIXME measuretext is buggy, make extra wide
   return [metrics.width, this.fontHeight];
};

/**
 * Height of the font in pixels.
 */
objects.accessors(Font.prototype, {
   'fontHeight': {
      get: function() {
         // Returns an approximate line height of the text
         // This version of the specification does not provide a way to obtain
         // the bounding box dimensions of the text.
         // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-measuretext
         return this.sampleSurface.context.measureText('M').width * 1.5;
      }
   }

});

}}, ["gamejs", "gamejs/utils/objects"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/mixer": function(require, exports, module) {
var gamejs = require('../gamejs');

/**
 * @fileoverview Playing sounds with the html5 audio tag. Audio files must be preloaded
 * with the usual `gamejs.preload()` function. Ogg, wav and webm supported.
 *
 * Sounds & Images are loaded relative to './'.
 */

var CACHE = {};

/**
 * need to export preloading status for require
 * @ignore
 */
var _PRELOADING = false;

/**
 * @ignore
 */
var NUM_CHANNELS = 8;

/**
 * Sets the number of available channels for the mixer. The default value is 8.
 */
exports.setNumChannels = function(count) {
   NUM_CHANNELS = parseInt(count, 10) || NUM_CHANNELS;
};

exports.getNumChannels = function() {
   return NUM_CHANNELS;
};

/**
 * put all audios on page in cache
 * if same domain as current page, remove common href-prefix
 * @ignore
 */
exports.init = function() {
   var audios = Array.prototype.slice.call(document.getElementsByTagName("audio"), 0);
   addToCache(audios);
   return;
};

/**
 * Preload the audios into cache
 * @param {String[]} List of audio URIs to load
 * @returns {Function} which returns 0-1 for preload progress
 * @ignore
 */
exports.preload = function(audioUrls, showProgressOrImage) {
   var countTotal = 0;
   var countLoaded = 0;

   function incrementLoaded() {
      countLoaded++;
      if (countLoaded == countTotal) {
         _PRELOADING = false;
      }
   }

   function getProgress() {
      return countTotal > 0 ? countLoaded / countTotal : 1;
   }

   function successHandler() {
      addToCache(this);
      incrementLoaded();
   }
   function errorHandler() {
      incrementLoaded();
      throw new Error('Error loading ' + this.src);
   }

   for (var key in audioUrls) {
      if (key.indexOf('wav') == -1 && key.indexOf('ogg') == -1 && key.indexOf('webm') == -1) {
         continue;
      }
      countTotal++;
      var audio = new Audio();
      audio.addEventListener('canplay', successHandler, true);
      audio.addEventListener('error', errorHandler, true);
      audio.src = audioUrls[key];
      audio.gamejsKey = key;
      audio.load();
   }
   if (countTotal > 0) {
      _PRELOADING = true;
   }
   return getProgress;
};

/**
 * @ignore
 */
exports.isPreloading = function() {
   return _PRELOADING;
};

/**
 * @param {dom.ImgElement} audios the <audio> elements to put into cache
 * @ignore
 */
function addToCache(audios) {
   if (!(audios instanceof Array)) {
      audios = [audios];
   }

   var docLoc = document.location.href;
   audios.forEach(function(audio) {
      CACHE[audio.gamejsKey] = audio;
   });
   return;
}

/**
 * Sounds can be played back.
 * @constructor
 * @param {String|dom.AudioElement} uriOrAudio the uri of <audio> dom element
 *                of the sound
 */
exports.Sound = function Sound(uriOrAudio) {
   var cachedAudio;
   if (typeof uriOrAudio === 'string') {
      cachedAudio = CACHE[uriOrAudio];
   } else {
      cachedAudio = uriOrAudio;
   }
   if (!cachedAudio) {
      // TODO sync audio loading
      throw new Error('Missing "' + uriOrAudio + '", gamejs.preload() all audio files before loading');
   }

   var channels = [];
   var i = NUM_CHANNELS;
   while (i-->0) {
      var audio = new Audio();
      audio.preload = "auto";
      audio.loop = false;
      audio.src = cachedAudio.src;
      channels.push(audio);
   }
   /**
    * start the sound
    * @param {Boolean} loop whether the audio should loop for ever or not
    */
   this.play = function(loop) {
      channels.some(function(audio) {
         if (audio.ended || audio.paused) {
            audio.loop = !!loop;
            audio.play();
            return true;
         }
         return false;
      });
   };

   /**
    * Stop the sound.
    * This will stop the playback of this Sound on any active Channels.
    */
   this.stop = function() {
      channels.forEach(function(audio) {
         audio.pause();
         audio.currentTime = 0;
      });
   };

   /**
    * Set volume of this sound
    * @param {Number} value volume from 0 to 1
    */
   this.setVolume = function(value) {
      channels.forEach(function(audio) {
         audio.volume = value;
      });
   };

   /**
    * @returns {Number} the sound's volume from 0 to 1
    */
   this.getVolume = function() {
      return channels[0].volume;
   };

   /**
    * @returns {Number} Duration of this sound in seconds
    */
   this.getLength = function() {
      return channels[0].duration;
   };

   return this;
};

}}, ["gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/http": function(require, exports, module) {
/**
 * @fileoverview Make synchronous http requests to your game's serverside component.
 *
 * If you configure a ajax base URL you can make http requests to your
 * server using those functions.

 * The most high-level functions are `load()` and `save()` which take
 * and return a JavaScript object, which they will send to / recieve from
 * the server-side in JSON format.
 *
 * @example
 *
 *     <script>
 *     // Same Origin policy applies! You can only make requests
 *     // to the server from which the html page is served.
 *      var $g = {
 *         ajaxBaseHref: "http://the-same-server.com/ajax/"
 *      };
 *      </script>
 *      <script src="./public/gamejs-wrapped.js"></script>
 *      ....
 *      typeof gamejs.load('userdata/') === 'object'
 *      typeof gamejs.get('userdata/') === 'string'
 *      ...
 *
 */

/**
 * Response object returned by http functions `get` and `post`. This
 * class is not instantiable.
 *
 * @param{String} responseText
 * @param {String} responseXML
 * @param {Number} status
 * @param {String} statusText
 */
exports.Response = function() {
   /**
    * @param {String} header
    */
   this.getResponseHeader = function(header)  {
   };
   throw new Error('response class not instantiable');
};

/**
 * Make http request to server-side
 * @param {String} method http method
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @return {Response} response
 */
var ajax = exports.ajax = function(method, url, data, type) {
   data = data || null;
   var response = new XMLHttpRequest();
   response.open(method, url, false);
   if (type) {
      response.setRequestHeader("Accept", type);
   }
   if (data instanceof Object) {
      data = JSON.stringify(data);
      response.setRequestHeader('Content-Type', 'application/json');
   }
   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
   response.send(data);
   return response;
};

/**
 * Make http GET request to server-side
 * @param {String} url
 */
var get = exports.get = function(url) {
   return ajax('GET', url);
};

/**
 * Make http POST request to server-side
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @returns {Response}
 */
var post = exports.post = function(url, data, type) {
   return ajax('POST', url, data, type);
};

function stringify(response) {
   // eval is evil
   return eval('(' + response.responseText + ')');
}

function ajaxBaseHref() {
    return (window.$g && window.$g.ajaxBaseHref) || './';
}

/**
 * Load an object from the server-side.
 * @param {String} url
 * @return {Object} the object loaded from the server
 */
exports.load = function(url) {
   return stringify(get(ajaxBaseHref() + url));
};

/**
 * Send an object to a server-side function.
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @returns {Object} the response object
 */
exports.save = function(url, data, type) {
   return stringify(post(ajaxBaseHref() + url, {payload: data}, type));
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/transform": function(require, exports, module) {
var Surface = require('../gamejs').Surface;
var matrix = require('./utils/matrix');
var math = require('./utils/math');
var vectors = require('./utils/vectors');

/**
 * @fileoverview Rotate and scale Surfaces.
 */

/**
 * Returns a new surface which holds the original surface rotate by angle degrees.
 * Unless rotating by 90 degree increments, the image will be padded larger to hold the new size.
 * @param {Surface} surface
 * @param {angel} angle Clockwise angle by which to rotate
 * @returns {Surface} new, rotated surface
 */
exports.rotate = function (surface, angle) {
   var origSize = surface.getSize();
   var radians = (angle * Math.PI / 180);
   var newSize = origSize;
   // find new bounding box
   if (angle % 360 !== 0) {
      var rect = surface.getRect();
      var points = [
         [-rect.width/2, rect.height/2],
         [rect.width/2, rect.height/2],
         [-rect.width/2, -rect.height/2],
         [rect.width/2, -rect.height/2]
      ];
      var rotPoints = points.map(function(p) {
         return vectors.rotate(p, radians);
      });
      var xs = rotPoints.map(function(p) { return p[0]; });
      var ys = rotPoints.map(function(p) { return p[1]; });
      var left = Math.min.apply(Math, xs);
      var right = Math.max.apply(Math, xs);
      var bottom = Math.min.apply(Math, ys);
      var top = Math.max.apply(Math, ys);
      newSize = [right-left, top-bottom];
   }
   var newSurface = new Surface(newSize);
   var oldMatrix = surface._matrix;
   surface._matrix = matrix.translate(surface._matrix, origSize[0]/2, origSize[1]/2);
   surface._matrix = matrix.rotate(surface._matrix, radians);
   surface._matrix = matrix.translate(surface._matrix, -origSize[0]/2, -origSize[1]/2);
   var offset = [(newSize[0] - origSize[0]) / 2, (newSize[1] - origSize[1]) / 2];
   newSurface.blit(surface, offset);
   surface._matrix = oldMatrix;
   return newSurface;
};

/**
 * Returns a new surface holding the scaled surface.
 * @param {Surface} surface
 * @param {Array} dimensions new [width, height] of surface after scaling
 * @returns {Surface} new, scaled surface
 */
exports.scale = function(surface, dims) {
   var width = dims[0];
   var height = dims[1];
   if (width <= 0 || height <= 0) {
      throw new Error('[gamejs.transform.scale] Invalid arguments for height and width', [width, height]);
   }
   var oldDims = surface.getSize();
   var ws = width / oldDims[0];
   var hs = height / oldDims[1];
   var newSurface = new Surface([width, height]);
   var originalMatrix = surface._matrix.slice(0);
   surface._matrix = matrix.scale(surface._matrix, [ws, hs]);
   newSurface.blit(surface);
   surface._matrix = originalMatrix;
   return newSurface;
};

/**
 * Flip a Surface either vertically, horizontally or both. This returns
 * a new Surface (i.e: nondestructive).
 * @param {gamejs.Surface} surface
 * @param {Boolean} flipHorizontal
 * @param {Boolean} flipVertical
 * @returns {Surface} new, flipped surface
 */
exports.flip = function(surface, flipHorizontal, flipVertical) {
   var dims = surface.getSize();
   var newSurface = new Surface(dims);
   var scaleX = 1;
   var scaleY = 1;
   var xPos = 0;
   var yPos = 0;
   if (flipHorizontal === true) {
      scaleX = -1;
      xPos = -dims[0];
   }
   if (flipVertical === true) {
      scaleY = -1;
      yPos = -dims[1];
   }
   newSurface.context.save();
   newSurface.context.scale(scaleX, scaleY);
   newSurface.context.drawImage(surface.canvas, xPos, yPos);
   newSurface.context.restore();
   return newSurface;
};

}}, ["gamejs", "gamejs/utils/matrix", "gamejs/utils/math", "gamejs/utils/vectors"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/event": function(require, exports, module) {
var display = require('./display');
var gamejs = require('../gamejs');
/**
 * @fileoverview Methods for polling mouse and keyboard.
 *
 * Call `gamejs.event.get()` in your main loop to get a list of events that happend
 * since your last call.
 *
 * Note that some events, which would trigger a default browser action, are prevented
 * from triggering their default behaviour if and only if the game's display canvas has
 * focus (the game gets focus if the user clicked on the game).
 *
 * All events have a type identifier. This event type is in between the values
 * of NOEVENT and NUMEVENTS. Each event has a constant in `gamejs.event.*`
 * All user defined events can have the value of USEREVENT or higher.
 * Make sure your custom event ids* follow this system.
 *
 * A pattern for using the event loop: your main game function (tick in this example)
 * is being called by [gamejs.time.interval()](../time/#interval).
 * Inside tick we call [gamejs.event.get()](#get) for a list of events that happened since the last
 * tick and we loop over each event and act on the event properties.
 *
 * @example
 *     var events = gamejs.event.get()
 *     events.forEach(function(event) {
 *        if (event.type === gamejs.event.MOUSE_UP) {
 *          gamejs.log(event.pos, event.button);
 *        } else if (event.type === gamejs.event.KEY_UP) {
 *          gamejs.log(event.key);
 *        }
 *     });
 *
 */
// key constants
exports.K_UP = 38;
exports.K_DOWN = 40;
exports.K_RIGHT = 39;
exports.K_LEFT = 37;

exports.K_SPACE = 32;
exports.K_BACKSPACE = 8;
exports.K_TAB = 9;
exports.K_ENTER = 13;
exports.K_SHIFT = 16;
exports.K_CTRL = 17;
exports.K_ALT = 18;
exports.K_ESC = 27;

exports.K_0 = 48;
exports.K_1 = 49;
exports.K_2 = 50;
exports.K_3 = 51;
exports.K_4 = 52;
exports.K_5 = 53;
exports.K_6 = 54;
exports.K_7 = 55;
exports.K_8 = 56;
exports.K_9 = 57;
exports.K_a = 65;
exports.K_b = 66;
exports.K_c = 67;
exports.K_d = 68;
exports.K_e = 69;
exports.K_f = 70;
exports.K_g = 71;
exports.K_h = 72;
exports.K_i = 73;
exports.K_j = 74;
exports.K_k = 75;
exports.K_l = 76;
exports.K_m = 77;
exports.K_n = 78;
exports.K_o = 79;
exports.K_p = 80;
exports.K_q = 81;
exports.K_r = 82;
exports.K_s = 83;
exports.K_t = 84;
exports.K_u = 85;
exports.K_v = 86;
exports.K_w = 87;
exports.K_x = 88;
exports.K_y = 89;
exports.K_z = 90;

exports.K_KP1 = 97;
exports.K_KP2 = 98;
exports.K_KP3 = 99;
exports.K_KP4 = 100;
exports.K_KP5 = 101;
exports.K_KP6 = 102;
exports.K_KP7 = 103;
exports.K_KP8 = 104;
exports.K_KP9 = 105;

// event type constants
exports.NOEVENT = 0
exports.NUMEVENTS = 32000

exports.QUIT = 0;
exports.KEY_DOWN = 1;
exports.KEY_UP = 2;
exports.MOUSE_MOTION = 3;
exports.MOUSE_UP = 4;
exports.MOUSE_DOWN = 5;
exports.MOUSE_WHEEL = 6;
exports.USEREVENT = 2000;

exports.WORKER = 1000;
exports.WORKER_RESULT = 1001;
/** @ignore **/
exports.WORKER_ERROR = 1002;
/** @ignore **/
exports.WORKER_ALIVE = 1003;
/** @ignore **/
exports.WORKER_LOG = 1004;

var QUEUE = [];

/**
 * Get all events from the event queue
 * @returns {Array}
 */
exports.get = function(eventTypes) {
  if (eventTypes === undefined) {
    return QUEUE.splice(0, QUEUE.length);
  } else {
    if (! (eventTypes instanceof Array)) {
      eventTypes = [eventTypes];
    }
    var result = [];
    QUEUE = QUEUE.filter(function(event) {
      if (eventTypes.indexOf(event.type) === -1) {
        return true;
      }
      result.push(event)
      return false;
    })
    return result;
  }
};

/**
 * Get the newest event of the event queue
 * @returns {gamejs.event.Event}
 */
exports.poll = function() {
   return QUEUE.pop();
};

/**
 * Post an event to the event queue.
 * @param {gamejs.event.Event} userEvent the event to post to the queue
 */
exports.post = function(userEvent) {
   if (userEvent.type === exports.WORKER_RESULT && gamejs.worker.inWorker === true) {
      gamejs.worker._messageMain(userEvent);
   } else if (userEvent.type === exports.WORKER && gamejs.worker.inWorker === false) {
      if (!userEvent.worker || !userEvent.worker.post) {
         throw new Error('Missing "worker" property on event');
      }
      userEvent.worker.post(userEvent.data);
   } else {
      QUEUE.push(userEvent);
   }
   return;
};

/**
 * Remove all events from the queue
 */
exports.clear = function() {
   QUEUE = [];
};

/**
 * Holds all information about an event.
 * @class
 */

exports.Event = function() {
    /**
     * The type of the event. e.g., gamejs.event.QUIT, KEYDOWN, MOUSEUP.
     */
    this.type = null;
    /**
     * key the keyCode of the key. compare with gamejs.event.K_a, gamejs.event.K_b,...
     */
    this.key = null;
    /**
     * relative movement for a mousemove event
     */
    this.rel = null;
    /**
     * the number of the mousebutton pressed
     */
    this.button = null;
    /**
     * pos the position of the event for mouse events
     */
    this.pos = null;
};

/**
 * @ignore
 */
exports.init = function() {

   var lastPos = [];

   // anonymous functions as event handlers = memory leak, see MDC:elementAddEventListener

   function onMouseDown (ev) {
      var canvasOffset = display._getCanvasOffset();
      QUEUE.push({
         'type': gamejs.event.MOUSE_DOWN,
         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
         'button': ev.button,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onMouseUp (ev) {
      var canvasOffset = display._getCanvasOffset();
      QUEUE.push({
         'type':gamejs.event.MOUSE_UP,
         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
         'button': ev.button,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onKeyDown (ev) {
      var key = ev.keyCode || ev.which;
      QUEUE.push({
         'type': gamejs.event.KEY_DOWN,
         'key': key,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });

      // if the display has focus, we surpress default action
      // for most keys
      if (display._hasFocus() && (!ev.ctrlKey && !ev.metaKey &&
         ((key >= exports.K_LEFT && key <= exports.K_DOWN) ||
         (key >= exports.K_0    && key <= exports.K_z) ||
         (key >= exports.K_KP1  && key <= exports.K_KP9) ||
         key === exports.K_SPACE ||
         key === exports.K_TAB ||
         key === exports.K_ENTER)) ||
         key === exports.K_ALT ||
         key === exports.K_BACKSPACE) {
        ev.preventDefault();
      }
   }

   function onKeyUp (ev) {
      QUEUE.push({
         'type': gamejs.event.KEY_UP,
         'key': ev.keyCode,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onMouseMove (ev) {
      var canvasOffset = display._getCanvasOffset();
      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
      var relativePos = [];
      if (lastPos.length) {
         relativePos = [
            lastPos[0] - currentPos[0],
            lastPos[1] - currentPos[1]
         ];
      }
      QUEUE.push({
         'type': gamejs.event.MOUSE_MOTION,
         'pos': currentPos,
         'rel': relativePos,
         'buttons': null, // FIXME, fixable?
         'timestamp': ev.timeStamp
      });
      lastPos = currentPos;
      return;
   }

   function onMouseScroll(ev) {
      var canvasOffset = display._getCanvasOffset();
      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
      QUEUE.push({
         type: gamejs.event.MOUSE_WHEEL,
         pos: currentPos,
         delta: ev.detail || (- ev.wheelDeltaY / 40)
      });
      return;
   }

   function onBeforeUnload (ev) {
      QUEUE.push({
         'type': gamejs.event.QUIT
      });
      return;
   }

   // IEFIX does not support addEventListener on document itself
   // MOZFIX but in moz & opera events don't reach body if mouse outside window or on menubar
   var canvas = display.getSurface()._canvas;
   document.addEventListener('mousedown', onMouseDown, false);
   document.addEventListener('mouseup', onMouseUp, false);
   document.addEventListener('keydown', onKeyDown, false);
   document.addEventListener('keyup', onKeyUp, false);
   canvas.addEventListener('mousemove', onMouseMove, false);
   canvas.addEventListener('mousewheel', onMouseScroll, false);
   // MOZFIX
   // https://developer.mozilla.org/en/Code_snippets/Miscellaneous#Detecting_mouse_wheel_events
   canvas.addEventListener('DOMMouseScroll', onMouseScroll, false);
   canvas.addEventListener('beforeunload', onBeforeUnload, false);

};

}}, ["gamejs/display", "gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/noise": function(require, exports, module) {
/**
 * @fileoverview
 * A noise generator comparable to Perlin noise, which is useful
 * for generating procedural content.
 * @see gamejs/utils/prng
 */

// Ported to JS by by zz85 <https://github.com/zz85> from Stefan
// Gustavson's java implementation
// <http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf>
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com

/**
 * This implementation provides 2D and 3D noise. You can optionally
 * pass a seedable pseudo-random number generator to its constructor. This
 * generator object is assumed to have a `random()` method; `Math` is used
 * per default.
 *
 * Also see `gamejs/utils/prng` for a seedable pseudo random number generator
 *
 * @param {Object} prng the random number generator to use; most provide `random()` method
 * @usage
 *  var simplex = new gamejs.noise.Simplex();
 *  simplex.get(x, y);
 *  // or for 3d noise
 *  simple.get(x, y, y);
 */
var Simplex = exports.Simplex = function(r) {
  if (r == undefined) r = Math;
  /** @ignore */
  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
               [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
               [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
  /** @ignore */
  this.p = [];
  for (var i=0; i<256; i++) {
   this.p[i] = Math.floor(r.random()*256);
  }
  // To remove the need for index wrapping, double the permutation table length
  /** @ignore */
  this.perm = [];
  for(var i=0; i<512; i++) {
   this.perm[i]=this.p[i & 255];
   }

  // A lookup table to traverse the simplex around a given point in 4D.
  // Details can be found where this table is used, in the 4D noise method.
  /** @ignore */
  this.simplex = [
    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],
    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],
    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],
    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],
    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],
    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],
    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],
    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];
};

/** @ignore */
Simplex.prototype.dot = function(g, x, y) {
   return g[0]*x + g[1]*y;
};

/**
 * @param {Number} x
 * @param {Number} y
 * @returns {Number} noise for given position, in range [-1, 1]
 */
Simplex.prototype.get = function(xin, yin) {
  var n0, n1, n2; // Noise contributions from the three corners
  // Skew the input space to determine which simplex cell we're in
  var F2 = 0.5*(Math.sqrt(3.0)-1.0);
  var s = (xin+yin)*F2; // Hairy factor for 2D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var G2 = (3.0-Math.sqrt(3.0))/6.0;
  var t = (i+j)*G2;
  var X0 = i-t; // Unskew the cell origin back to (x,y) space
  var Y0 = j-t;
  var x0 = xin-X0; // The x,y distances from the cell origin
  var y0 = yin-Y0;
  // For the 2D case, the simplex shape is an equilateral triangle.
  // Determine which simplex we are in.
  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
  else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)
  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
  // c = (3-sqrt(3))/6
  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
  var y1 = y0 - j1 + G2;
  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
  var y2 = y0 - 1.0 + 2.0 * G2;
  // Work out the hashed gradient indices of the three simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var gi0 = this.perm[ii+this.perm[jj]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
  // Calculate the contribution from the three corners
  var t0 = 0.5 - x0*x0-y0*y0;
  if(t0<0) n0 = 0.0;
  else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
  }
  var t1 = 0.5 - x1*x1-y1*y1;
  if(t1<0) n1 = 0.0;
  else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
  }
  var t2 = 0.5 - x2*x2-y2*y2;
  if(t2<0) n2 = 0.0;
  else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to return values in the interval [-1,1].
  return 70.0 * (n0 + n1 + n2);
};


/**
 * @param {Number} x
 * @param {Number} y
 * @param {Number} y
 * @returns {Number} noise for given position, in range [-1, 1]
 */
Simplex.prototype.get3d = function(xin, yin, zin) {
  var n0, n1, n2, n3; // Noise contributions from the four corners
  // Skew the input space to determine which simplex cell we're in
  var F3 = 1.0/3.0;
  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var k = Math.floor(zin+s);
  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too
  var t = (i+j+k)*G3;
  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space
  var Y0 = j-t;
  var Z0 = k-t;
  var x0 = xin-X0; // The x,y,z distances from the cell origin
  var y0 = yin-Y0;
  var z0 = zin-Z0;
  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
  // Determine which simplex we are in.
  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
  if(x0>=y0) {
    if(y0>=z0)
      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order
      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order
      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order
    }
  else { // x0<y0
    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order
    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order
    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order
  }
  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
  // c = 1/6.
  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
  var y1 = y0 - j1 + G3;
  var z1 = z0 - k1 + G3;
  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords
  var y2 = y0 - j2 + 2.0*G3;
  var z2 = z0 - k2 + 2.0*G3;
  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords
  var y3 = y0 - 1.0 + 3.0*G3;
  var z3 = z0 - 1.0 + 3.0*G3;
  // Work out the hashed gradient indices of the four simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var kk = k & 255;
  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;
  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;
  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;
  // Calculate the contribution from the four corners
  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
  if(t0<0) n0 = 0.0;
  else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
  }
  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
  if(t1<0) n1 = 0.0;
  else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
  }
  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
  if(t2<0) n2 = 0.0;
  else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
  }
  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
  if(t3<0) n3 = 0.0;
  else {
    t3 *= t3;
    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to stay just inside [-1,1]
  return 32.0*(n0 + n1 + n2 + n3);
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/surfacearray": function(require, exports, module) {
var gamejs = require('../gamejs');
var accessors = require('./utils/objects').accessors;
/**
 * @fileoverview Fast pixel access.
 *
 * @example
 *
 *   // create array from display surface
 *   var srfArray = new SurfaceArray(display);
 *   // direct pixel access
 *   srfArray.set(50, 100, [255, 0, 0, 100]);
 *   console.log(srfArray.get(30, 50));
 *   // blit modified array back to display surface
 *   blitArray(display, srfArray);
 */

/**
 * Directly copy values from an array into a Surface.
 *
 * This is faster than blitting the `surface` property on a SurfaceArray
 *
 * The array must be the same dimensions as the Surface and will completely
 * replace all pixel values.
 * @param {gamejs.Surface} surface
 * @param {gamejs.surfacearray.SurfaceArray} surfaceArray
 */
exports.blitArray = function(surface, surfaceArray) {
   surface.context.putImageData(surfaceArray.imageData, 0, 0);
   return;
};

/**
 * The SurfaceArray can be constructed with a surface whose values
 * are then used to initialize the pixel array.
 *
 * The surface passed as argument is not modified by the SurfaceArray.
 *
 * If an array is used to construct SurfaceArray, the array must describe
 * the dimensions of the SurfaceArray [width, height].
 *
 * @param {gamejs.Surface|Array} surfaceOrDimensions
 * @see http://dev.w3.org/html5/2dcontext/#pixel-manipulation
 */
var SurfaceArray = exports.SurfaceArray = function(surfaceOrDimensions) {
   var size = null;
   var data = null;
   var imageData = null;

   /**
    * Set rgba value at position x, y.
    *
    * For performance reasons this function has only one signature
    * being Number, Number, Array[4].
    *
    * @param {Number} x x position of pixel
    * @param {Number} y y position of pixel
    * @param {Array} rgba [red, green, blue, alpha] values [255, 255, 255, 255] (alpha, the last argument defaults to 255)
    * @throws Error if x, y out of range
    */
   this.set = function(x, y, rgba) {
      var offset = (x * 4) + (y * size[0] * 4);
      /** faster without
      if (offset + 3 >= data.length || x < 0 || y < 0) {
         throw new Error('x, y out of range', x, y);
      }
      **/
      data[offset] = rgba[0];
      data[offset+1] = rgba[1];
      data[offset+2] = rgba[2];
      data[offset+3] = rgba[3] === undefined ? 255 : rgba[3];
      return;
   };

   /**
    * Get rgba value at position xy,
    * @param {Number} x
    * @param {Number} y
    * @returns {Array} [red, green, blue, alpha]
    */
   this.get = function(x, y) {
      var offset = (x * 4) + (y * size[0] * 4);
      return [
         data[offset],
         data[offset+1],
         data[offset+2],
         data[offset+3]
      ];
   };

   /**
    * a new gamejs.Surface on every access, representing
    * the current state of the SurfaceArray.
    * @type {gamejs.Surface}
    */
   // for jsdoc only
   this.surface = null;

   accessors(this, {
      surface: {
         get: function() {
            var s = new gamejs.Surface(size);
            s.context.putImageData(imageData, 0, 0);
            return s;
         }
      },
      imageData: {
         get: function() {
            return imageData;
         }
      }
   });

   this.getSize = function() {
      return size;
   };

   /**
    * constructor
    */
   if (surfaceOrDimensions instanceof Array) {
      size = surfaceOrDimensions;
      imageData = gamejs.display.getSurface().context.createImageData(size[0], size[1]);
      data = imageData.data;
   } else {
      size = surfaceOrDimensions.getSize();
      imageData = surfaceOrDimensions.getImageData(0, 0, size[0], size[1]);
      data = imageData.data;
   }
   return this;
};

}}, ["gamejs", "gamejs/utils/objects"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/objects": function(require, exports, module) {
/**
 * @fileoverview Utility functions for working with Objects
 */

/**
 * Put a prototype into the prototype chain of another prototype.
 * @param {Object} subClass
 * @param {Object} superClass
 */
exports.extend = function(subClass, superClass) {
   if (subClass === undefined) {
      throw new Error('unknown subClass');
   }
   if (superClass === undefined) {
      throw new Error('unknown superClass');
   }
   // new Function() is evil
   var f = new Function();
   f.prototype = superClass.prototype;

   subClass.prototype = new f();
   subClass.prototype.constructor = subClass;
   subClass.superClass = superClass.prototype;
   subClass.superConstructor = superClass;
   return;
};

/**
 * Creates a new object as the as the keywise union of the provided objects.
 * Whenever a key exists in a later object that already existed in an earlier
 * object, the according value of the earlier object takes precedence.
 * @param {Object} obj... The objects to merge
 */
exports.merge = function() {
   var result = {};
      for (var i = arguments.length; i > 0; --i) {
         var obj = arguments[i - 1];
         for (var property in obj) {
            result[property] = obj[property];
         }
      }
   return result;
};

/**
 * fallback for Object.keys
 * @param {Object} obj
 * @returns {Array} list of own properties
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
 */
var keys = exports.keys = function(obj) {
   if (Object.keys) {
      return Object.keys(obj);
   }

   var ret=[],p;
   for (p in obj) {
      if(Object.prototype.hasOwnProperty.call(obj, p)) {
         ret.push(p);
      }
   }
   return ret;
};

/**
 * Create object accessors
 * @param {Object} object The object on which to define the property
 * @param {String} name name of the property
 * @param {Function} get
 * @param {Function} set
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty
 */
var accessor = exports.accessor = function(object, name, get, set) {
   // ECMA5
   if (Object.defineProperty !== undefined) {
      Object.defineProperty(object, name, {
         get: get,
         set: set
      });
   // non-standard
   } else if (Object.prototype.__defineGetter__ !== undefined) {
      object.__defineGetter__(name, get);
      if (set) {
         object.__defineSetter__(name, set);
      }
   }
	return;
};

/**
 * @param {Object} object The object on which to define or modify properties.
 * @param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperties
 */
exports.accessors = function(object, props) {
   keys(props).forEach(function(propKey) {
      accessor(object, propKey, props[propKey].get, props[propKey].set);
   });
   return;
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/arrays": function(require, exports, module) {
/**
 * @fileoverview Utility functions for working with Obiects
 * @param {Object} item
 * @param {Array} array
 * @param {Object} returns removed item or null
 */

exports.remove = function(item, array) {
   var index = array.indexOf(item);
   if (index !== -1) {
      return array.splice(array.indexOf(item), 1);
   }
   return null;
};

/**
 * Shuffles the array *in place*.
 * @see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
exports.shuffle = function(array) {
    var len = array.length -1;
    for (i = len; i > 0; i--) {
        var idx = parseInt(Math.random() * (i + 1));
        var item = array[i];
        array[i] = array[idx];
        array[idx] = item;
    }
    return array;
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/strings": function(require, exports, module) {
/**
 * Get the longest common segment that two strings
 * have in common, starting at the beginning of the string
 * @param {String} str1 a string
 * @param {String} str2 another string
 * @returns {String} the longest common segment
 */
exports.getCommonPrefix = function getCommonPrefix(str1, str2) {
    if (str1 == null || str2 == null) {
        return null;
    } else if (str1.length > str2.length && str1.indexOf(str2) == 0) {
        return str2;
    } else if (str2.length > str1.length && str2.indexOf(str1) == 0) {
        return str1;
    }
    var length = Math.min(str1.length, str2.length);
    for (var i = 0; i < length; i++) {
        if (str1[i] != str2[i]) {
            return str1.slice(0, i);
        }
    }
    return str1.slice(0, length);
}

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/binaryheap": function(require, exports, module) {
/**
 * Binary Heap
 *
 * @see http://eloquentjavascript.net/appendix2.html
 */
var BinaryHeap = exports.BinaryHeap = function(scoreFunction){
   /**
    * @ignore
    */
   this.content = [];
   /**
    * @ignore
    */
   this.scoreFunction = scoreFunction;
   return this;
};

/**
 * Add element to heap.
 * @param {Object} element
 */
BinaryHeap.prototype.push = function(element) {
   this.content.push(element);
   this.sinkDown(this.content.length - 1);
   return;
};

/**
 * Return first element from heap.
 * @param {Object} element
 * @returns {Object} element
 */
BinaryHeap.prototype.pop = function() {
   // Store the first element so we can return it later.
   var result = this.content[0];
   // Get the element at the end of the array.
   var end = this.content.pop();
   // If there are any elements left, put the end element at the
   // start, and let it bubble up.
   if (this.content.length > 0) {
      this.content[0] = end;
      this.bubbleUp(0);
   }
   return result;
};

/**
 * Remove the given element from the heap.
 * @param {Object} element
 * @throws {Error} if node not found
 */
BinaryHeap.prototype.remove = function(node) {
   // To remove a value, we must search through the array to find
   // it.
   var isFound = this.content.some(function(cNode, idx) {
      if (cNode == node) {
         var end = this.content.pop();
         if (idx != this.content.length) {
            this.content[idx] = end;
            if (this.scoreFunction(end) < this.scoreFunction(node)) {
               this.sinkDown(idx);
            } else {
               this.bubbleUp(idx);
            }
         }
         return true;
      }
      return false;
   }, this);
   if (!isFound) {
      //throw new Error("Node not found.");
   }
   return;
};

/**
 * Number of elements in heap.
 */
BinaryHeap.prototype.size = function() {
   return this.content.length;
};

/**
 * @ignore
 */
BinaryHeap.prototype.sinkDown = function(idx) {
   // Fetch the element that has to be sunk
   var element = this.content[idx];
   // When at 0, an element can not sink any further.
   while (idx > 0) {
      // Compute the parent element's index, and fetch it.
      var parentIdx = Math.floor((idx + 1) / 2) - 1;
      var parent = this.content[parentIdx];
      // Swap the elements if the parent is greater.
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
         this.content[parentIdx] = element;
         this.content[idx] = parent;
         // Update 'n' to continue at the new position.
         idx = parentIdx;
      // Found a parent that is less, no need to sink any further.
      } else {
         break;
      }
   }
   return;
};

/**
 * @ignore
 */
BinaryHeap.prototype.bubbleUp = function(idx) {
   // Look up the target element and its score.
   var length = this.content.length;
   var element = this.content[idx];
   var elemScore = this.scoreFunction(element);

   while(true) {
      // Compute the indices of the child elements.
      var child2Idx = (idx + 1) * 2;
      var child1Idx= child2Idx - 1;
      // This is used to store the new position of the element,
      // if any.
      var swapIdx = null;
      // If the first child exists (is inside the array)...
      if (child1Idx < length) {
         // Look it up and compute its score.
         var child1 = this.content[child1Idx];
         var child1Score = this.scoreFunction(child1);
         // If the score is less than our element's, we need to swap.
         if (child1Score < elemScore) {
            swapIdx = child1Idx;
         }
      }
      // Do the same checks for the other child.
      if (child2Idx < length) {
         var child2 = this.content[child2Idx];
         var child2Score = this.scoreFunction(child2);
         if (child2Score < (swapIdx === null ? elemScore : child1Score)) {
            swapIdx = child2Idx;
         }
      }

      // If the element needs to be moved, swap it, and continue.
      if (swapIdx !== null) {
         this.content[idx] = this.content[swapIdx];
         this.content[swapIdx] = element;
         idx = swapIdx;
      // Otherwise, we are done.
      } else {
         break;
      }
   }
   return;
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/prng": function(require, exports, module) {
/**
 * @fileoverview A seedable random-number generator. Especially
 * useful in conjunction with the noise generator in `gamejs/utils/noise`.
 *
 */
// From http://baagoe.com/en/RandomMusings/javascript/
// Johannes Baage <baagoe@baagoe.com>, 2010
// API modified by Simon Oberhammer <simon@nekapuzer.at>, 2012
// discussion of the used algorithms <http://baagoe.org/en/w/index.php/Better_random_numbers_for_javascript>


/* @ignore */
var Mash = function Mash() {
  var n = 0xefc8249d;
  this.hash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  this.version = 'Mash 0.9';
  return this;
}

/**
 * A seedable pseudo-random number generator.
 * @param {Number|String} seed the seed for generating the numbers
 *
 * @usage
 *  var prng = require('gamejs/utils/prng');
 *  var seed = 'gamejs';
 *  var alea = new prng.Alea(seed);
 *  alea.random(); // 0.6765871671959758
 *  alea.random(); // 0.15881546027958393
 *
 *  // generator with the same seed will generate the same sequence
 *  // of numbers:
 *  var aleaTwo = new prng.Alea(seed);
 *  aleaTwo.random(); // 0.6765871671959758
 *  aleaTwo.random(); // 0.15881546027958393
 */
var Alea = exports.Alea = function Alea() {
   var args = Array.prototype.slice.call(arguments);
   var s0 = 0;
   var s1 = 0;
   var s2 = 0;
   var c = 1;
   if (args.length == 0) {
     args = [+new Date];
   }
   var mash = new Mash();
   s0 = mash.hash(' ');
   s1 = mash.hash(' ');
   s2 = mash.hash(' ');

   for (var i = 0; i < args.length; i++) {
     s0 -= mash.hash(args[i]);
     if (s0 < 0) {
       s0 += 1;
     }
     s1 -= mash.hash(args[i]);
     if (s1 < 0) {
       s1 += 1;
     }
     s2 -= mash.hash(args[i]);
     if (s2 < 0) {
       s2 += 1;
     }
   }
   mash = null;

   /**
    * @returns {Number} the next random number as determined by the seed
    */
   this.random = function() {
     var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
     s0 = s1;
     s1 = s2;
     return s2 = t - (c = t | 0);
   };
   return this;
};

}}, ["gamejs/utils/prng"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/matrix": function(require, exports, module) {
/**
 * @fileoverview Matrix manipulation, used by GameJs itself. You
 * probably do not need this unless you manipulate a Context's transformation
 * matrix yourself.
 */

// correct way to do scale, rotate, translate
// *  gamejs.utils.matrix will be used in gamejs.transforms, modifing the surfaces.matrix
// * this matrix must be applied to the context in Surface.draw()

/**
 * @returns {Array} [1, 0, 0, 1, 0, 0]
 */
var identiy = exports.identity = function () {
   return [1, 0, 0, 1, 0, 0];
};

/**
 * @param {Array} matrix
 * @param {Array} matrix
 * @returns {Array} matrix sum
 */
var add = exports.add = function(m1, m2) {
   return [
      m1[0] + m2[0],
      m1[1] + m2[1],
      m1[2] + m2[2],
      m1[3] + m2[3],
      m1[4] + m2[4],
      m1[5] + m2[5],
      m1[6] + m2[6]
   ];
};

/**
 * @param {Array} matrix A
 * @param {Array} matrix B
 * @returns {Array} matrix product
 */
var multiply = exports.multiply = function(m1, m2) {
   return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
   ];
};

/**
 * @param {Array} matrix
 * @param {Number} dx
 * @param {Number} dy
 * @returns {Array} translated matrix
 */
var translate = exports.translate = function(m1, dx, dy) {
   return multiply(m1, [1, 0, 0, 1, dx, dy]);
};

/**
 * @param {Array} matrix
 * @param {Number} angle in radians
 * @returns {Array} rotated matrix
 */
var rotate = exports.rotate = function(m1, angle) {
   // radians
   var sin = Math.sin(angle);
   var cos = Math.cos(angle);
   return multiply(m1, [cos, sin, -sin, cos, 0, 0]);
};

/**
 * @param {Array} matrix
 * @returns {Number} rotation in radians
 */
var rotation = exports.rotation = function(m1) {
      return Math.atan2(m1[1], m1[0]);
};

/**
 * @param {Array} matrix
 * @param {Array} vector [a, b]
 * @returns {Array} scaled matrix
 */
var scale = exports.scale = function(m1, svec) {
   var sx = svec[0];
   var sy = svec[1];
   return multiply(m1, [sx, 0, 0, sy, 0, 0]);
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/base64": function(require, exports, module) {
/**
 * @fileoverview
 * Base64 encode / decode
 * @author http://www.webtoolkit.info
 */


var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * Decodes a base64 encoded string to a string.
 */
var decode = exports.decode = function(input) {
   var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
   input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

   while (i < input.length) {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));

      chr1 = (enc1 << 2) | (enc2 >> 4);
      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      chr3 = ((enc3 & 3) << 6) | enc4;

      output.push(String.fromCharCode(chr1));

      if (enc3 != 64) {
         output.push(String.fromCharCode(chr2));
      }
      if (enc4 != 64) {
         output.push(String.fromCharCode(chr3));
      }
   }

   output = output.join('');
   return output;
};

/**
 * Decodes a base64 encoded string into a byte array
 * @param {String} input
 * @param {Array} bytes bytes per character, defaults to 1
 */
exports.decodeAsArray = function(input, bytes) {
   bytes = bytes || 1;
   var decoded = decode(input);
   var len = decoded.length / bytes;
   var array = [];
   for (var i=0; i< len; i++) {
      array[i] = 0;
      for (var j = bytes - 1; j >=0; --j) {
         array[i] += decoded.charCodeAt((i * bytes) + j) << (j <<3 )
      }
   }
   return array;
}

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/math": function(require, exports, module) {
/**
 *
 * absolute angle to relative angle, in degrees
 * @param {Number} absolute angle in degrees
 * @returns {Number} relative angle in degrees
 */
exports.normaliseDegrees=function(degrees){
    degrees=degrees % 360;
    if(degrees<0) {
        degrees+=360;
    }
    return degrees;
};

/**
 *
 * absolute angle to relative angle, in radians
 * @param {Number} absolute angle in radians
 * @returns {Number} relative angle in radians
 */
exports.normaliseRadians=function(radians){
    radians=radians % (2*Math.PI);
    if(radians<0) {
        radians+=(2*Math.PI);
    }
    return radians;
};

/**
 *
 * convert radians to degrees
 * @param {Number} radians
 * @returns {Number} degrees
 */
exports.degrees=function(radians) {
    return radians*(180/Math.PI);
};

/**
 *
 * convert degrees to radians
 * @param {Number} degrees
 * @returns {Number} radians
 */
exports.radians=function(degrees) {
    return degrees*(Math.PI/180);
};

/**
 * @returns the center of multipled 2d points
 * @param {Array} first point
 * @param {Array} second point
 * @param {Array} ...
 */
exports.centroid = function() {
   var args = Array.prototype.slice.apply(arguments, [0]);
   var c = [0,0];
   args.forEach(function(p) {
      c[0] += parseInt(p[0], 10);
      c[1] += parseInt(p[1], 10);
   });
   var len = args.length;
   return [
      c[0] / len,
      c[1] / len
   ];
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/vectors": function(require, exports, module) {
var math=require('./math');

/**
 * @param {Array} origin point [b0, b1]
 * @param {Array} target point [b0, b1]
 * @returns {Number} distance between two points
 */
exports.distance = function(a, b) {
   return len(subtract(a, b));
};

/**
 * subtracts vectors [a0, a1] - [a0, a1]
 * @param {Array} a
 * @param {Array} b
 * @returns {Array} vector
 */
var subtract = exports.subtract = function(a, b) {
   return [a[0] - b[0], a[1] - b[1]];
};

/**
 * adds vectors [a0, a1] - [a0, a1]
 * @param {Array} a vector
 * @param {Array} b vector
 * @returns {Array} vector
 */
var add = exports.add = function(a, b) {
   return [a[0] + b[0], a[1] + b[1]];
};

/**
 * multiply vector with scalar or other vector
 * @param {Array} vector [v0, v1]
 * @param {Number|Array} vector or number
 * @returns {Number|Array} result
 */
var multiply = exports.multiply = function(a, s) {
   if (typeof s === 'number') {
      return [a[0] * s, a[1] * s];
   }

   return [a[0] * s[0], a[1] * s[1]];
};

/**
 * @param {Array} a vector
 * @param {Number} s
 */
exports.divide = function(a, s) {
   if (typeof s === 'number') {
      return [a[0] / s, a[1] / s];
   }
   throw new Error('only divide by scalar supported');
};

/**
 * @param {Array} vector [v0, v1]
 * @returns {Number} length of vector
 */
var len = exports.len = function(v) {
   return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
};

/**
 *
 * normalize vector to unit vector
 * @param {Array} vector [v0, v1]
 * @returns {Array} unit vector [v0, v1]
 */
var unit = exports.unit = function(v) {
   var l = len(v);
   if(l) return [v[0] / l, v[1] / l];
   return [0, 0];
};

/**
 *
 * rotate vector
 * @param {Array} vector [v0, v1]
 * @param {Number} angle to rotate vector by, radians. can be negative
 * @returns {Array} rotated vector [v0, v1]
 */
exports.rotate=function(v, angle){
   angle=math.normaliseRadians(angle);
   return [v[0]* Math.cos(angle)-v[1]*Math.sin(angle),
           v[0]* Math.sin(angle)+v[1]*Math.cos(angle)];

};

/**
 *
 * calculate vector dot product
 * @param {Array} vector [v0, v1]
 * @param {Array} vector [v0, v1]
 * @returns {Number} dot product of v1 and v2
 */
var dot = exports.dot=function(v1, v2){
   return (v1[0] * v2[0]) + (v1[1] * v2[1]);
};

/**
 *
 * calculate angle between vectors
 * @param {Array} vector [v0, v1]
 * @param {Array} vector [v0, v1]
 * @returns {Number} angle between v1 and v2 in radians
 */
exports.angle=function(v1, v2){
   var a1 = Math.atan2(v1[0], v1[1]);
   var a2 = Math.atan2(v2[0], v2[1]);
   var rel = a1 - a2;
   return (rel - Math.floor((rel + Math.PI) / (2 * Math.PI)) * (2 * Math.PI) - (2 * Math.PI)) % (Math.PI * 2)
};

/**
 * @returns {Array} vector with max length as specified.
 */
exports.truncate = function(v, maxLength) {
   if (len(v) > maxLength) {
      return multiply(unit(v), maxLength);
   };
   return v;
};

}}, ["gamejs/utils/math"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/utils/uri": function(require, exports, module) {
/**
 * @fileoverview Utilies for URI handling.
 *
 */

var URI_REGEX = new RegExp(
    '^' +
    '(?:' +
      '([^:/?#.]+)' +                     // scheme - ignore special characters
                                          // used by other URL parts such as :,
                                          // ?, /, #, and .
    ':)?' +
    '(?://' +
      '(?:([^/?#]*)@)?' +                 // userInfo
      '([\\w\\d\\-\\u0100-\\uffff.%]*)' + // domain - restrict to letters,
                                          // digits, dashes, dots, percent
                                          // escapes, and unicode characters.
      '(?::([0-9]+))?' +                  // port
    ')?' +
    '([^?#]+)?' +                         // path
    '(?:\\?([^#]*))?' +                   // query
    '(?:#(.*))?' +                        // fragment
    '$');

/**
 * Resolve path against URI.
 *
 * @param {String} uri
 * @param {String} path to resolve
 */
var resolve = exports.resolve = function(uri, path) {
   var m = match(uri);
   var n = match(path);
   var host = '';
   if(m[1] && m[3]) host = m[1] + '://' + m[3];
   if (n[1]) {
      return path;
   }
   if (m[4]) {
      host = host + ":" + m[4];
   }
   var absolutePath = m[5];
   if (path.charAt(0) !== '/') {
      var lastSlashIndex = absolutePath.lastIndexOf('/');
      absolutePath = absolutePath.substr(0, lastSlashIndex + 1) + path;
   } else {
      absolutePath = path;
   }
   return host + removeDotSegments(absolutePath);

};

/**
 * Try to match an URI against a regex returning the following
 * capture groups:
 *     $1 = http              scheme
 *     $2 = <undefined>       userInfo -\
 *     $3 = www.ics.uci.edu   domain     | authority
 *     $4 = <undefined>       port     -/
 *     $5 = /pub/ietf/uri/    path
 *     $6 = <undefined>       query without ?
 *     $7 = Related           fragment without #
 *
 * @param {String} uri
 */
var match = exports.match = function(uri) {
   return uri.match(URI_REGEX);
}

/**
 * Make an absolute URI relative to document.location.href
 * @param {String} uri
 * @returns The relative URI or the unchanged URI if it's not
 * possible to make it relative to the path of document.location.href.
 */
var makeRelative = exports.makeRelative = function(uri) {
   var docLocPath = resolve(document.location.href, './');
   if (uri.indexOf(docLocPath) == 0) {
      uri = './' + uri.substring(docLocPath.length);
   }
   return uri;
};

/**
 * Removes dot segments in given path component
 */
var removeDotSegments = function(path) {
   if (path == '..' || path == '.') {
      return '';
   }
   var leadingSlash = path.indexOf('/') > -1;

   var segments = path.split('/');
   var out = [];

   for (var pos = 0; pos < segments.length; ) {
      var segment = segments[pos++];

      if (segment == '.') {
         if (leadingSlash && pos == segments.length) {
            out.push('');
         }
      } else if (segment == '..') {
         if (out.length > 1 || out.length == 1 && out[0] != '') {
            out.pop();
         }
         if (leadingSlash && pos == segments.length) {
            out.push('');
         }
      } else {
         out.push(segment);
         leadingSlash = true;
      }
   }
   return out.join('/');
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/display": function(require, exports, module) {
var Surface = require('../gamejs').Surface;

/**
 * @fileoverview Methods to create, access and manipulate the display Surface.
 *
 * @example
 * var display = gamejs.display.setMode([800, 600]);
 * // blit sunflower picture in top left corner of display
 * var sunflower = gamejs.image.load("images/sunflower");
 * display.blit(sunflower);
 *
 */

var CANVAS_ID = "gjs-canvas";
var LOADER_ID = "gjs-loader";
var SURFACE = null;

/**
 * Pass this flag to `gamejs.display.setMode(resolution, flags)` to disable
 * pixel smoothing; this is, for example, useful for retro-style, low resolution graphics
 * where you don't want the browser to smooth them when scaling & drawing.
 */
var DISABLE_SMOOTHING = exports.DISABLE_SMOOTHING = 2;

var _SURFACE_SMOOTHING = true;

/**
 * @returns {document.Element} the canvas dom element
 */
var getCanvas = function() {
   return document.getElementById(CANVAS_ID);
};

/**
 * Create the master Canvas plane.
 * @ignore
 */
exports.init = function() {
   // create canvas element if not yet present
   var jsGameCanvas = null;
   if ((jsGameCanvas = getCanvas()) === null) {
      jsGameCanvas = document.createElement("canvas");
      jsGameCanvas.setAttribute("id", CANVAS_ID);
      document.body.appendChild(jsGameCanvas);
   }
   // to be focusable, tabindex must be set
   jsGameCanvas.setAttribute("tabindex", 1);
   jsGameCanvas.focus();
   // remove loader if any;
   var $loader = document.getElementById('gjs-loader');
   if ($loader) {
      $loader.style.display = "none";
   }
   return;
};

/** @ignore **/
exports._hasFocus = function() {
   return document.activeElement == getCanvas();
}

/** @ignore **/
exports._isSmoothingEnabled = function() {
   return (_SURFACE_SMOOTHING === true);
}

/**
 * Set the width and height of the Display. Conviniently this will
 * return the actual display Surface - the same as calling [gamejs.display.getSurface()](#getSurface))
 * later on.
 * @param {Array} dimensions [width, height] of the display surface
 * @param {Number} flags currently only gamejs.display.DISABLE_SMOOTHING supported
 */
exports.setMode = function(dimensions, flags) {
   var canvas = getCanvas();
   canvas.width = dimensions[0];
   canvas.height = dimensions[1];
   _SURFACE_SMOOTHING = (flags !== DISABLE_SMOOTHING);
   return getSurface();
};

/**
 * Set the Caption of the Display (document.title)
 * @param {String} title the title of the app
 * @param {gamejs.Image} icon FIXME implement favicon support
 */
exports.setCaption = function(title, icon) {
   document.title = title;
};


/**
 * The Display (the canvas element) is most likely not in the top left corner
 * of the browser due to CSS styling. To calculate the mouseposition within the
 * canvas we need this offset.
 * @see gamejs/event
 * @ignore
 *
 * @returns {Array} [x, y] offset of the canvas
 */

exports._getCanvasOffset = function() {
   var boundRect = getCanvas().getBoundingClientRect();
   return [boundRect.left, boundRect.top];
};

/**
 * Drawing on the Surface returned by `getSurface()` will draw on the screen.
 * @returns {gamejs.Surface} the display Surface
 */
var getSurface = exports.getSurface = function() {
   if (SURFACE === null) {
      var canvas = getCanvas();
      SURFACE = new Surface([canvas.clientWidth, canvas.clientHeight]);
      SURFACE._canvas = canvas;
      SURFACE._context = canvas.getContext('2d');
      if (_SURFACE_SMOOTHING) {
         SURFACE._smooth();
      } else {
         SURFACE._noSmooth();
      }
   }
   return SURFACE;
};

}}, ["gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/xml": function(require, exports, module) {
/**
 * @fileoverview
 *
 * Provides facilities for parsing an xml String.
 * 
 * You will typically get a `gamejs.xml.Document` instance
 * by loading the data with one of the two static 
 * `Document.fromString(string)` or `Document.fromUrl(url)`.

 * Querying for `elements(name)` or `children()` will return a
 * new `gamejs.xml.Document` matching your result (or null).
 *
 * Use `attributes(name)` and `value()` to get the data stored
 * in the XML Document.
 */

/**
 * XMLParser
 */
var Parser = exports.Parser = function() {

   var xmlDoc = null;
   var parser = new DOMParser();
   
   this.parseFromString = function(xmlString) {
      xmlDoc = parser.parseFromString(xmlString, 'text/xml');
      return xmlDoc;
   };
   
   return this;
};

/**
 * Instantiate with the static functions `Document.fromString()` and `fromURL()`.
 */
var Document = exports.Document = function(xmlDocument) {   
   if (!xmlDocument || (!xmlDocument instanceof XMLDocument) ) {
      throw new Error('Need a valid xmlDocument.');
   }
   /** @ignore **/
   this._xmlDocument = xmlDocument;
   return this;
};

/**
 * Returns the first element in the current document whose tag-name matches
 * the given 'name'.
 * @returns gamejs.xml.Document
 */
Document.prototype.element = function(name) {
   var elem = this._xmlDocument.getElementsByTagName(name)[0];
   return elem && new Document(elem) || null;
};

/**
 * Returns all elements in the current document whose tag-name matches
 * the given 'name'.
 * @returns an Array of gamejs.xml.Document
 */
Document.prototype.elements = function(name) {
   var elems = this._xmlDocument.getElementsByTagName(name);
   return Array.prototype.slice.apply(elems, [0]).map(function(elem) {
      return new Document(elem);
   });
};

/**
 * Returns the attribute value of this document.
 *
 * @returns String
 */
Document.prototype.attribute = function(name) {
   var attributeValue = this._xmlDocument.getAttribute(name);
   attributeValue = attributeValue ? attributeValue.trim() : null;
   if (attributeValue === null) {
      return null;
   }
   if (attributeValue.toLowerCase() === 'true') {
      return true;
   }
   if (attributeValue.toLowerCase() === 'false') {
      return false;
   }
   var attributeIntValue = parseInt(attributeValue, 10);
   var attributeFloatValue = parseFloat(attributeValue, 10);
   if (!isNaN(attributeIntValue)) {
      if (attributeFloatValue !== attributeIntValue) {
         return attributeFloatValue;
      }
      return attributeIntValue;
   }
   return attributeValue;
};

/**
 * Returns the nodevalue of the current xml document
 * @returns String
 */
Document.prototype.value = function() {
   return this._xmlDocument.nodeValue;
};

/**
 * Returns all children of this xml document
 * @returns Array of gamejs.xml.Document
 */
Document.prototype.children = function() {
   return Array.prototype.slice.apply(this._xmlDocument.childNodes, [0]).map(function(cNode) {
      return new Document(cNode);
   });
};

/**
 * @returns gamejs.xml.Document
 */
Document.fromString = function(xmlString) {
   var parser = new DOMParser();
   var xmlDoc = parser.parseFromString(xmlString, 'text/xml');
   return new Document(xmlDoc);
};

/**
 * @returns gamejs.xml.Document
 */
Document.fromURL = function(url) {
   var response = new XMLHttpRequest();
   response.open('GET', url, false);
   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
   response.setRequestHeader('Content-Type', 'text/xml');
   response.overrideMimeType('text/xml');
   response.send();
   return new Document(response.responseXML);
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/worker": function(require, exports, module) {
var gamejs = require('../gamejs');
var uri = require('./utils/uri');

/**
 * @fileoverview
 * Workers are useful to relieve your GameJs application from code which
 * might take long to run. Either expensive algorithms, which might get called
 * every now and then (e.g., path-finding) or another logic being run continously
 * within the rendering loop (e.g., physics engine).
 *
 * A Worker is like a seperate GameJs application being executed - another `main.js`
 * with its own `gamejs.ready()`. The Worker's most important feature is that
 * code executing within it does not block the rendering code. The Worker's
 * greatest limitation is that you can only communicate with it through text
 * messages.
 *
 * See the `examples/workers` directory for a running example.
 *
 * @example
 *  // Create a worker with the main module "./test"
 *  var fooWorker = new Worker('./test');
 *  // Send a message to your worker.
 *  // The Message doesn't have to be a string but it must be `JSON.stringify()`-able
 *  fooWorker.post("foobar");
 *
 *  // The result of the worker will be accessible
 *  // in the main application via the gamejs.event queue
 *  if (event.type === gamejs.event.WORKER_RESULT) {
 *     gamejs.log('Worker #' + event.worker.id + ' returned ' + event.data);
 *  }
 *
 *  // In the worker module, we can send results back to the main application
 *  // by posting them to the gamejs event queue as type `gamejs.event.WORKER_RESULT`
 *  gamejs.event.post({
 *     type: gamejs.event.WORKER_RESULT,
 *     data: "zarzar"
 *  });
 *
 */

/**
 * true if this GameJs instance is being executed within a WebWorker
 * @type Boolean
 */
exports.inWorker = (this.importScripts !== undefined);

/**
 * Executed in scope of worker after user's main module
 * @ignore
 */
exports._ready = function () {
   var gamejs = require('gamejs');
   self.onmessage = function(event) {
      gamejs.event.post(event.data)
   };
   self.postMessage({
      type: gamejs.event.WORKER_ALIVE
   });
};

/**
 * Send message to main context for logging
 * @ignore
 **/
exports._logMessage = function() {
   self.postMessage({
      type: gamejs.event.WORKER_LOGMESSAGE,
      arguments: Array.prototype.slice.apply(arguments)
   });
};

/**
 * Send result message to main context
 * @ignore
 */
exports._messageMain = function(event) {
   self.postMessage({
      type: gamejs.event.WORKER_RESULT,
      data: event.data
   });
};

/**
  * executed in scope of worker before user's main module
  * @ignore
  */
var workerPrefix = function workerPrefix() {
   __scripts.forEach(function(script) {
      try {
         importScripts(script)
      } catch (e) {
         // can't help the worker
      }
   });
};

/**
 * Setup a worker which has `require()` defined
 * @ignore
 **/
var create = function(workerModuleId) {
   var moduleRoot = uri.resolve(document.location.href, window.require.getModuleRoot());
   var initialScripts = [];
   Array.prototype.slice.apply(document.getElementsByTagName('script'), [0]).forEach(function(script) {
      if (script.src) {
         initialScripts.push(script.src);
      }
   });

   var URL = window.URL || window.webkitURL;
   var prefixString = workerPrefix.toString();
   // don't be afraid...
   prefixString = prefixString.substring(prefixString.indexOf("{") + 1, prefixString.lastIndexOf("}"));
   var blob = new Blob([
      'var __scripts = ["' + initialScripts.join('","') + '"];',
      prefixString,
      'self.require.setModuleRoot("' + moduleRoot + '");',
      'self.require.run("'+ workerModuleId +'");'
   ], {type: 'application\/javascript'});

   var blobURL = URL.createObjectURL(blob);
   return new Worker(blobURL);
};

/**
 * The `Worker` constructor takes only one argument: a module id. This module
 * will be executed inside the newly created Worker. It is effectively the
 * main module of the Worker.
 *
 * Inside a Worker, you can use `require()` to import other scripts or
 * GameJs modules.
 *
 * **Note:** A Worker does not have access to the browser's `document`. So
 * a lot of GameJs modules - everything related to drawing to the canvas -
 * do not work in the Worker.
 *
 * You can use `gamejs.time.*`, `gamejs.utils.*`, `gamejs.event.*` and probably others
 * (as well as any module you write yourself for this purpose, of course).
 *
 * @param {String} moduleId The Worker's main module id. The main module will be executed in the worker
 */
exports.Worker = function(moduleId) {
   // FIXME id should be unchangeable
   /**
    * Unique id of this worker
    * @property {Number}
    */
   var id = this.id = guid(moduleId);
   var worker = create(moduleId);
   var deadQueue = [];
   var alive = false;
   var self  = this;

   worker.onmessage = function(event) {
      if (event.data.type === gamejs.event.WORKER_ALIVE) {
         alive = true;
         deadQueue.forEach(function(data) {
            self.post(data);
         });
      } else if (event.data.type === gamejs.event.WORKER_LOGMESSAGE) {
         gamejs.log.apply(null, [id].concat(event.data.arguments));
      } else {
         gamejs.event.post({
            type: gamejs.event.WORKER_RESULT,
            data: event.data.data,
            worker: self,
            event: event,
         })
      }
   };
   worker.onerror = function(event) {
      gamejs.error('Error in worker "' + id + '" line ' + event.lineno + ': ', event.message)
      gamejs.event.post({
         type: gamejs.event.WORKER_ERROR,
         data: event.data,
         worker: self,
         event: event,
      })
   };

   /**
    * Send a message to the worker
    *
    * @param {Object} data Payload object which gets sent to the Worker
    */
   this.post = function(data) {
      if (alive) {
         worker.postMessage({
            type: gamejs.event.WORKER,
            data: data
         });
      } else {
         deadQueue.push(data);
      }
   };
   return this;
}

/**
 * not a real GUID
 * @ignore
 */
function guid(moduleId) {
   var S4 = function() {
      return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
   };
   return moduleId + '@' + (S4()+S4());
}

}}, ["gamejs", "gamejs/utils/uri", "gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/draw": function(require, exports, module) {
/**
 * @fileoverview Utilities for drawing geometrical objects to Surfaces. If you want to put images on
 * the screen see gamejs/image.
 *
 * There are several ways to specify colors. Whenever the docs says "valid #RGB string"
 * you can pass in any of the following formats.
 *
 *
 * @example
 *     "#ff00ff"
 *     "rgb(255, 0, 255)"
 *     "rgba(255,0, 255, 1)"
 * @see gamejs/image
 */

// FIXME all draw functions must return a minimal rect containing the drawn shape

/**
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] position of line start
 * @param {Array} endPos [x, y] position of line end
 * @param {Number} width of the line, defaults to 1
 */
exports.line = function(surface, color, startPos, endPos, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.lineTo(endPos[0], endPos[1]);
   ctx.stroke();
   ctx.restore();
   return;
};

/**
 * Draw connected lines. Use this instead of indiviudal line() calls for
 * better performance
 *
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB string, "#ff0000"
 * @param {Boolean} closed if true the last and first point are connected
 * @param {Array} pointlist holding array [x,y] arrays of points
 * @param {Number} width width of the lines, defaults to 1
 */
exports.lines = function(surface, color, closed, pointlist, width) {
   closed = closed || false;
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.lineWidth = width || 1;
   pointlist.forEach(function(point, idx) {
      if (idx === 0) {
         ctx.moveTo(point[0], point[1]);
      } else {
         ctx.lineTo(point[0], point[1]);
      }
   });
   if (closed) {
      ctx.lineTo(pointlist[0][0], pointlist[0][1]);
   }
   ctx.stroke();
   ctx.restore();
   return;
};

/**
 * Draw a circle on Surface
 *
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pos [x, y] position of the circle center
 * @param {Number} radius of the circle
 * @param {Number} width width of the circle, if not given or 0 the circle is filled
 */
exports.circle = function(surface, color, pos, radius, width) {
   if (!radius) {
      throw new Error('[circle] radius required argument');
   }
   if (!pos || !(pos instanceof Array)) {
      throw new Error('[circle] pos must be given & array' + pos);
   }

   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.lineWidth = width || 1;
   ctx.arc(pos[0], pos[1], radius, 0, 2*Math.PI, true);
   if (width === undefined || width === 0) {
      ctx.fill();
   } else {
      ctx.stroke();
   }
   ctx.restore();
   return;
};

/**
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {gamejs.Rect} rect the position and dimension attributes of this Rect will be used
 * @param {Number} width the width of line drawing the Rect, if 0 or not given the Rect is filled.
 */
exports.rect = function(surface, color, rect, width) {
   var ctx =surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   if (isNaN(width) || width === 0) {
      ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
   } else {
      ctx.lineWidth = width || 1;
      ctx.strokeRect(rect.left, rect.top, rect.width, rect.height);
   }
   ctx.restore();
};

/**
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {gamejs.Rect} rect the position and dimension attributes of this Rect will be used
 * @param {Number} startAngle
 * @param {Number} stopAngle
 * @param {Number} width the width of line, if 0 or not given the arc is filled.
 */
exports.arc= function(surface, color, rect, startAngle, stopAngle, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.arc(rect.center[0], rect.center[1],
            rect.width/2,
            startAngle * (Math.PI/180), stopAngle * (Math.PI/180),
            false
         );
   if (isNaN(width) || width === 0) {
      ctx.fill();
   } else {
      ctx.lineWidth = width || 1;
      ctx.stroke();
   }
   ctx.restore();
};

/**
 * Draw a polygon on the surface. The pointlist argument are the vertices
 * for the polygon.
 *
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pointlist array of vertices [x, y] of the polygon
 * @param {Number} width the width of line, if 0 or not given the polygon is filled.
 */
exports.polygon = function(surface, color, pointlist, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.beginPath();
   pointlist.forEach(function(point, idx) {
      if (idx == 0) {
         ctx.moveTo(point[0], point[1]);
      } else {
         ctx.lineTo(point[0], point[1]);
      }
   });
   ctx.closePath();
   if (isNaN(width) || width === 0) {
      ctx.fill();
   } else {
      ctx.lineWidth = width || 1;
      ctx.stroke();
   }
   ctx.restore();
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/time": function(require, exports, module) {
/**
 * @fileoverview
 * Provides tools for game time managment.
 *
 * This is very different from how PyGame works. We can not
 * pause the execution of the script in Browser JavaScript, so what
 * we do you do is write a main function which contains the code
 * you would put into your main loop and pass that to `gamejs.time.interval()`:
 *
 * @example
 *  // call function `tick` as fast as the browser thinks is appropriate
 *  gamejs.time.interval(tick);
 *  // call the function `tick` maximally 20 times per second
 *  gamejs.time.interval(tick, 20);
 *
 *
 */


var TIMER_LASTCALL = null;
var CALLBACKS = {};
var CALLBACKS_LASTCALL = {};
var STARTTIME = null;

// `window` is not accessible in webworker (would lead to TypeError)
// @@ this cross-browser fuckery has to go away ASAP.
var reqAnimationFrame = typeof(window) != 'undefined' ?
                        window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        null : null;

var reqAniFrameRecursive = function() {
   perInterval();
   reqAnimationFrame(reqAniFrameRecursive)
}

/**
 * @ignore
 */
exports.init = function() {
   STARTTIME = Date.now();

   if (reqAnimationFrame) {
      reqAnimationFrame(reqAniFrameRecursive);
   } else {
      setInterval(perInterval, 10);
   }
   return;
};

/**
 * Call a function as fast as the browser thinks is good for an animation.
 *
 * Alternatively, the desired "frames per second" (fps) can be passed as
 * the second argument. This will limit the calls to the function to happen
 * at most this often per second. "fps" is thus a colloquial term for
 * "callback frequency per second".
 *
 * If you do not specify a required callback frequency but let the browser
 * decided how often the function should get called, then beware that the browser
 * can schedule your function to only be called as rarely as once per second
 * (for example, if the browser window is not visible).

 * @param {Function} fn the function to be called
 * @param {Number} fps optional callback frequency per second
 * @param {Object} thisObj optional context for callback function
 */
exports.interval = function(fn, fps, thisObj) {
   // both args are optional
   if (thisObj === undefined && isNaN(fps)) {
      thisObj = fps;
      fps = undefined;
   }
   fpsCallback(fn, thisObj, fps);
   return;
}

/**
 * This function is deprecated in favor of `gamejs.time.interval`
 * @see #interval
 *
 * @param {Function} fn the function to call back
 * @param {Object} thisObj `this` will be set to that object when executing the callback function
 * @param {Number} fps specify the framerate by which you want the callback to be called. (e.g. 30 = 30 times per seconds). default: 60
 * @deprecated
 * @ignore
 */
var fpsCallback = exports.fpsCallback = function(fn, thisObj, fps) {
   if (fps === undefined) {
     fps = 60;
   }

   fps = parseInt(1000/fps, 10);
   CALLBACKS[fps] = CALLBACKS[fps] || [];
   CALLBACKS_LASTCALL[fps] = CALLBACKS_LASTCALL[fps] || 0;

   CALLBACKS[fps].push({
      'rawFn': fn,
      'callback': function(msWaited) {
         fn.apply(thisObj, [msWaited]);
      }
   });
   return;
};

/**
 * @param {Function} callback the function delete
 * @param {Number} fps
 * @deprecated
 * @ignore
 */
exports.deleteCallback = function(callback, fps) {
   fps = parseInt(1000/fps, 10);
   var callbacks = CALLBACKS[fps];
   if (!callbacks) {
      return;
   }

   CALLBACKS[fps] = callbacks.filter(function(fnInfo, idx) {
      if (fnInfo.rawFn !== callback) {
         return true;
      }
      return false;
   });
   return;
};

var perInterval = function() {
   var msNow = Date.now();
   var lastCalls = CALLBACKS_LASTCALL;
   function callbackWrapper(fnInfo) {
      fnInfo.callback(msWaited);
   }
   for (var fpsKey in lastCalls) {
      if (!lastCalls[fpsKey]) {
         CALLBACKS_LASTCALL[fpsKey] = msNow;
      }
      var msWaited = msNow - lastCalls[fpsKey];
      if (fpsKey <= msWaited) {
         CALLBACKS_LASTCALL[fpsKey] = msNow;
         CALLBACKS[fpsKey].forEach(callbackWrapper, this);
      }
   }
   return;
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"gamejs/tmx": function(require, exports, module) {
var gamejs = require('../gamejs');
var objects = require('./utils/objects');
var xml = require('./xml');
var base64 = require('./utils/base64');
var uri = require('./utils/uri');

/**
 * @fileoverview
 * This is a loader for the general purpose tile map editor "Tiled".
 *
 * This module can load all ".tmx" files even if additionally base64 encoded
 * (can be configured in Tiled).
 *
 * This module loads the whole map definition, including the TileSets with
 * all necessary images. For an example on how to render a map loaded with
 * this module, see `examples/tiledmap`.
 *
 * You will typically create a Map instance with `Map(url)` and deal
 * with the layers, tilesets, etc. through the Map instance
 * instead of loading & creating them yourself.
 *
 * Only orthogonol maps are supported (no isometric maps).
 *
 * @see http://www.mapeditor.org/
 * @see https://github.com/bjorn/tiled/wiki/TMX-Map-Format
 */

/**
 * My code is inspired by:
 *   * https://bitbucket.org/maikg/tiled2cocos/
 *   * https://github.com/obiot/melonJS/
 *
 */

/**
 * A Tiled Map holds all layers defined in the tmx file as well
 * as the necessary tiles to render the map.
 * @param {String} url Relative or absolute URL to the tmx file
 */
var Map = exports.Map = function(url) {

   var url = uri.resolve(document.location.href, url);
   var xmlDoc = xml.Document.fromURL(url);
   var mapNode = xmlDoc.element('map');

   /**
    * Width of a single tile in pixels
    * @type Number
    */
   this.tileWidth = mapNode.attribute('tilewidth');
   /**
    * Height of a single tile in pixels
    * @type Number
    */
   this.tileHeight = mapNode.attribute('tileheight');
   /**
    * Width of the map in tiles
    * @type Number
    */
   this.width = mapNode.attribute('width');
   /**
    * Height of the map in tiles
    * @type Number
    */
   this.height = mapNode.attribute('height');

   var orientation = mapNode.attribute('orientation');
   if (orientation !== 'orthogonal') {
      throw new Error('only orthogonol maps supported');
   }

   /**
    * Custom properties of the map
    */
   this.properties = {};
   setProperties(this.properties, mapNode);

   /**
    * All tiles of this map.
    * @type TileSets
    */
   this.tiles = new TileSets(mapNode, url);
   this.layers = loadLayers(mapNode);
   return this;
};

/**
 * A Tile. Can not be instantiated. Get a Tile by calling `getTile(gid)`
 * on a `TileSets` instance.
 */
var Tile = exports.Tile = function() {
   throw new Error('Can not be instantiated.')
   /**
    * @type {gamejs.Surface} this tile's Surface
    */
   this.surface = null;
   /**
    * @type {Object} custom properties attach for this tile
    */
   this.properties = null;
   return;
}

/**
 * A TileSets instance holds all tilesets of a map. This class
 * makes it easy to get the image for a certain tile ID. You usually
 * don't care about in which specific TileSet an image is so this
 * class holds them all and deals with the lookup.
 *
 * You don't usually create a `TileSets` instance yourself, instead
 * it is automatically created and attached to a `Map`.
 */
var TileSets = exports.TileSets = function(mapNode, mapUrl) {
   var tileSets = [];

   /**
    * Retrieve the image for a tile ID (gid).
    *
    * @param {Number} gid global tile id to retrieve
    * @returns {gamejs.Surface} the Surface for the gid
    */
   this.getSurface = function(gid) {
      var tile = this.getTile(gid);
      return tile && tile.surface || null;
   };

   /**
    * @param {Number} gid global tile id
    * @returns {Object} the custom properties of this tile
    */
   this.getProperties = function(gid) {
      var tile = this.getTile(gid);
      return tile && tile.properties || {};
   };

   /**
    * @param {Number} gid global tile id
    * @returns {Object} the Tile object for this gid
    */
   this.getTile = function(gid) {
      var tile = null;
      tileSets.some(function(tileSet, idx) {
         if (tileSet.firstGid <= gid) {
            tile = tileSet.tiles[gid - tileSet.firstGid];
            return true;
         }
         return false;
      }, this);
      return tile;
   };

   var loadTileSet = function(tileSetNode) {
      var tiles = [];
      var tileWidth = tileSetNode.attribute('tilewidth');
      var tileHeight = tileSetNode.attribute('tileheight');
      var spacing = tileSetNode.attribute('spacing') || 0;
      // broken in tiled?
      var margin = 0;

      var imageNode = tileSetNode.element('image');
      var imageAtlasFile = imageNode.attribute('source');
      var imageUrl = uri.makeRelative(uri.resolve(mapUrl, imageAtlasFile));
      var atlas = gamejs.image.load(imageUrl);
      // FIXME set transparency if imageNode.attribute('trans') is set

      var tileNodes = tileSetNode.elements('tile')
      var dims = atlas.getSize();
      var imgSize = new gamejs.Rect([0,0], [tileWidth, tileHeight]);
      var idx = 0;
      var y = 0;
      while (y + tileHeight <= dims[1]) {
         x = 0;
         while (x + tileWidth <= dims[0]) {
            var tileImage = new gamejs.Surface(tileWidth, tileHeight);
            var rect = new gamejs.Rect([x, y], [tileWidth, tileHeight]);
            tileImage.blit(atlas, imgSize, rect);
            var tileProperties = {};
            tileNodes.some(function(tileNode) {
               if (tileNode.attribute('id') === idx) {
                  setProperties(tileProperties, tileNode);
                  return true;
               }
            }, this);
            tiles.push({
               surface: tileImage,
               properties: tileProperties
            });
            x += tileWidth + spacing;
            idx++;
         }
         y += tileHeight + spacing;
      }
      return tiles;
   }

   /**
    *
    * constructor
    **/
   mapNode.elements('tileset').forEach(function(tileSetNode) {
      var firstGid = tileSetNode.attribute('firstgid');
      var externalSource = tileSetNode.attribute('source');
      if (externalSource) {
         var tileSetDocument = xml.Document.fromURL(uri.resolve(mapUrl, externalSource));
         tileSetNode = tileSetDocument.element('tileset');
      }
      tileSets.push({
         tiles: loadTileSet(tileSetNode),
         firstGid: firstGid
      });
   });
   tileSets.reverse();

   return this;
};

/**
 * loadLayers
 */
var H_FLIP = 0x80000000;
var V_FLIP = 0x40000000;
var loadLayers = function(mapNode) {
   var layers = [];

   var getGids = function(layerNode) {
      var dataNode = layerNode.element('data');
      var encoding = dataNode.attribute('encoding');
      var compression = dataNode.attribute('compression')
      var data = "";
      dataNode.children().forEach(function(textNode) {
         data += textNode.value();
      });
      var byteData = [];
      if (encoding === 'base64') {
         if (compression) {
            throw new Error('Compression of map data unsupported');
         }
         byteData = base64.decodeAsArray(data, 4);
      } else if (encoding === 'csv') {
         data.trim().split('\n').forEach(function(row) {
            row.split(',', width).forEach(function(entry) {
               byteData.push(parseInt(entry, 10));
            });
         });
      } else {
         // FIXME individual XML tile elements
         throw new Error('individual tile format not supported');
      }
      return byteData;
   };

   var width = mapNode.attribute('width');
   var height = mapNode.attribute('height');
   mapNode.elements('layer').forEach(function(layerNode) {
      // create empty gid matrix
      var gidMatrix = [];
      var i = height;
      while (i-->0) {
         var j = width;
         gidMatrix[i] = [];
         while (j-->0) {
            gidMatrix[i][j] = 0;
         }
      }

      getGids(layerNode).forEach(function(gid, idx) {
         // FIXME flipX/Y currently ignored
         var flipX = gid & H_FLIP;
         var flipY = gid & V_FLIP;
         // clear flags
         gid &= ~(H_FLIP | V_FLIP);
         gidMatrix[parseInt(idx / width, 10)][parseInt(idx % width, 10)] = gid;
      });
      layers.push({
         gids: gidMatrix,
         opacity: layerNode.attribute('opacity'),
         visible: layerNode.attribute('visible'),
         properties: setProperties({}, layerNode)
      });
   });
   return layers;
}

/**
 * set generic <properties><property name="" value="">... on given object
 */
var setProperties = function(object, node) {
   var props = node.element('properties');
   if (!props) {
      return;
   }
   props.elements('property').forEach(function(propertyNode) {
      var name = propertyNode.attribute('name');
      var value = propertyNode.attribute('value');
      object[name] = value;
   });
   return object;
};

}}, ["gamejs", "gamejs/utils/objects", "gamejs/xml", "gamejs/utils/base64", "gamejs/utils/uri"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs/mask": function(require, exports, module) {
var gamejs = require('../gamejs');
var objects = require('./utils/objects');

/**
 * @fileoverview Image masks. Usefull for pixel perfect collision detection.
 */

/**
 * Creates an image mask from the given Surface. The alpha of each pixel is checked
 * to see if it is greater than the given threshold. If it is greater then
 * that pixel is set as non-colliding.
 *
 * @param {gamejs.Surface} surface
 * @param {Number} threshold 0 to 255. defaults to: 255, fully transparent
 */
exports.fromSurface = function(surface, threshold) {
   threshold = threshold && (255 - threshold) || 255;
   var imgData = surface.getImageData().data;
   var dims = surface.getSize();
   var mask = new Mask(dims);
   for (var i=0;i<imgData.length;i += 4) {
      // y: pixel # / width
      var y = parseInt((i / 4) / dims[0], 10);
      // x: pixel # % width
      var x = parseInt((i / 4) % dims[0], 10);
      var alpha = imgData[i+3];
      if (alpha >= threshold) {
         mask.setAt(x, y);
      }
   }
   return mask;
};

/**
 * Image Mask
 * @param {Array} dimensions [width, height]
 *
 */
var Mask = exports.Mask = function(dims) {
   /**
    * @ignore
    */
   this.width = dims[0];
   /**
    * @ignore
    */
   this.height = dims[1];
   /**
    * @ignore
    */
   this._bits = [];
   for (var i=0;i<this.width;i++) {
      this._bits[i] = [];
      for (var j=0;j<this.height;j++) {
         this._bits[i][j] = false;
      }
   }
   return;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns the overlapping rectangle or null if there is no overlap;
 */
Mask.prototype.overlapRect = function(otherMask, offset) {
   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }
   // bounding box intersect
   if (!brect.collideRect(arect)) {
      return null;
   }
   var xStart = Math.max(arect.left, brect.left);
   var xEnd = Math.min(arect.right, brect.right);

   var yStart = Math.max(arect.top, brect.top);
   var yEnd = Math.min(arect.bottom, brect.bottom);

   return new gamejs.Rect([xStart, yStart], [xEnd - xStart, yEnd - yStart]);
};

/**
 *
 * @returns True if the otherMask overlaps with this map.
 * @param {Mask} otherMask
 * @param {Array} offset
 */
Mask.prototype.overlap = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return false;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var count = 0;
   for (var y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (var x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             return true;
         }
      }
   }
   // NOTE this should not happen because either we bailed out
   // long ago because the rects do not overlap or there is an
   // overlap and we should not have gotten this far.
   // throw new Error("Maks.overlap: overlap detected but could not create mask for it.");
   return false;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns the number of overlapping pixels
 */
Mask.prototype.overlapArea = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return 0;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var count = 0;
   for (var y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (var x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             count++;
         }
      }
   }
   return count;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns a mask of the overlapping pixels
 */
Mask.prototype.overlapMask = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return 0;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var mask = new Mask([overlapRect.width, overlapRect.height]);
   for (var y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (var x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             mask.setAt(x, y);
         }
      }
   }
   return mask;
};

/**
 * Set bit at position.
 * @param {Number} x
 * @param {Number} y
 */
Mask.prototype.setAt = function(x, y) {
   this._bits[x][y] = true;
};

/**
 * Get bit at position.
 *
 * @param {Number} x
 * @param {Number} y
 */
Mask.prototype.getAt = function(x, y) {
   x = parseInt(x, 10);
   y = parseInt(y, 10);
   if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
      return false;
   }
   return this._bits[x][y];
};


/**
 * Flip the bits in this map.
 */
Mask.prototype.invert = function() {
   this._bits = this._bits.map(function(row) {
      return row.map(function(b) {
         return !b;
      });
   });
};

/**
 * @returns {Array} the dimensions of the map
 */
Mask.prototype.getSize = function() {
   return [this.width, this.height];
};

objects.accessors(Mask.prototype, {
   /**
    * Rect of this Mask.
    */
   'rect': {
      get: function() {
         return new gamejs.Rect([0, 0], [this.width, this.height]);
      }
   },
   /**
    * @returns {Number} number of set pixels in this mask.
    */
   'length': {
      get: function() {
         var c = 0;
         this._bits.forEach(function(row) {
            row.forEach(function(b) {
               if (b) {
                  c++;
               }
            });
         });
         return c;
      }
   }
});

}}, ["gamejs", "gamejs/utils/objects"]);/* This file has been generated by yabbler.js */
require.define({
"utils": function(require, exports, module) {
var gamejs=require('gamejs');
var math=gamejs.utils.math;
var box2d=require('./engine').box2d;
var buffs=require('./buffs');
var settings=require('./settings');
var vectors = gamejs.utils.vectors;
var renderer=require('./renderer');

exports.renderLevelBackground=function(level, render_props){
    var cache=renderer.cache;
    var width=level.size[0];
    var height=level.size[1];
    var background=new gamejs.Surface([width, height]);
    var x, y;
    var tile=cache.getTile(level.bgtile);
    var sz=tile.getSize();
    for(y=0;y<height;y=y+sz[1]){
        for(x=0;x<width;x=x+sz[0]){
                background.blit(tile, [x, y]);             
        }
    }
    
    //render decals into background
    var position, angle;
    level.decals.forEach(function(decal){
        angle=math.normaliseDegrees(decal.a);
        background.blit(cache.getDecalSprite(level.dict[decal['f']], angle), decal.p)
    }, this);

    if(render_props ||(render_props==undefined)){
        //RENDER PROPS INTO BACKGROUND
        level.props.forEach(function(prop){
            angle=math.normaliseDegrees(prop.a);
            background.blit(cache.getPropSprite(level.dict[prop['f']], angle), prop.p)
        }, this);
    }
    
    return background;
};

exports.interpolatePoints=function(pt1, pt2, q){
    return [pt1[0]+(pt2[0]>pt1[0]? 1 : -1)*Math.abs(pt2[0]-pt1[0])*q,
            pt1[1]+(pt2[1]>pt1[1]? 1 : -1)*Math.abs(pt2[1]-pt1[1])*q];
};

exports.interpolateInts=function(a1, a2, q){
    return a1+(a2>a1? 1: -1)*Math.abs(a2-a1)*q;
};

var copy=exports.copy=function(src, dest){
    for(var attr in src) dest[attr]=src[attr];
    return dest;
};

var vec=exports.vec=function(){
    if(!(arguments.length && arguments[0].hasOwnProperty('x'))){
        if(arguments.length==1) return new box2d.b2Vec2(arguments[0][0], arguments[0][1]);
        else if(arguments.length==2) return new box2d.b2Vec2(arguments[0], arguments[1]);
        else throw "kablooie"
    }else return arguments[0];
};

var vectorToList=exports.vectorToList=exports.arr=function(vect){
    if(vect.hasOwnProperty('x')) return [vect.x, vect.y];
    return vect;
};

exports.removeObjFromList=function(val, list){
    for(var i=0; i<list.length; i++) {
        if(list[i] == val) {
            list.splice(i, 1);
            break;
        }
    }
};

exports.resizeSurfaceToHeight=function(surface, height){
    var sz=surface.getSize();
    var q=sz[1]/height
    var new_sz=[parseInt(sz[0]/q), parseInt(sz[1]/q)];
    var s=new gamejs.Surface(new_sz[0], new_sz[1]);
    s.blit(surface, new gamejs.Rect([0, 0], s.getSize()), new gamejs.Rect([0, 0], surface.getSize()));
    return s;
};

exports.inArray=function(haystack, needle){
    for(var i=0;i<haystack.length;i++){
        if(haystack[i]==needle) return true;
    }
    return false;
};

exports.supports_html5_storage=function() {
  try {
    return 'localStorage' in window && window['localStorage'] !== null;
  } catch (e) {
    return false;
  }
}

exports.push = function(obj, obj_from, force_multiplier, debuff_duration){
    if(obj.has_tag('car') && debuff_duration)
        obj.world.create(buffs.SlipDebuff, {'duration':debuff_duration,
                                             'object':obj});
    var fvect = vectors.unit(vectors.subtract(obj.get_position(), obj_from.get_position()));
    fvect = vectors.multiply(fvect, obj.get_mass()*force_multiplier);
    obj.apply_impulse(fvect, obj.get_position());
}

}}, ["gamejs", "engine", "buffs", "settings", "renderer"]);/* This file has been generated by yabbler.js */
require.define({
"bots": function(require, exports, module) {
var names=exports.names=['Bob', 'The Dominator', 'Desert Penguin', 'Smiley'];
var car_descriptions=require('./car_descriptions');
exports.generateBotCarDescr=function(){
    var cartypes=[];
    for(var key in car_descriptions) cartypes.push(key);
    var ct=cartypes[Math.floor(Math.random()*(cartypes.length))];
    var weapons=['Machinegun', 'MissileLauncher'];
    var wp=weapons[Math.floor(Math.random()*(weapons.length))];
    var retv={'type':ct,
                'front_weapon':{'type':wp,
                                'ammo_upgrades':0,
                                'damage_upgrades':0},
                'util':null,
                'rear_weapon':null,
                'acc_upgrades':0,
                'speed_upgrades':0,
                'armor_upgrades':0};
    
    return retv;
};

//LEAGUE 1

exports.CatLady={'type':'Sandbug',
                    'name':'Cat Lady',
                    'front_weapon':{'type':'Machinegun',
                                    'ammo_upgrades':0,
                                    'damage_upgrades':0},
                    'util':null,
                    'rear_weapon':{'type':'MineLauncher',
                                    'ammo_upgrades':0,
                                    'damage_upgrades':0},
                    'acc_upgrades':0,
                    'speed_upgrades':0,
                    'armor_upgrades':0};
                    
                    
exports.Bob={'type':'Hillbilly',
                    'name':'Bob',
                    'front_weapon':{'type':'MissileLauncher',
                                    'ammo_upgrades':1,
                                    'damage_upgrades':1},
                    'util':null,
                    'rear_weapon':null,
                    'acc_upgrades':2,
                    'speed_upgrades':0,
                    'armor_upgrades':0};
                    
                    
exports.Dominator={'type':'Sandbug',
                      'name':'The Dominator',
                      'front_weapon':{'type':'Machinegun',
                                    'ammo_upgrades':3,
                                    'damage_upgrades':0},
                    'util':null,
                    'rear_weapon':null,
                    'acc_upgrades':0,
                    'speed_upgrades':0,
                    'armor_upgrades':2};
                    
//LEAGUE 2             
exports.HotShot={'type':'Racer',
                    'name':'HotShot',
                    'front_weapon':{'type':'Machinegun',
                                    'ammo_upgrades':5,
                                    'damage_upgrades':3},
                    'util':{'type':'Shockwave',
                                    'ammo_upgrades':0,
                                    'damage_upgrades':0},
                    'rear_weapon':null,
                    'acc_upgrades':0,
                    'speed_upgrades':0,
                    'armor_upgrades':0};
                    
                    
exports.TheDude={'type':'Hillbilly',
                    'name':'The Dude',
                    'front_weapon':{'type':'HomingMissiles',
                                    'ammo_upgrades':1,
                                    'damage_upgrades':1},
                    'util':null,
                    'rear_weapon':{'type':'Oil',
                                    'ammo_upgrades':1,
                                    'damage_upgrades':1},
                    'acc_upgrades':2,
                    'speed_upgrades':2,
                    'armor_upgrades':0};
                    
                    
exports.Ratman={'type':'Bandit',
                      'name':'Ratman',
                      'front_weapon':{'type':'PlasmaCannon',
                                    'ammo_upgrades':2,
                                    'damage_upgrades':0},
                    'util':{'type':'RepairKit',
                                    'ammo_upgrades':2,
                                    'damage_upgrades':0},
                    'rear_weapon':null,
                    'acc_upgrades':0,
                    'speed_upgrades':2,
                    'armor_upgrades':2};
                    

//league three

exports.Bulldog = {'type':'Brawler',
				   'name':'Brawler',
				   'front_weapon':{'type':'MissileLauncher',
				   				   'ammo_upgrades':4,
				   				   'damage_upgrades':3},
				   'util':{'type':'NOS',
				   		   'ammo_upgrades':1,
				   		   'damage_upgrades':0},
				   	'rear_weapon':{'type':'Oil',
                                    'ammo_upgrades':1,
                                    'damage_upgrades':1},
				   	'acc_upgrades':2,
				   	'speed_upgrades':1,
				   	'armor_upgrades':2};
				   	
exports.JC={'type':'Bandit',
              'name':'JC',
              'front_weapon':{'type':'Machinegun',
                                'ammo_upgrades':2,
                                'damage_upgrades':3},
	           'util':{'type':'Shield',
	                    'ammo_upgrades':0,
	                    'damage_upgrades':0},
	           'rear_weapon':{'type':'Napalm',
	                          'ammo_upgrades':2,
	                          'damage_upgrades':1},
	           'acc_upgrades':0,
	           'speed_upgrades':3,
	           'armor_upgrades':1};
	           
exports.PainKid={'type':'Racer',
	                'name':'Pain Kid',
	                'front_weapon':{'type':'Machinegun',
	                                'ammo_upgrades':5,
	                                'damage_upgrades':3},
	                'util':{'type':'Shockwave',
	                                'ammo_upgrades':1,
	                                'damage_upgrades':0},
	                'rear_weapon':{'type':'MineLauncher',
	                                'ammo_upgrades':2,
	                                'damage_upgrades':4},
	                'acc_upgrades':0,
	                'speed_upgrades':2,
	                'armor_upgrades':2};
                    	           
                    
				   	
				

}}, ["car_descriptions"]);/* This file has been generated by yabbler.js */
require.define({
"skin": function(require, exports, module) {
exports.ui_header_background='#FFF';
exports.ui_background='#E6E6E6';

exports.alias_background='#333333';

exports.alert_box_border='black';
exports.alert_box_background='#E6E6E6';

//fonts name:[css description, color]
/*
exports.fonts={'hud':['30px "Showcard Gothic"', 'red'],         //in game hud
               'header':['40px Aharoni', '#351A15'],            //ui scene headers
               'default':['20px Aharoni', '#351A15'],           //labels, default if not specified
               'small_header':['bold 16px Arial', 'black'],     //table headers
               'small':['bold 14px Arial', 'black'],             //table cells
               'alias':['bold 14px Arial', '#4CFF00'],  //ingame multiplayer player alias
               'button':['20px Aharoni', '#351A15'],
               'loading':['40px Stencil', '#351A15']
               };
*/

exports.fonts={'hud':['30px maass', 'red'],         //in game hud
               'header':['40px maass', '#351A15'],            //ui scene headers
               'default':['20px maass', '#351A15'],           //labels, default if not specified
               'small_header':['16px maass', 'white'],     //table headers
               'small':['14px maass', 'black'],             //table cells
               'alias':['23px maass', '#333333'],  //ingame multiplayer player alias
               '16_33':['16px maass', '#333333'],
               '13_1a':['13px maass', '#1A1A1A'],
               '13_green':['13px maass', '#00BC12'],
               'alias_label':['40px maass', '#FFFFFF'],
               'button':['25px maass', '#000'],
               'button2':['30px maass', '#333333'],
               'button2_hover':['30px maass', '#F2F2F2'],
               'loading':['40px maass', '#351A15'],
               '40_black':['40px maass', '#000'],
               '13_grayish':['13px maass', '#383736'],
               '25_66':['25px maass', '#666666'],
               'sp_btn':['30px maass', '#FFF'],
               'header_black':['56px maass', '#333333'],
               'header_brown':['56px maass', '#A67C52'],
               'editor_ai_wp':['19px maass', '#0094FF'],
               'editor_checkpoint':['19px maass', '#FF5656'],
               'editor_start_pos':['19px maass', '#3AFF51'],
               'g_white_title':['16px maass', '#F2F2F2']
               };


exports.single_player_scene={'background_color':'#C7B299'};

exports.dialog={'font':'default'};

exports.sp_car_display={'bg_color':'#998675',
                        'font1':'13_grayish',
                        'font2':'sp_btn'};

exports.garage_btn={'bg_color':'#CCCCCC',
                    'bg_color_hover':'#B3B3B3',
                    'label_bg':'#E6E6E6',
                    'font':'alias'};
                    
exports.track_selector={'back_color':'#E6E6E6',
                        'front_color':'#CCCCCC',
                        'item_hover_color':'#D8D8D8',
                        'item_font':'16_33'};

exports.title_button={'fill':'#CCCCCC',
                      'fill_hover':'#B3B3B3',
                      'font':'40_black'};

exports.sp_button={'fill':'#333333',
                    'fill_hover':'#000',
                    'font':'sp_btn'};
                      
exports.button={'border':'#282828',              //button border
                'font':'button',                 //default font
                'fill':'#CCCCCC',                 //default fill
                'hover_fill':'#B3B3B3',          //fill on hover
                'selected_fill':'#FF6A00'};       //fill when selected
                
exports.garage={'background_color':'#666666',
                'back_button':{'fill':'#E6E6E6',
                                'hover_fill':'#000',
                                'font':'button2',
                                'hover_font':'button2_hover'},
                'balance_background':'#E6E6E6',
                'car_title_background':'#333333',
                'car_background':'#CCCCCC',
                'car_title_font':'g_white_title',
                'balance_font':'alias',
                'weapon_info_title_background':'#F5F5F5',
                'weapon_info_background':'#B3B3B3',
                'weapon_label_font':'16_33',
                'weapon_info_text_font':'13_1a',
                'tuning_title_background':'#4D4D4D',
                'tuning_background':'#1A1A1A',
                'store_background':'#F2F2F2',
                'store_border':'#CCCCCC',
                'selected_shop_item_bg':'#B3B3B3',
                'slot_border':'rgba(204, 204, 204, 0.5)',
                'slot_bg':'rgba(204, 204, 204, 0.8)',
                'slot_bg_selected':'#777777',
                'slot_path':'#CCCCCC',
                'white_button':{'bg':'#F2F2F2',
                                'bg_hover':'#1A1A1A',
                                'font':'16_33',
                                'hover_font':'g_white_title'}};
                

exports.trackdisplay={'font':'16_33'};

//label
exports.label={'font':'default'};

//textbox
exports.textbox={'font':'default',
                 'border':'#282828',
                 'background':'#FFEFAA'};


//table
exports.table={'header_font':'small_header',
                'data_font':'small',
                'border':'#C6A500',
                'header_fill':'#333333',         //header row background
                'hover_fill':'#FFBE00',          //fill on row hover
                'body_fill':'#CCCCCC',
                'selected_fill':'#FF6A00'};           //my english fails me. its the line between rows

//track info display
exports.trackinfodisplay={'header_font':'default',
                          'outline_color':'#808080'};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"car_descriptions": function(require, exports, module) {
/*car:
 
    width             - width in meters
    height            - height in meters
    filenames          - sprite file name
    power             -engine power in newtons
    max_steer_angle   -max steering angle, degrees
    max_speed         -max speed, km/h
    wheels      -front wheel definitions: [[-1, -1.2], [1, -1.2]] 
    weapon1           -first weapon
    weapon2           -second weapon
    health            -max health
*/

/*
  wheel:
  x
  y
  revolving
  powered
*/

/*
 this.player_car=new cars.Car({'width':2,
                                    'height':4,
                                    'filename':'yellow_car.png',
                                    'world':this.world,
                                    'position':[car_positions[1].x+1, car_positions[1].y+2],
                                    'angle':car_positions[1].angle,
                                    'power':90,
                                    'max_steer_angle':20,
                                    'max_speed':150,
                                    'front_wheels':[[-1, -1.2], [1, -1.2]],
                                    'back_wheels':[[-1, 1.1], [1, 1.2]],
                                    'weapon1':new weapons.Machinegun({}),
                                    'weapon2':new weapons.MineLauncher({}),
                                    'health':100});
 
*/


exports.Bandit={'width':1.7,
                'height':3.5,
                'id':'Bandit',
                'name':'Bandit',
                'description':'Small but agile',
                'filenames':['bandit_yellow.png', 'bandit_green.png', 'bandit_blue.png', 'bandit_red.png'],
                'art_filename':'bandit_big.png',
                'power':105,
                'max_speed':110,
                'max_steer_angle':17,
                'health':80,
                
                'power_upgrade':6,
                'speed_upgrade':4,
                'armor_upgrade':20,
                'upgrade_price':600,
                
                'speed_stars':1,
                'acceleration_stars':4,
                'armor_stars':1,
                'handling_stars':4,
                
                'price':3000,
                
                'main_weapon':'Machinegun',
                'wheels':[{'x':-0.85, 'y':-1, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':0.85, 'y':-1, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':-0.85, 'y':1.1, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'},
                          {'x':0.85, 'y':1.1, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'}]
                };
                
exports.Sandbug={'id':'Sandbug',
                'width':1.8,
                'height':4,
                'name':'Sandbug',
                'description':'A basic, low budget car',
                'filenames':['sandbug_yellow.png', 'sandbug_green.png', 'sandbug_blue.png', 'sandbug_red.png'],
               'art_filename':'sandbug_big.png',
               'power':75,
               'max_steer_angle':15,
               'max_speed':100,
               'health':100,
               
               'power_upgrade':7,
               'speed_upgrade':4,
               'armor_upgrade':20,
               'upgrade_price':300,
               
               'speed_stars':1,
               'acceleration_stars':1,
               'armor_stars':2,
               'handling_stars':2,
               
               'price':1000,
               'wheels':[{'x':-0.9, 'y':-1.2, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':0.9, 'y':-1.2, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':-0.9, 'y':1.2, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'},
                          {'x':0.9, 'y':1.2, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'}]
                };
               
exports.Thunderbolt = {'width':2.1,
                       'height':4.5,
                       'id':'Thunderbolt',
                       'name':'Thunderbolt',
                       'description':'A powerful muscle car',
                       'filenames':['thunderbolt_yellow.png', 'thunderbolt_green.png', 'thunderbolt_blue.png', 'thunderbolt_red.png'],
                       'art_filename':'thunderbolt_big.png',
                       'power':140,
                       'max_steer_angle':13,
                       'max_speed':135,
                       'health':140,
                       
                       'power_upgrade':9,
                       'speed_upgrade':5,
                       'armor_upgrade':25,
                       'upgrade_price':1200,
                       
                       'speed_stars':4,
                       'acceleration_stars':4,
                       'armor_stars':3,
                       'handling_stars':1,
                       
                       'price':7000,
                       
                       'wheels':[{'x':-1, 'y':-1.4, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
		                          {'x':1, 'y':-1.4, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
		                          {'x':-1, 'y':1.4, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'},
		                          {'x':1, 'y':1.4, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'}]
                       
                       }  ;             
                
                
exports.Racer={'width':2,
                'id':'Racer',
                'name':'Racer',
                'description':'A well rounded racing car',
               'height':4,
               'filenames':['racer_yellow.png', 'racer_green.png', 'racer_blue.png', 'racer_red.png'],
               'art_filename':'racer_big.png',
                'power':90,
                'max_steer_angle':16,
                'max_speed':125,
                'health':100,
                
                'power_upgrade':7,
                'speed_upgrade':4,
                'armor_upgrade':20,
                'upgrade_price':600,
                
                'speed_stars':3,
                'acceleration_stars':2,
                'armor_stars':2,
                'handling_stars':3,
                
                'price':4500,
                
                'wheels':[{'x':-0.9, 'y':-1.2, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':0.9, 'y':-1.2, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':-0.9, 'y':1.2, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'},
                          {'x':0.9, 'y':1.2, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'}]
                
            };
            
exports.Hillbilly={'width':2.4,
                'height':5,
                'id':'Hillbilly',
                'name':'Hillbilly',
                'description':'Sturdy, lots of space in the back',
                'filenames':['samaritan_yellow.png', 'samaritan_green.png', 'samaritan_blue.png', 'samaritan_red.png'],
                'art_filename':'samaritan_big.png',
                'power':120,
                'max_steer_angle':16,
                'max_speed':115,
                'health':140,
                
                'power_upgrade':10,
                'speed_upgrade':4,
                'armor_upgrade':25,
                'upgrade_price':600,
                
                'speed_stars':2,
                'armor_stars':3,
                'acceleration_stars':1,
                'handling_stars':2,
                
                'price':4000,
                
                'wheels':[{'x':-1, 'y':-1.7, 'width':0.6, 'length':1.2, 'revolving':true, 'powered':true, 'filename':'big_wheel.png'},
                          {'x':1, 'y':-1.7, 'width':0.6, 'length':1.2, 'revolving':true, 'powered':true, 'filename':'big_wheel.png'},
                          {'x':-0.9, 'y':1.6, 'width':0.6, 'length':1.2, 'revolving':false, 'powered':false, 'filename':'big_wheel.png'},
                          {'x':0.9, 'y':1.6, 'width':0.6, 'length':1.2, 'revolving':false, 'powered':false, 'filename':'big_wheel.png'}]
                };
            
            
exports.Brawler={'width':3,
                'height':6,
                'id':'Brawler',
                'name':'Brawler',
                'description':'Heavily armored combat SUV',
                'filenames':['brawler_yellow.png', 'brawler_green.png', 'brawler_blue.png', 'brawler_red.png'],
                'art_filename':'brawler_big.png',
                'power':150,
                'max_steer_angle':16,
                'max_speed':120,
                'health':180,
                
                'power_upgrade':12,
                'speed_upgrade':4,
                'armor_upgrade':30,
                'upgrade_price':600,
                
                'speed_stars':3,
                'armor_stars':4,
                'acceleration_stars':1,
                'handling_stars':1,
                
                'price':6000,
                
                'main_weapon':'MissileLauncher',
                'wheels':[{'x':-1.25, 'y':-2, 'width':0.6, 'length':1.2, 'revolving':true, 'powered':true, 'filename':'big_wheel.png'},
                          {'x':1.25, 'y':-2, 'width':0.6, 'length':1.2, 'revolving':true, 'powered':true, 'filename':'big_wheel.png'},
                          {'x':-1.25, 'y':2.1, 'width':0.6, 'length':1.2, 'revolving':false, 'powered':false, 'filename':'big_wheel.png'},
                          {'x':1.25, 'y':2.1, 'width':0.6, 'length':1.2, 'revolving':false, 'powered':false, 'filename':'big_wheel.png'}]
                };
}}, []);/* This file has been generated by yabbler.js */
require.define({
"props": function(require, exports, module) {
var gamejs=require('gamejs');
var utils=require('./utils');
var vec=utils.vec;
var arr=utils.arr;
var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
var engine = require('./engine');

exports.rotarrays={};

var BoxProp = exports.BoxProp = function(parameters){
    /*
     pars:
     filename
     size
     world
     position
     angle
    */
    
    var par_list = ['filename'];
    
    engine.utils.process_parameters(parameters, par_list);
    
    this.filename = parameters.filename;
    
    parameters.fixed_rotation = true;
    parameters.body_type = engine.box2d.b2Body.b2_staticBody;
    BoxProp.superConstructor.apply(this, [parameters]);
    this.add_tag('prop');
};

gamejs.utils.objects.extend(BoxProp, engine.Entity);

engine.register_class(BoxProp);

}}, ["gamejs", "utils", "engine"]);/* This file has been generated by yabbler.js */
require.define({
"ui": function(require, exports, module) {
var gamejs=require('gamejs');
var GUI=require('./gamejs-gui');
var skin=require('./skin');
var renderer=require('./renderer');
var settings=require('./settings');
var combatracer=require('./combatracer');
var car_descriptions=require('./car_descriptions');
var weapon_descriptions=require('./weapon_descriptions');
var levels=require('./levels');
var utils=require('./utils');
var sounds=require('./sounds');
var leagues=require('./leagues');

exports.fonts={};

exports.init=function(){
    for(var font in skin.fonts){
        exports.fonts[font]=new GUI.CachedFont(skin.fonts[font][0], skin.fonts[font][1]);   
    }
};

var getFont=exports.getFont=function(font){
    return exports.fonts[font];
};

//SCENE CONTAINER
var SceneContainer=function(pars){
    this.background_color=pars.background_color || skin.ui_background;
    this.header_height=pars.header_height || 110;
    SceneContainer.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(SceneContainer, GUI.View);

SceneContainer.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.rect(this.surface, skin.ui_header_background, new gamejs.Rect([0, 0], [this.surface.getSize()[0], this.header_height]));
    gamejs.draw.rect(this.surface, this.background_color, new gamejs.Rect([0, this.header_height], [this.surface.getSize()[0], this.surface.getSize()[1]-this.header_height]));
};



var UIScene=exports.UIScene=function(){
    var cache=this.cache=cache=renderer.cache;
    var game=this.game=combatracer.game;
   // game.display.fill('#FFF');
    this.gui=new GUI.GUI(game.display);
    this.gui.on(GUI.EVT_PAINT,
                function(){
                    this.surface.clear();
                }, this.gui);
    this.container=new SceneContainer({'position':[0, 0],
                                        'size':[800, 600],
                                        'parent':this.gui});
    
    this.gui.center(this.container);

    //bandit racer label at the top
    this.br_title=new BRTitle({'position':[60, 11],
                              'parent':this.container});
    
    this.guncar=new GUI.Image({'position':[32, 110-44],
                              'parent':this.container,
                              'image':cache.getUIImage('guncar.png')});

    //if ping is set to true, this scene will ping the server every ms_to_ping miliseconds so as not to time out.
    this.ping=false;
    this.ms_to_ping=10000;

    this.dialog=new Dialog({'parent':this.gui,
                           'size':[600, 150]});

    this.alert=function(text, button){
        this.dialog.show(text, button);
    };
    
    this.clearAlert=function(){
        this.dialog.close();
    };
    
    this.handleEvent=function(event){
        this.gui.despatchEvent(event);  
    };

    this.returnToTitle=function(){
        this.game.showTitle();
    };
    this.handleMessageDefault=function(cmd, payload){
        if(cmd==='ERR'){
            this.alert(payload.text);
        }else if(cmd==='CRITICAL_ERR'){
            this.returnToTitle();
            this.game.title_scene.alert(payload.text);
        }else if(cmd==='HELLO' || cmd==='PONG'){

        }else{
            this.alert('Unknown server message:'+cmd);
        }

    };
    this.renderer=new renderer.UIRenderer(settings.get('SCREEN_WIDTH'), settings.get('SCREEN_HEIGHT'), this.cache);

  
    this.update=function(msDuration){
        if(this.ping){
            this.ms_to_ping-=msDuration;
            if(this.ms_to_ping<=0){
                this.game.getCommunicator().queueMessage('PING');
                this.ms_to_ping=10000;
            }
        }
        this.gui.update(msDuration);
    };
  
    this.draw=function(display){  
        this.gui.draw();
    };

  return this;
};

UIScene.prototype.handleMessage=function(cmd, payload){
    console.log('uiscene',cmd, payload);
    this.handleMessageDefault(cmd, payload);
};

var BRTitle=exports.BRTitle=function(pars){
    pars.text='Bandit Racer';
    pars.font=getFont('header_black');
    BRTitle.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(BRTitle, GUI.Label);

BRTitle.prototype.paint=function(){
    var font1=getFont('header_brown');
    var font2=getFont('header_black');
    var ofst=0;
    font2.render(this.surface, 'B', [0, 0], null, -3);
    ofst+=font2.getTextSize('B')[0]-3;
    
    font1.render(this.surface, 'andit ', [ofst, 0], null, -3);
    ofst+=font1.getTextSize('andit ')[0]-3;
    
    font2.render(this.surface, 'R', [ofst, 0], null, -3);
    ofst+=font2.getTextSize('R')[0]-3;
    
    font1.render(this.surface, 'acer', [ofst, 0], null, -3);
};

var NameInput=exports.NameInput=function(pars){
    pars.size=[200, 40];
    pars.font=getFont('alias');
    pars.scw_size=[190, 40];
    NameInput.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(NameInput, GUI.TextInput)

NameInput.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.polygon(this.surface, '#FFF', [[10, 0], [this.size[0], 0], [this.size[0]-10, this.size[1]], [0, this.size[1]]]);
};

var TitleButton=exports.TitleButton=function(pars){
    pars.font=pars.font || getFont(skin.title_button.font);
    TitleButton.superConstructor.apply(this, [pars]);
    this.onClick(function(){
        sounds.play({'filename':'button_click.wav'});
    });
};

gamejs.utils.objects.extend(TitleButton, GUI.Button);

TitleButton.prototype.paint=function(){
    var color = this.isHovered() ? skin.title_button.fill_hover : skin.title_button.fill;
    this.surface.clear();
    gamejs.draw.polygon(this.surface, color, [[40, 0], [this.size[0], 0], [this.size[0], this.size[1]], [0, this.size[1]]]);
};

var Button=exports.Button=function(pars){
    this.font=pars.font=pars.font || getFont(skin.button.font);
    this.hover_font=pars.hover_font;
    this.fill=pars.fill || skin.button.fill;
    this.hover_fill = pars.hover_fill || skin.button.hover_fill;
    this.lean = pars.lean || 'right';
    Button.superConstructor.apply(this, [pars]);
    this.onClick(function(){
        sounds.play({'filename':'button_click.wav'});
    });
};

gamejs.utils.objects.extend(Button, GUI.Button);

Button.prototype.paint=function(){
    if(this.label && this.isHovered() && this.hover_font){
        this.label.font=this.hover_font;
    }else{
        this.label.font=this.font;
    }
    this.label.refresh();
    var color = this.isHovered() ? this.hover_fill : this.fill;
    this.surface.clear();
    if(this.lean=='right') gamejs.draw.polygon(this.surface, color, [[10, 0], [this.size[0], 0], [this.size[0], this.size[1]], [0, this.size[1]]]);
    else if(this.lean=='both') gamejs.draw.polygon(this.surface, color, [[10, 0], [this.size[0], 0], [this.size[0]-10, this.size[1]], [0, this.size[1]]]);
    else if(this.lean=='none') gamejs.draw.rect(this.surface, color, new gamejs.Rect([0,0], this.getSize()));
    else gamejs.draw.polygon(this.surface, color, [[0, 0], [this.size[0]-10, 0], [this.size[0], this.size[1]], [0, this.size[1]]]);
};

var YesNoDialog=exports.YesNoDialog=function(pars){
    YesNoDialog.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'position':[0, 0],
                             'parent':this,
                             'font':getFont(skin.dialog.font),
                             'text':pars.text || 'b'});
    
    this.yes= new Button({'position':[0, 0],
                         'size':[150, 50],
                         'parent':this,
                         'lean':'both',
                         'text':'Yes'});
    this.no=new Button({'position':[0, 0],
                         'size':[150, 50],
                         'parent':this,
                         'lean':'both',
                         'text':'No'});
    
    this.center(this.yes);
    this.center(this.no);
    this.center(this.label);
    this.label.move([this.label.getPosition()[0], this.label.getPosition()[1]-30]);
    this.yes.move([this.yes.position[0]-80, this.yes.position[1]+30]);
    this.no.move([this.no.position[0]+80, this.no.position[1]+30]);
    this.yes.onClick(function(){
        this.close();
    }, this);
    this.no.onClick(function(){
        this.close();
    }, this);
}
gamejs.utils.objects.extend(YesNoDialog, GUI.Dialog);

var Dialog=exports.Dialog = function(pars){
    Dialog.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'position':[0, 0],
                             'parent':this,
                             'font':getFont(skin.dialog.font),
                             'text':'b'});
    
    this.btn= new Button({'position':[0, 0],
                         'size':[150, 50],
                         'parent':this,
                         'lean':'both',
                         'text':'Ok'});
    this.center(this.btn);
    this.btn.move([this.btn.position[0], this.btn.position[1]+30]);
    this.btn.onClick(function(){
        this.close();
    }, this);
};

gamejs.utils.objects.extend(Dialog, GUI.Dialog);

Dialog.prototype.show=function(text, button){
    if(button==undefined) button=true;
    this.label.setText(text);
    this.center(this.label);
    this.label.move([this.label.position[0], this.label.position[1]-30]);
    if(button){
        this.btn.show();
    }else this.btn.hide();
    GUI.Dialog.prototype.show.apply(this, []);
};

var GoToGarage=exports.GoToGarage=function(pars){
    pars.size=[210, 180];
    GoToGarage.superConstructor.apply(this, [pars]);

    this.img= new GUI.Image({'position':[0, 0],
                            'parent':this,
                            'image':renderer.cache.getUIImage('garage.png')});
    this.center(this.img);
    this.img.move([this.img.position[0], 7]);
    
    this.lbl=new GUI.Label({'position':[0, 0],
                          'parent':this,
                          'font':getFont(skin.garage_btn.font),
                          'text':'Garage'});
    this.center(this.lbl);
    this.lbl.move([this.lbl.position[0], this.size[1]-this.lbl.size[1]-17]);    
};

gamejs.utils.objects.extend(GoToGarage, GUI.View);

GoToGarage.prototype.paint=function(){
    this.surface.fill(skin.garage_btn.label_bg);
    gamejs.draw.rect(this.surface, this.isHovered() ? skin.garage_btn.bg_color_hover : skin.garage_btn.bg_color, new gamejs.Rect([0, 0], [this.size[0], 126]));
};

var DifficultySelect=exports.DifficultySelect=function(pars){
    DifficultySelect.superConstructor.apply(this, [pars]);
    
    this.difficulties=['Easy', 'Medium', 'Hard'];
    
    if (combatracer.game.player.singleplayer.completed) 
    	this.difficulties.push('Hell');
    
    new GUI.Label({'parent':this,
                  'position':[10, 6],
                  'font':getFont(skin.sp_car_display.font1),
                  'text':'Difficulty:'});
    
    this.difflbl=new GUI.Label({'parent':this,
                                'position':[27, 17],
                                'font':getFont(skin.sp_car_display.font2),
                                 'text':this.difficulties[combatracer.game.player.singleplayer.difficulty-1]});
    
    this.left=new IncrementButton({'parent':this,
                                   'position':[5, 28],
                                   'size':[16, 25],
                                   'direction':'left'});
    
    this.left.onClick(function(){
        combatracer.game.player.singleplayer.difficulty--;
        if(combatracer.game.player.singleplayer.difficulty==0) combatracer.game.player.singleplayer.difficulty = this.difficulties.length;
        this.difflbl.setText(this.difficulties[combatracer.game.player.singleplayer.difficulty-1]);
    }, this);
    
    this.right=new IncrementButton({'parent':this,
                                   'position':[210-20-5, 28],
                                   'size':[16, 25],
                                   'direction':'right'});
    
    this.right.onClick(function(){
        combatracer.game.player.singleplayer.difficulty++;
        if(combatracer.game.player.singleplayer.difficulty == this.difficulties.length+1) combatracer.game.player.singleplayer.difficulty=1;
        this.difflbl.setText(this.difficulties[combatracer.game.player.singleplayer.difficulty-1]);
    }, this);
    
};
gamejs.utils.objects.extend(DifficultySelect, GUI.View);

DifficultySelect.prototype.paint=function(){
    gamejs.draw.polygon(this.surface, skin.sp_car_display.bg_color,
                        [[0, 0], [this.size[0]-20, 0], [this.size[0], 20],
                         [this.size[0], this.size[1]], [0, this.size[1]]]);
};


var CarDisplay=exports.CarDisplay=function(pars){
    pars.size=[210, 65];
    CarDisplay.superConstructor.apply(this, [pars]);
    this.gameinfo=pars.gameinfo;
    
    new GUI.Label({'parent':this,
                  'position':[10, 6],
                  'font':getFont(skin.sp_car_display.font1),
                  'text':'Current Car:'});
    
    this.carlbl=new GUI.Label({'parent':this,
                              'position':[16, 17],
                              'font':getFont(skin.sp_car_display.font2),
                              'text':car_descriptions[this.gameinfo.car.type].name});
    
};
gamejs.utils.objects.extend(CarDisplay, GUI.View);

CarDisplay.prototype.paint=function(){
    gamejs.draw.polygon(this.surface, skin.sp_car_display.bg_color,
                        [[0, 0], [this.size[0], 0], [this.size[0], this.size[1]-20],
                         [this.size[0]-20, this.size[1]], [0, this.size[1]]]);
};

TrackSelectorItem=exports.TrackSelectorItem=function(pars){
    pars.size=[pars.parent.size[0], 22];
    this.track=pars.track;
    this.track_obj=levels[this.track];
    TrackSelectorItem.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'position':[0, 0],
                             'parent':this,
                             'font':getFont(skin.track_selector.item_font),
                             'text':this.track_obj.title});
    this.center(this.label);
    this.label.move([this.size[0]-this.label.size[0]-16, this.label.position[1]]);
    this.selected=false;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
};

gamejs.utils.objects.extend(TrackSelectorItem, GUI.View);

TrackSelectorItem.prototype.select=function(){
    this.selected=true;
    this.refresh();
    sounds.play({'filename':'button_click.wav'});
    this.despatchEvent({'type':'track_select', 'track':this.track});
};

TrackSelectorItem.prototype.deselect=function(){
    this.selected=false;
    this.refresh();
};

TrackSelectorItem.prototype.paint=function(){
    this.surface.fill(this.selected ? skin.track_selector.front_color : this.isHovered() ? skin.track_selector.item_hover_color : skin.track_selector.back_color);
};

TrackSelector=exports.TrackSelector=function(pars){
    pars.size=[536, 320];
    TrackSelector.superConstructor.apply(this, [pars]);
    this.track=null;
    
    if(pars.tracks.length <= 7){
        this.tbg1=new GUI.View({'position':[0, 30],
                               'size':[226, 231],
                               'parent':this});
    } else {
        this.tbg1 = new GUI.ScrollableView({'position':[0, 30],
                                           'size':[206, 201],
                                           'parent':this});
        var scrollbar=new GUI.VerticalScrollbar({'parent':this,
                                                'position':[this.tbg1.getSize()[0], 35],
                                                'size':[20, this.tbg1.getSize()[1]-10]});
        this.tbg1.setVerticalScrollbar(scrollbar);
    }
                           
                           
                           
    this.tbg1.on(GUI.EVT_PAINT, function(){
        gamejs.draw.polygon(this.surface, skin.track_selector.back_color,
                        [[0, 0], [this.size[0], 0], [this.size[0], this.size[1]],
                         [20, this.size[1]], [0, this.size[1]-20]]);
    }, this.tbg1);
    
    this.tbg2=new GUI.View({'position':[226, 0],
                           'size':[310, 320],
                           'parent':this});
    this.tbg2.on(GUI.EVT_PAINT, function(){
        this.surface.fill(skin.track_selector.front_color);
    }, this.tbg2);
    
    this.trackdisplay=new TrackDisplay({'parent':this.tbg2,
                                       'position':[0, 0]});
    
    new GUI.Label({'parent':this,
                  'position':[10, 0],
                  'font':getFont('alias'),
                  'text':pars.label});
    
    pars.tracks.forEach(function(track){
        ti=new TrackSelectorItem({'parent':this.tbg1,
                                 'track':track.id,
                                 'position':[0, 0]});
        ti.on('track_select', this.select, this);
    }, this);
    
    GUI.layout.vertical(this.tbg1.children, 5);    
    
    if(this.tbg1.autoSetScrollableArea){
        this.tbg1.autoSetScrollableArea();
    }
    
};

gamejs.utils.objects.extend(TrackSelector, GUI.View);

TrackSelector.prototype.select=function(event){
    this.track=event.track;
    this.tbg1.children.forEach(function(item){
        if(item.deselect && (item.track!=this.track))item.deselect();
    }, this);
    this.trackdisplay.setTrack(this.track);
};

var TrackDisplay=exports.TrackDisplay=function(pars){
    this.track=null;
    this.img=null;
    this.lbl=null;
    pars.size=[316, 320];
    TrackDisplay.superConstructor.apply(this, [pars]);
    if(pars.track) this.setTrack(pars.track);
    this.lbl2=new GUI.Label({'parent':this,
                            'position':[0, 0],
                            'font':getFont(skin.trackdisplay.font),
                            'text':'Select a track!'});
    this.center(this.lbl2);
};

gamejs.utils.objects.extend(TrackDisplay, GUI.View);

TrackDisplay.prototype.setTrack=function(track){
    this.track=track;
    if(track){
        this.lbl2.hide();
        var st=utils.renderLevelBackground(levels[track], false);
        var sz=st.getSize();
        if(sz[0]>sz[1]){
            var q=sz[0]/280;
        }else{
            var q=sz[1]/280;
        }
        var new_sz=[parseInt(sz[0]/q), parseInt(sz[1]/q)];
        s=new gamejs.Surface(new_sz[0], new_sz[1]);
        s.blit(st, new gamejs.Rect([0, 0], new_sz), new gamejs.Rect([0, 0], st.getSize()));
        
        if(!this.img){
            this.img=new GUI.Image({'parent':this,
                                   'position':[15, 10],
                                   'image':s});
        }else{
            this.img.resize(s.getSize());
            this.img.setImage(s);
        }
        if(!this.lbl){
            this.lbl=new GUI.Label({'parent':this,
                                   'position':[0, 0],
                                   'text':levels[track].title,
                                   'font':getFont(skin.trackdisplay.font)});
        }else{
            this.lbl.setText(levels[track].title);
        }
        this.center(this.lbl);
        this.lbl.move([this.lbl.position[0], this.size[1]-this.lbl.size[1]-5]);
    }
};

/***
 *
 *pars:
     scene
     position
     columns  - list of column defs,
                column def is {'key':'item', 'label':'The Item', 'width':100}
     data - list of data: {id:row_id,
                           key:value,
                           key2:value,
                           ....}
    selectable - can rows be selected?*/

var Table=exports.Table=function(pars){
    Table.superConstructor.apply(this, [pars]);
    this.columns=pars.columns;
    this.data=pars.data;
    this.header=new GUI.View({'parent':this,
                             'size':[this.size[0], 30],
                             'position':[0, 0]});
    this.header.on(GUI.EVT_PAINT, function(){
        this.surface.fill(skin.table.header_fill);
    }, this.header);
    
    var ofst=0;
    this.columns.forEach(function(column){
        new GUI.Label({'parent':this.header,
                      'position':[ofst+20, 3],
                      'font':getFont(skin.table.header_font),
                      'text':column.label});
        ofst+=column.width;
    }, this);
    
    this.body=new GUI.View({'parent':this,
                             'size':[this.size[0], this.size[1]-30],
                             'position':[0, 30]});
    this.body.on(GUI.EVT_PAINT, function(){
        this.surface.fill(skin.table.body_fill);
    }, this.body);
    if(this.data) this.setData(this.data);
};

gamejs.utils.objects.extend(Table, GUI.View);

Table.prototype.setData=function(data, empty_label){
    this.body.children=[];
    var row_ofst=0, col_ofst;
    if (data.length){
        data.forEach(function(row){
            col_ofst=0;
            var view=new GUI.View({'parent':this.body,
                                  'size':[this.size[0], 30],
                                  'position':[0, row_ofst]});
            this.columns.forEach(function(column){
                new GUI.Label({'parent':view,
                            'position':[col_ofst+20, 3],
                            'font':getFont(skin.table.header_font),
                            'text':String(row[column.key]),
                            'font':getFont(skin.table.data_font)});
                col_ofst+=column.width;
            }, this);
            row_ofst+=30;
        }, this);
    } else if(empty_label){
        new GUI.Label({'parent':this.body,
                        'position':[20, 3],
                        'font':getFont(skin.table.header_font),
                        'text':String(empty_label),
                        'font':getFont(skin.table.data_font)});
    }
};


var IncrementButton=exports.IncrementButton=function(pars){
    var image=new gamejs.Surface(pars.size);
    var image_hover=new gamejs.Surface(pars.size);
    if(pars.direction=='up'){
        var ptlist=[[parseInt(pars.size[0]/2), 0], pars.size, [0, pars.size[1]]];    
    }
    else if(pars.direction=='down'){
        var ptlist=[[0, 0], [pars.size[0], 0],[parseInt(pars.size[0]/2), pars.size[1]]];
    }
    else if(pars.direction=='left'){
        var ptlist=[[0, parseInt(pars.size[1]/2)], [pars.size[0], 0], pars.size];
    }else{
        var ptlist=[[0, 0], [pars.size[0], parseInt(pars.size[1]/2)], [0, pars.size[1]]];
    }
    
    gamejs.draw.polygon(image, skin.title_button.fill, ptlist);
    gamejs.draw.polygon(image_hover, skin.title_button.fill_hover, ptlist);
    
    pars.image=image;
    pars.image_hover=image_hover;
    pars.image_down=false;
    IncrementButton.superConstructor.apply(this, [pars]);
    this.onClick(function(){
        sounds.play({'filename':'button_click.wav'});
    });
};
gamejs.utils.objects.extend(IncrementButton, GUI.Button);


var Stars=exports.Stars=function(pars){
    pars.image=renderer.cache['static'][pars.stars+'stars.png'];
    Stars.superConstructor.apply(this, [pars]);
};
gamejs.utils.objects.extend(Stars, GUI.Image);

Stars.prototype.setStars=function(stars){
    var img=renderer.cache['static'][stars+'stars.png'];
    this.resize(img.getSize())
    this.setImage(img);
};

var KeyExplanation=exports.KeyExplanation=function(pars){
    pars.size=[400, 52];
    KeyExplanation.superConstructor.apply(this, [pars]);
    var font=getFont('25_66');
    this.key=pars.key;
    this.text=pars.text;
    var bt_w= 60;
    if(this.key.length>1) bt_w=font.getTextSize(this.key)[0]+50;
    this.btn=new GUI.Button({'size':[bt_w, this.getSize()[1]],
                            'position':[0, 0],
                            'font':font,
                            'parent':this,
                            'image':renderer.cache.getUIImage('key_bg.png'),
                            'text':this.key});
    this.btn.label.move([this.btn.label.getPosition()[0], this.btn.label.getPosition()[1]-7]);
    
    this.lbl=new GUI.Label({'position':[0, 0],
                           'parent':this,
                           'font':font,
                           'text':this.text});
    
    this.center(this.lbl);
    this.lbl.move([bt_w+30, this.lbl.getPosition()[1]]);
};

gamejs.utils.objects.extend(KeyExplanation, GUI.View);
}}, ["gamejs", "gamejs-gui", "skin", "renderer", "settings", "combatracer", "car_descriptions", "weapon_descriptions", "levels", "utils", "sounds", "leagues"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs-gui": function(require, exports, module) {
var gamejs = require('gamejs');
var draw=gamejs.draw;

var EVT_FOCUS = exports.EVT_FOCUS = 'focus';
var EVT_BLUR = exports.EVT_BLUR = 'blur';
var EVT_MOUSE_OVER = exports.EVT_MOUSE_OVER = 'mouse_over';
var EVT_MOUSE_OUT = exports.EVT_MOUSE_OUT = 'mouse_out';
var EVT_KEY_DOWN = exports.EVT_KEY_DOWN= gamejs.event.KEY_DOWN;
var EVT_KEY_UP = exports.EVT_KEY_UP = gamejs.event.KEY_UP;
var EVT_MOUSE_UP = exports.EVT_MOUSE_UP = gamejs.event.MOUSE_UP;
var EVT_MOUSE_DOWN = exports.EVT_MOUSE_DOWN = gamejs.event.MOUSE_DOWN;
var EVT_MOUSE_WHEEL = exports.EVT_MOUSE_WHEEL = gamejs.event.MOUSE_WHEEL;
var EVT_MOUSE_MOTION = exports.EVT_MOUSE_MOTION = gamejs.event.MOUSE_MOTION;
var EVT_BTN_CLICK = exports.EVT_BTN_CLICK = 'btn_click';
var EVT_CLOSE = exports.EVT_CLOSE = 'close';
var EVT_SCROLL = exports.EVT_SCROLL = 'scroll';
var EVT_DRAG = exports.EVT_DRAG = 'drag';
var EVT_MOVE = exports.EVT_MOVE = 'move';
var EVT_RESIZE = exports.EVT_RESIZE = 'resize';
var EVT_PAINT = exports.EVT_PAINT = 'paint';
var EVT_AFTER_PAINT = exports.EVT_AFTER_PAINT = 'after_paint';
var EVT_CHANGE = exports.EVT_CHANGE = 'change'; //input change for input elements
var DEFAULT_FONT_DESCR='14px Verdana';
var gamejs_ui_next_id=1;


/**
 *@ignore
 */
function cloneEvent(evt, offset){
    var new_evt={};
    for(key in evt){
        new_evt[key]=evt[key];
    }
    if(new_evt.pos && offset){
        new_evt.pos=[new_evt.pos[0]-offset[0], new_evt.pos[1]-offset[1]];
    }
    return new_evt; 
}

/**
 *@ignore
 */
function getCenterPos(size1, size2){
    return [Math.max(parseInt((size1[0]-size2[0])/2), 0),
            Math.max(parseInt((size1[1]-size2[1])/2), 0)];
}

/**
 *Make a view draggable within it's parent. Dragging generates EVT_DRAG
 *@function
 *@param {View} view view to make draggable.
 */
var draggable=exports.draggable=function(view){
    view.grab_pos=null;
    view.on(EVT_MOUSE_DOWN, function(event){
        this.grab_pos=event.global_pos;
    }, view);
    view.getGUI().on(EVT_MOUSE_UP, function(event){
        this.grab_pos=null;
    }, view);
    
    view.getGUI().on(EVT_MOUSE_MOTION, function(event){
        if(this.grab_pos){
            var old_position=this.position;

            var new_position=[this.position[0]+event.pos[0]-this.grab_pos[0],
                              this.position[1]+event.pos[1]-this.grab_pos[1]];
            

            this.grab_pos=event.pos;
            this.move(new_position);
            this.despatchEvent({'type':EVT_DRAG,
                                'old_pos':old_position,
                                'new_pos':this.position});
        }
    }, view);
};

/**
 *implements lazy caching for individual letters
 *@class cached font
 *@constructor
 *
 *@param {String|Array} font either font description as string, or assoc array character:gamejs.Surface
 *@param {String} color a valid #RGB String, "#ffcc00"
 *
 *@property {Number} space_width space between lettersin pixels. Default 'm' width divided by 3
 *@property {Number} tab_width tab width in pixels. Default 3*space_width
 *@property {gamejs.font.Font} font font object used to render characters. Default 14px Verdana
 */
var CachedFont=exports.CachedFont=function(font, color){
    this.space_width=3;
    this.tab_width=12;
    this.chars={}; //character:surface;
    this.font=null;
    if((typeof font)=='string'){
        color = color ? color : '#000';
        this.color=color;
        this.font=new gamejs.font.Font(font);
        
    }else{
        this.chars=font;
        this.font=new gamejs.font.Font(DEFAULT_FONT_DESCR);
        this.color='#000';
    }
    //space width - 1/3 of m's width
    this.space_width=parseInt(Math.ceil(this.getCharSurface('m').getSize()[0]/3));
    this.tab_width=3*this.space_width;
};


/**
 *returns gamejs.Surface for a character. Caches this surface if it is not cached
 *
 *@function
 *@param {String} c single character
 *
 *@returns {gamejs.Surface} surface object with the character painted on. Not a copy, don't paint on it!
 */
CachedFont.prototype.getCharSurface=function(c){
    if(!this.chars[c]){
        var s=this.font.render(c, this.color);
        this.chars[c]=s;
    }
    return this.chars[c];
};

/**
 *get size text would occupy if it was rendered
 *@function
 *
 *@param {String} text
 *
 *@returns {Array} size, eg. [width, height]
 */
CachedFont.prototype.getTextSize=function(text){
    var w=0, h=0, c, l, sz;
    if(text){ 
        for(var i=0;i<text.length;i++){
            c=text[i];
            if(c==' ')w+=this.space_width;
            else if(c=='\t')w+=this.tab_width;
            else{
                l=this.getCharSurface(c);
                if(l){
                    sz=l.getSize();
                    w+=sz[0];
                    h=Math.max(sz[1], h);
                }
            }
        }
        if(!h) h=this.getCharSurface('m').getSize()[1];
        return [w, h];
    }else return [0, 0];
};

/**
 *render text on a surface
 *@function
 *
 *@param {gamejs.Surface} surface surface to render text on
 *@param {String} text text to render
 *@param {Array} position position to render the text at
 *@param {Number} space_width OPTIONAL, override space width
 */
CachedFont.prototype.render=function(surface, text, position, space_width){
    ofst=position[0];
    space_width=space_width? space_width : this.space_width;
    var i, c, s;
    for(i=0;i<text.length;i++){
        c=text[i];
        if(c==' ')ofst+=space_width;
        else if(c=='\t')ofst+=this.tab_width;
        else{
            s=this.getCharSurface(c);
            r1=[ofst, position[1]];
            surface.blit(s, r1);
            ofst+=s.getSize()[0];
        }
    }        
};

try{
    exports.DEFAULT_FONT=new CachedFont('12px Verdana', 'black');
}catch(e){
    
}

/**
 *View
 *@class base gui object !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@constructor
 *
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? default true
 *
 *@property {Array} size view size, [width, length]
 *@property {Array} position view position relative to parent, [x, y]
 *@property {gamejs.Surface} surface surface this view is rendered on
 *@property {View} parent parent view of this view
 *@property {Array} children array of this views children views
 */
var View=exports.View=function(pars){
    this.type='view';
    this.id=gamejs_ui_next_id++;
    if(!pars.size) throw "View: size must be specified"
    this.size=pars.size;
    if(!pars.position) pars.position=[0, 0];
    this.position=[parseInt(pars.position[0]), parseInt(pars.position[1])];
    this.surface=pars.surface ? pars.surface : new gamejs.Surface(this.size);
    if(pars.parent===undefined) throw "Element's parent not given."
    this.parent=pars.parent;
    if(pars.visible===undefined){
        this.visible=true;
    }else{
        this.visible=pars.visible;
    }
    if(this.parent) this.parent.addChild(this);
    
    this.children=[];
    this._refresh=true;
    
    //is the mouse over this view?
    this.is_hovered=false;
    
    //is this view focused?
    this.is_focused=false;
    
    //evenet type: [{'callback':x, 'scope':y, ...]
    this.listeners={};
    return this;
    
};

/*
 *get is focus state
 *@function
 *@returns {Bool} is this view focused?
 */
View.prototype.isFocused=function(){
    return this.is_focused;  
};

/**
 *get hover state
 *@function
 *@returns {Bool} is mouse hovering on this element?
 */
View.prototype.isHovered=function(){
    return this.is_hovered;  
};
/**
 *get view size
 *@function
 *@returns {Array} view size, [width, height]
 */
View.prototype.getSize=function(){
    return [this.size[0], this.size[1]];
};

/**
 *get view position within it's parent element
 *@function
 *@returns {Array} view position within it's parent element, [x, y]
 */
View.prototype.getPosition=function(){
    return [this.position[0], this.position[1]];
};

/**
 *get visible state
 *@function
 *@returns {Bool} is this view visible?
 */

View.prototype.isVisible=function(){
  return this.visible;
};

/**
 *detaches a child from this view
 *@function
 *@param {View|Number} child View or or child View id.
 */
View.prototype.removeChild=function(child){
    if(typeof(child)!='number')child=child.id;
    for(var i=0;i<this.children.length;i++){
        if(this.children[i].id==child){
            child=this.children.splice(i, 1);
            this.refresh();
            return true;
        }
    }
    return false;
}

/**
 *detaches view from it's parent, effectively destroying it
 *@function
 */
View.prototype.destroy=function(){
    if(this.parent)this.parent.removeChild(this);
}

/**
 *get position & size rect
 *@returns gamejs.Rect instance. Position is relative to parent
 */
View.prototype.getRect=function(){
    return new gamejs.Rect(this.position, this.size);  
};

/**
 *right align element to this x coordinate
 *@function
 *@param {Number} x xcoordinate
 */
View.prototype.rightAlign=function(x){
    this.move([x-this.getSize()[0], this.getPosition()[1]]);
};

/**
 *add child to this view
 *@param {View} child view to add as a child of this view
 */
View.prototype.addChild=function(child){
    this.children.push(child);
};

/**
 *if needed, paints this view, draws children and coposites them on this views surface
 *@function
 *@returns {Bool} has this view been repainted
 */
View.prototype.draw=function(){
    if(!this.visible){
        if(this._refresh){
            this._refresh=false;
            return true;
        }
        return false;
    }
    
    var painted=false; //has something been repainted in this view?
    //does this view need repainting?
  
    this.children.forEach(function(child){
        //draw children if this view has been repainted or child has been repainted
        if(child.draw() || this._refresh){
            painted=true;
        }
    }, this);
    
    if(this._refresh || painted){
        this.paint();
        this.despatchEvent({'type':EVT_PAINT, 'surface':this.surface});
        this.children.forEach(function(child){
            if(child.visible) this.blitChild(child);
        }, this)
        this.despatchEvent({'type':EVT_AFTER_PAINT, 'surface':this.surface});
        painted=true;
        this._refresh=false;
    }
    
    return painted;
};
/**
 *blit child's surface on this view's surface
 *@function
 *@param {View} child child view to blit
 */
View.prototype.blitChild=function(child){
    this.surface.blit(child.surface, child.position);
};

/**
 *paint this view on it's surface. does not repaint/blit children! override this to implement custom drawing of the element itself. by default, only clears the surface
 *@function
 */
View.prototype.paint=function(){
    this.surface.clear();
};


/**
 *update view. does nothing by default
 *@function
 *@param {Number} miliseconds since last update
 */
View.prototype.update=function(msDuration){};

/**
 *recursively calls _update on this views children, then calls update for this view.
 *@ignore
 */
View.prototype._update=function(msDuration){
    this.children.forEach(function(child){
        child._update(msDuration);        
    });
    this.update(msDuration);
};

/**
 *register a callback for an event. When event is triggered, callback is called with event object as argument
 *@function
 *@param {Event ID} event event ID of the event to be registered on, eg gamejs-gui.EVT_BLUR, gamejs-gui.EVT_KEY_DOWN, etc.
 *@param {Function} callback function to call when event is triggered
 *@param {Object} scope - this object for the callback
 */
View.prototype.on=function(event_type, callback, scope){
    if(!this.listeners[event_type])this.listeners[event_type]=[];
    this.listeners[event_type].push({'callback':callback, 'scope':scope});
};

/**
 *despatches event to all children. internal
 *@ignore
 */
View.prototype.despatchEventToChildren= function(event){
    this.children.forEach(function(child){child.despatchEvent(event);});
};

/**
 *Move view relative to its parent. Generates EVT_MOVE event
 *@function
 *@param {Array} new position relative to parent element, eg. [x, y]
 */
View.prototype.move=function(position){
    var old_position=this.position;
    this.position=position;
    this.parent.refresh();
    this.despatchEvent({'type':EVT_MOVE,
                       'old_pos':old_position,
                       'new_pos':position});
};

/**
 *Move view relative to its position. Generates EVT_MOVE event
 *@function
 *@param {Array} delta coordinates relative to current position ,eg. [delta x, delta y]
 */
View.prototype.moveRelative=function(position){
    this.move([this.position[0]+position[0], this.position[1]+position[1]]);  
};  

/**
 *Resize this view. Generates EVT_RESIZE event
 *@function
 *@param {Array} new size, eg. [width, height]
 */
View.prototype.resize=function(size){
    var old_size=this.size;
    this.size=size;
    this.surface=new gamejs.Surface([Math.max(size[0], 1), Math.max(size[1], 1)]);
    this.refresh();
    this.despatchEvent({'type':EVT_RESIZE,
                       'old_size':old_size,
                       'new_size':size});
};

/**
 *Redraw this view and its children.
 *@function
 */
View.prototype.refresh=function(){
    this._refresh=true;
};

/**
 *If this view is hidden, make it visible
 *@function
 */
View.prototype.show=function(){
    if(!this.visible){
        this.visible=true;
        this.refresh();
    }
};

/**
 *If this view is visible, hide it. This also blurs and mouse-outs the view, if applicable
 *@function
 */
View.prototype.hide=function(){
    if(this.visible){
        this.despatchEvent({'type':EVT_BLUR});
        this.despatchEvent({'type':EVT_MOUSE_OUT});
        this.visible=false;
        this.refresh();
    }
};

/**
 *Despatch event to this view. Event is despatched to children if applicable, then handled by this view.
 *@function
 *@param {Event} event event to despatch
 */
View.prototype.despatchEvent=function(event){
    if(!this.visible) return;
    var inside=false; //event position inside this view
    
    if(event.type==EVT_BLUR){
        if(this.is_focused){
            this.is_focused=false;
            this.refresh();
            this.handleEvent(event);
        }
        this.despatchEventToChildren(event);
    }
    else if(event.type==EVT_MOUSE_OUT){
        if(this.is_hovered){
            this.is_hovered=false;
            this.refresh();
            this.handleEvent(event);
        }
        this.despatchEventToChildren(event);
    }
    else if(event.type==EVT_MOUSE_OVER){
        this.is_hovered=true;
        this.refresh();
        this.handleEvent(event);
    }
    
    else if(event.type==EVT_FOCUS){
        this.is_focused=true;
        this.refresh();
        this.handleEvent(event);
    }
    
    else if(event.type==EVT_MOUSE_DOWN){
        if(!this.isFocused()){
            this.despatchEvent({'type':EVT_FOCUS});
        }
        this.children.forEach(function(child){
            //click inside child: despatch
            if(child.getRect().collidePoint(event.pos)){
                child.despatchEvent(cloneEvent(event, child.position));
            }else{
                //not inside, but child is focused: blur
                if(child.isFocused()) child.despatchEvent({'type':EVT_BLUR});
            }
        }, this);
        this.handleEvent(event);
    }
    
    else if(event.type==EVT_MOUSE_UP){
        this.children.forEach(function(child){
            //click inside child: despatch
            if(child.getRect().collidePoint(event.pos)){
                child.despatchEvent(cloneEvent(event, child.position));
            }
        }, this);
        this.handleEvent(event);
    }
    
    else if(event.type==EVT_MOUSE_MOTION){
        
        //mouse moved onto this view - hover
        this.children.forEach(function(child){
            //click inside child: despatch
            if(child.getRect().collidePoint(event.pos)){
                //inside, not hovering: hover
                if(!child.isHovered()) child.despatchEvent(cloneEvent({'type':EVT_MOUSE_OVER, 'pos':event.pos}, child.position));
                child.despatchEvent(cloneEvent(event, child.position));
            }else{
                //not inside, but child is focused: blur
                if(child.isHovered()) child.despatchEvent(cloneEvent({'type':EVT_MOUSE_OUT, 'pos':event.pos}, child.position));
            }
        }, this);
        this.handleEvent(event);
        
    }
    else if(event.type==EVT_KEY_UP || event.type==EVT_KEY_DOWN || event.type==EVT_KEY_UP){
        if(this.isFocused()){     
            this.children.forEach(function(child){
                if(child.isFocused()) child.despatchEvent(cloneEvent(event));
            });
            this.handleEvent(event);
        }
    //default
    }else{
        this.handleEvent(event);
    }

};

/**
 *returns GUI object at the base of this views branch
 *@function
 *@returns {GUI} GUI object at the base if this views branch
 */
View.prototype.getGUI=function(){
    var parent=this.parent;
    while(parent!=null && parent.type!='gui'){
        parent=parent.parent;
    }
    return parent;
};

/**
 *Center a child view within this view. Must be direct child
 *@function
 *@param {View} child child view
 */
View.prototype.center=function(child){
    child.move(getCenterPos(this.size, child.size));   
};

/**
 *execute any registered callbacks for this event. Should only be called by despatchEvent!
 *@ignore
 */
View.prototype.handleEvent=function(event){
    if(this.listeners[event.type]){
        this.listeners[event.type].forEach(function(listener){
            if(listener.scope) listener.callback.apply(listener.scope, [event, this]);
            else listener.callback(event, this);
        });
    }
};

/**
 *@class single-line text display !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *@constructor 
 *
 *@param {CachedFont} font font to draw text with. OPTIONAL, default gamejs-gui.DEFAULT_FONT
 *@param {String} text text to draw
 *@param {View} parent parent element
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, EFAULT true
 *
 *resized automatically to house text.
 *
 *@property {CachedFont} font
 *@property {String} text

 */

var Label=exports.Label=function(pars){
    this.font=pars.font ? pars.font : exports.DEFAULT_FONT;
    pars.size=[1, 1];
    Label.superConstructor.apply(this, [pars]);
    if((pars.text == undefined)|| (pars.text == null)) throw "Label: label text must be provided!"
    this.setText(String(pars.text));
    this.type='label'; 
};

gamejs.utils.objects.extend(Label, View);

/**
 *set new text for this label. Resizes the view automatically.
 *@function
 *
 *@param {String} text new text
 */
Label.prototype.setText=function(text){
    this.text=String(text) ? String(text) : ' ';
    this.size=this.font.getTextSize(text);
    this.resize(this.size);
};

/***
 *paint implementation for label. clears surface and renders text
 *@function
 */
Label.prototype.paint=function(){
    this.surface.clear();
    this.font.render(this.surface, this.text, [0, 0]);
};

/**
 *@class button !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {gamejs.Surface} image button image, OPTIONAL
 *@param {gamejs.Surface} image_down button image when pressed down, OPTIONAL
 *@param {gamejs.Surface} image_hover button image when hovered on, OPTIONAL
 *@param {String} text text to display on button, OPTIONAL
 *@param {CachedFont} font to render text with, OPTIONAL
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? default true
 *
 *@property {String} text
 *@property {CachedFont} font
 *@property {Label} label  Label obejct, created if text was provided.
 */

var Button=exports.Button=function(pars){
    Button.superConstructor.apply(this, [pars]);
    this.type='button';
    this.image=null;
    this.label=null;
    this.image=pars.image;
    this.image_down=pars.image_down;
    this.image_hover=pars.image_hover;
    
    if(!this.image){
        this.image=new gamejs.Surface(this.size);
        this.image.fill('#FFF');
        gamejs.draw.rect(this.image, '#808080', new gamejs.Rect([0, 0], this.size), 1);
    }
    
    if(pars.text){     
        this.label=new Label({'parent':this,
                             'position':[0, 0],
                             'text':pars.text,
                             'font':pars.font});
        this.center(this.label);
    }
    
    this.pressed_down=false;
    this.on(EVT_MOUSE_DOWN, function(){
        if(!this.pressed_down){
            this.pressed_down=true;
            this.refresh();
        }
    }, this);
    
    this.on(EVT_MOUSE_UP, function(){
        if(this.pressed_down){
            this.pressed_down=false;
            this.despatchEvent({'type':EVT_BTN_CLICK});
            this.refresh();
        }
    }, this);
    
    this.on(EVT_MOUSE_OUT, function(){
        if(this.pressed_down){
            this.pressed_down=false;
            this.refresh();
        }
    }, this)
};

gamejs.utils.objects.extend(Button, View);

/**
 *short hand for on(EVT_BTN_CLICK, callback, scope)
 *@function
 *
 *@param {Function} callback function to call when EVT_BTN_CLICK event is triggered
 *@param {Object} scope this object for callback, OPTIONAL
 */
Button.prototype.onClick=function(callback, scope){
    this.on(EVT_BTN_CLICK, callback, scope);
};

/**
 *default button paint implementation paints image, image_down or image_hover based on button sotate
 *@function
 */
Button.prototype.paint=function(){
    var img;
    if(this.pressed_down && this.image_down) img=this.image_down;
    else if(this.isHovered() && this.image_hover) img=this.image_hover;
    else img=this.image;
    this.surface.blit(img, new gamejs.Rect([0, 0], this.surface.getSize()), new gamejs.Rect([0, 0], img.getSize()));
    
};

/**
 *set button text
 *@function
 *@param {String} text
 */
Button.prototype.setText=function(text){
    if(this.label){
        this.label.setText(text);
        this.center(this.label);
    }
};

/**
 *@class image !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {gamejs.Surface} image to paint
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {gamejs.Surface} image
 */

var Image=exports.Image=function(pars){
    if(!pars.image) throw 'Image: parameter image is required';
    if(!pars.size) pars.size=pars.image.getSize();
    this.image=pars.image;
    Image.superConstructor.apply(this, [pars]);
    this.type='image';
    return this;
};

gamejs.utils.objects.extend(Image, View);

/**
 *set new image
 *@function
 *@param {gamejs.Surface} image
 */
Image.prototype.setImage=function(image){
    this.image=image;
    this.refresh();
};

/**
 *default paint implementation for image. If Image object size!=provided image surface size, image is stretched.
 *@function
 */
Image.prototype.paint=function(){
    View.prototype.paint.apply(this, []);
    this.surface.blit(this.image, new gamejs.Rect([0, 0], this.surface.getSize()), new gamejs.Rect([0, 0], this.image.getSize()));  
};

/**
 *@class draggable frame header with a close button !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {Frame} parent frame object this header is applied to
 *@param {Number} height frame height, OPTIONAL, DEFAULT 20
 *@param {String} title frame title OPTIONAL
 *@param {CachedFont} title_font font for title OPTIONAL
 *@param {Bool} close_btn show close button? OPTIONAL, DEFAULT false
 *@param {gamejs.Surface} close_icon image to use for close button, OPTIONAL
 *@param {gamejs.Surface} close_btn close button image OPTIONAL
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {CachedFont) title_font
 *@property {Number} height
 */
var FrameHeader=exports.FrameHeader=function(pars){
    if(!pars.parent) throw 'FrameHeader: parent parameter is required';
    this.height=pars.height || 20;
    pars.width=pars.parent.size[0];
    pars.size=[pars.width, this.height];
    pars.position=[0, 0];
    this.title_font=pars.title_font;
    
    FrameHeader.superConstructor.apply(this, [pars]);
    draggable(this);
    
    if(pars.title){
        this.setTitle(pars.title);
    }
    
    if(pars.close_btn){
        var img;
        if(pars.close_icon){
            img=pars.close_icon;
        }
        else{
            img=new gamejs.Surface([this.height, this.height]);
            gamejs.draw.line(img, '#000', [3, 3], [this.height-3, this.height-3], 3);
            gamejs.draw.line(img, '#000', [3, this.height-3], [this.height-3, 3], 3);
        }
      
        img=new Image({'parent':this,
                      'position':[this.size[0]-img.getSize()[0], 0],
                      'image':img});
        img.on(EVT_MOUSE_DOWN, function(){
            this.close();
            this.despatchEvent({'type':EVT_CLOSE});
        }, this.parent);
    }
    
    this.type='frameheader';       
};

gamejs.utils.objects.extend(FrameHeader, View);

/**
 *moving header moves parent frame too
 *@function
 *
 *@param {Array} pos position ot move header to
 */
FrameHeader.prototype.move=function(pos){
    this.parent.move([this.parent.position[0]+pos[0]-this.position[0],
                      this.parent.position[1]+pos[1]-this.position[1]]);
};

/**
 *set header title
 *@function
 *
 *@param {String} text new header title
 */
FrameHeader.prototype.setTitle=function(text){
    if(!this.title_label)this.title_label=new Label({'parent':this,
                                                    'position':[0, 0],
                                                    'font':this.title_font,
                                                    'text':text});
    else this.title_label.setText(text);
    var font=this.title_label.font;
    var size=font.getTextSize(text);
    this.title_label.move([font.space_width, Math.max(parseInt(this.height-size[1]))], 0);
    draggable(this);
};

/**
 *default paint implementation: gray background
 *@function
 */
FrameHeader.prototype.paint=function(){
    gamejs.draw.rect(this.surface, '#C0C0C0', new gamejs.Rect([0, 0], this.size));
};



/**
 *@class a overlay view with it's own space and hierarchy, a 'window' in OS talk. Hidden by default !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {GUI} parent parent GUI object
 *@param {Bool} constrain if true, frame cannot be moved out of visible area
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {Bool} constrain
 */
var Frame=exports.Frame=function(pars){
    if(!pars.parent) throw 'Frame: parent parameter is required';
    if(pars.parent.type!='gui') throw 'Frame: parent object must be instance of GUI';
    var gui=pars.parent;
    pars.parent=null;
    Frame.superConstructor.apply(this, [pars]);
    this.type='frame';
    this.visible=false;
    gui.frames.push(this);
    this.parent=gui;    
    //constrain
    this.constrain=pars.constrain;
    return this;
};
gamejs.utils.objects.extend(Frame, View);

/**
 *Default implementation, white fill and gray border.
 *@function
 */
Frame.prototype.paint=function(){
    //fill
    gamejs.draw.rect(this.surface, '#FFF', new gamejs.Rect([0, 0], this.size));
    
    //draw border
    gamejs.draw.rect(this.surface, '#404040', new gamejs.Rect([0, 0], this.size), 1);
};

/**
 *Show frame, move it to top of the screen
 *@function
 */
Frame.prototype.show=function(){
    View.prototype.show.apply(this, []);
    this.parent.moveFrameToTop(this);
};

/**
 *Close frame. You propably want to use this instead of hide()! generates EVT_CLOSE
 *@function
 */
Frame.prototype.close=function(){
    View.prototype.hide.apply(this, []);
    this.despatchEvent({'type':EVT_CLOSE});
};

/**
 *implements restricting frame to GUI bounds. generates EVT_MOVE
 *@function
 *@param {Array} position position to move frame to
 */

Frame.prototype.move=function(position){
    if(this.constrain){
        if(position[0]<0)position[0]=0;
        if(position[0]>this.parent.size[0]-this.size[0]) position[0]=this.parent.size[0]-this.size[0];
        if(position[1]<0)position[1]=0;
        if(position[1]>this.parent.size[1]-this.size[1]) position[1]=this.parent.size[1]-this.size[1];
    }
    View.prototype.move.apply(this, [position]);
};

/**
 *closes frame, then destroys it
 *@function
 */
Frame.prototype.destroy=function(){
    if(this.visible) this.close();
    if(this.parent) this.parent.removeFrame(this);
};

/**
 *@class draggable view: can be dragged within its parent by holding down left mouse btn
 *@augments View
 *
 *@param {Number} min_x minimum x coordinate view can be dragged to, OPTIONAL
 *@param {Number} max_x maximum x coordinate view can be dragged to, OPTIONAL
 *@param {Number} min_y minimum y coordinate view can be dragged to, OPTIONAL
 *@param {Number} max_y maximum y coordinate view can be dragged to, OPTIONAL
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? default true
 *
 *@property {Number} min_x
 *@property {Number} max_x
 *@property {Number} min_y
 *@property {Number} max_y
 */

var DraggableView=exports.DraggableView=function(pars){
    DraggableView.superConstructor.apply(this, [pars]);
    draggable(this);
    this.min_x=pars.min_x;
    this.max_x=pars.max_x;
    this.min_y=pars.min_y;
    this.max_y=pars.max_y;
    this.type='draggableview';
};

gamejs.utils.objects.extend(DraggableView, View);

/**
 *implements restricting to coordinates, if applicable
 *@function
 *@param {Array} pos new position
 */
DraggableView.prototype.move=function(pos){
    var x=pos[0];
    if(this.min_x || (this.min_x==0)) x=Math.max(x, this.min_x);
    if(this.max_x || (this.max_x==0)) x=Math.min(x, this.max_x);
    
    var y=pos[1];
    if(this.min_y || (this.min_y==0)) y=Math.max(y, this.min_y);
    if(this.max_y || (this.max_y==0)) y=Math.min(y, this.max_y);
    
    View.prototype.move.apply(this, [[x, y]]);
};


/**
 *@class draggable part of the scrollbar !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments DraggableView
 *
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {gamejs.Surface} image iamge to use for the scroller, OPTIONAL
 *@param {Number} min_x minimum x coordinate view can be dragged to, OPTIONAL
 *@param {Number} max_x maximum x coordinate view can be dragged to, OPTIONAL
 *@param {Number} min_y minimum y coordinate view can be dragged to, OPTIONAL
 *@param {Number} max_y maximum y coordinate view can be dragged to, OPTIONAL
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {Image} img Image object created if image parameter was provided
 */
var Scroller=exports.Scroller=function(pars){
    Scroller.superConstructor.apply(this, [pars]);
    this.img=null;
    if(pars.image){
        this.img=new Image({'parent':this,
                    'position':[0, 0],
                    'size':this.size,
                    'image':pars.image});
    }
};
gamejs.utils.objects.extend(Scroller, DraggableView);

/**
 *resizes image along with scroller
 *@function 
 */
Scroller.prototype.resize=function(size){
    DraggableView.prototype.resize.apply(this,[size]);
    if(this.img)this.img.resize(size);

};

/**
 *@class !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {gamejs.Surface} left_btn_image image for left scrollbar button
 *@param {gamejs.Surface} scroller_image image for scroller
 *@param {gamejs.Surface} right_btn_image image for right scrollbar button
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {Button} left_btn left scrollbar button
 *@property {Button} right_btn right scrollbar button
 *@property {Scroller} scroller
 *@property {Function} scroller_class scroller class used to create scroller #TODO find better way to implement customization
 */

var HorizontalScrollbar=exports.HorizontalScrollbar=function(pars){
    HorizontalScrollbar.superConstructor.apply(this, [pars]);
    this.type='horizontalscrollbar';
    var left_btn_image=pars.left_btn_image;
    if(!left_btn_image){
        left_btn_image=new gamejs.Surface([this.size[1], this.size[1]]);
        var pts=[[0, this.size[1]/2],
                 [this.size[1], 0],
                 [this.size[1], this.size[1]]];
        gamejs.draw.polygon(left_btn_image, '#C0C0C0', pts);
    }
    this.left_btn=new Button({'parent':this,
                            'position':[0, 0],
                            'size':[this.size[1], this.size[1]],
                            'image':left_btn_image});
    this.left_btn.onClick(this.scrollLeft, this);
    
    var right_btn_image=pars.right_btn_image;
    if(!right_btn_image){
        right_btn_image=new gamejs.Surface([this.size[1], this.size[1]]);
        var pts=[[0, 0],
                 [this.size[1], this.size[1]/2],
                 [0, this.size[1]]];
        gamejs.draw.polygon(right_btn_image, '#C0C0C0', pts);
    }
    this.right_btn=new Button({'parent':this,
                            'position':[this.size[0]-this.size[1], 0],
                            'size':[this.size[1], this.size[1]],
                            'image':right_btn_image});
    
    this.right_btn.onClick(this.scrollRight, this);

    //scroller track size
    this.sts=this.size[0]-this.right_btn.size[0]-this.left_btn.size[0];
    
    var scroller_image=pars.scroller_image;
    if(!scroller_image){
        scroller_image=new gamejs.Surface([this.size[1], this.size[1]]);
        var sz=scroller_image.getSize()
        gamejs.draw.rect(scroller_image, '#C0C0C0', new gamejs.Rect([0, 0],[sz[0], sz[1]]));
    }
    var size=[Math.max(parseInt((this.size[0]-2*this.size[1])/2),scroller_image.getSize()[0]), this.size[1]];
    this.scroller=new this.scroller_class({'parent':this,
                                            'position':[this.size[1], 0],
                                            'image':scroller_image,
                                            'size':size,
                                            'min_x':this.size[1],
                                            'max_x':this.size[0]-this.right_btn.size[0]-size[0],
                                            'min_y':0,
                                            'max_y':0});

    
    this.scroll_pos=0;
    this.max_scroll_pos=this.sts-this.scroller.size[0];
    
    this.scroller.on(EVT_DRAG, function(event){
        this.setScrollPX(event.new_pos[0]-this.size[1]);
    }, this);
};
gamejs.utils.objects.extend(HorizontalScrollbar, View);

HorizontalScrollbar.prototype.scroller_class=Scroller;

/**
 *set relative scroller width
 *@function
 *@param {Number} sz relative scroller width, between 0.1 and 1, 
 */
HorizontalScrollbar.prototype.setScrollerSize=function(sz){
    sz=Math.min(Math.max(sz, 0.1), 1);
    this.scroller.resize([this.sts*sz, this.scroller.size[1]]);
   
    this.max_scroll_pos=this.sts-this.scroller.size[0];
    this.scroller.max_x=this.size[0]-this.left_btn.size[0]-this.scroller.size[0];
    this.refresh();
};

/**
 *set scroll amount, px
 *@function
 *@param {Number} pos scroll amount, px
 */
HorizontalScrollbar.prototype.setScrollPX=function(pos){
    this.scroller.move([pos+this.left_btn.size[0], 0]);
    var pos_x=this.scroller.position[0]-this.left_btn.size[0];
    this.scroll_pos=pos_x;
    var scroll=0;
    if(this.max_scroll_pos>0){
        scroll=pos_x/this.max_scroll_pos;
    }
    this.despatchEvent({'type':EVT_SCROLL,
                       'scroll_px':pos_x,
                       'scroll':scroll});
    this.refresh();
};

/**
 *set scroll amount, relative
 *@function
 *@param {Number} pos scroll amount, between 0 and 1
 */
HorizontalScrollbar.prototype.setScroll=function(pos){
    this.setScrollPX(parseInt(this.max_scroll_pos*pos));
};

/**
 *scroll left by 0.1 of max scrollable amount
 *@function
 */
HorizontalScrollbar.prototype.scrollLeft=function(){
    this.setScrollPX(Math.max(0, this.scroll_pos-this.max_scroll_pos*0.1));
};

/**
 *scroll right by 0.1 of max scrollable amount
 *@function
 */
HorizontalScrollbar.prototype.scrollRight=function(){
    this.setScrollPX(Math.min(this.max_scroll_pos, this.scroll_pos+this.max_scroll_pos*0.1));
};

/**
 *@class !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {gamejs.Surface} top_btn_image image for top scrollbar button
 *@param {gamejs.Surface} scroller_image image for scroller
 *@param {gamejs.Surface} bot_btn_image image for bottom scrollbar button
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {Button} top_btn top scrollbar button
 *@property {Button} bot_btn bottom scrollbar button
 *@property {Scroller} scroller
 *@property {Function} scroller_class scroller class used to create scroller #TODO find better way to implement customization
 */

var VerticalScrollbar=exports.VerticalScrollbar=function(pars){
    VerticalScrollbar.superConstructor.apply(this, [pars]);
    this.type='verticalscrollbar';
    var top_btn_image=pars.top_btn_image;
    if(!top_btn_image){
        top_btn_image=new gamejs.Surface([this.size[0], this.size[0]]);
        var pts=[[this.size[0]/2, 0],
                 [0, this.size[0]],
                 [this.size[0], this.size[0]]];
        gamejs.draw.polygon(top_btn_image, '#C0C0C0', pts);
    }
    this.top_btn=new Button({'parent':this,
                            'position':[0, 0],
                            'size':[this.size[0], this.size[0]],
                            'image':top_btn_image});
    this.top_btn.onClick(this.scrollUp, this);
    
    var bot_btn_image=pars.bot_btn_image;
    if(!bot_btn_image){
        bot_btn_image=new gamejs.Surface([this.size[0], this.size[0]]);
        var pts=[[0, 0],
                 [this.size[0], 0],
                 [this.size[0]/2, this.size[0]]];
        gamejs.draw.polygon(bot_btn_image, '#C0C0C0', pts);
    }
    this.bot_btn=new Button({'parent':this,
                            'position':[0, this.size[1]-this.size[0]],
                            'size':[this.size[0], this.size[0]],
                            'image':bot_btn_image});
    
    this.bot_btn.onClick(this.scrollDown, this);

    //scroller track size
    this.sts=this.size[1]-this.bot_btn.size[1]-this.top_btn.size[1];
    
    var scroller_image=pars.scroller_image;
    if(!scroller_image){
        scroller_image=new gamejs.Surface([this.size[0], this.size[0]]);
        var sz=scroller_image.getSize()
        gamejs.draw.rect(scroller_image, '#C0C0C0', new gamejs.Rect([0, 0],[sz[0], sz[1]]));
    }
    var size=[this.size[0], Math.max(parseInt((this.size[1]-2*this.size[0])/2),scroller_image.getSize()[1])];
    this.scroller=new this.scroller_class({'parent':this,
                                            'position':[0, this.size[0]],
                                            'image':scroller_image,
                                            'size':size,
                                            'min_x':0,
                                            'max_x':0,
                                            'min_y':this.size[0],
                                            'max_y':this.size[1]-this.bot_btn.size[1]-size[1]});

    
    this.scroll_pos=0;
    this.max_scroll_pos=this.sts-this.scroller.size[1];
    
    this.scroller.on(EVT_DRAG, function(event){
        this.setScrollPX(event.new_pos[1]-this.size[0]);
    }, this);
};
gamejs.utils.objects.extend(VerticalScrollbar, View);

VerticalScrollbar.prototype.scroller_class=Scroller;

/**
 *set relative scroller width
 *@function
 *@param {Number} sz relative scroller width, between 0.1 and 1, 
 */
VerticalScrollbar.prototype.setScrollerSize=function(sz){
    sz=Math.min(Math.max(sz, 0.1), 1);
    this.scroller.resize([this.scroller.size[0], this.sts*sz]);
   
    this.max_scroll_pos=this.sts-this.scroller.size[1];
    this.scroller.max_y=this.size[1]-this.bot_btn.size[1]-this.scroller.size[1];
    this.refresh();
};

/**
 *set scroll amount, px
 *@function
 *@param {Number} pos scroll amount, px
 */
VerticalScrollbar.prototype.setScrollPX=function(pos){
    this.scroller.move([0, pos+this.top_btn.size[1]]);
    var pos_y=this.scroller.position[1]-this.top_btn.size[1];
    this.scroll_pos=pos_y;
    var scroll=0;
    if(this.max_scroll_pos>0){
        scroll=pos_y/this.max_scroll_pos;
    }
    this.despatchEvent({'type':EVT_SCROLL,
                       'scroll_px':pos_y,
                       'scroll':scroll});
    this.refresh();
};

/**
 *set scroll amount, relative
 *@function
 *@param {Number} pos scroll amount, between 0 and 1
 */
VerticalScrollbar.prototype.setScroll=function(pos){
    this.setScrollPX(parseInt(this.max_scroll_pos*pos));
};

/**
 *@function
 *scroll up by 0.1 of max scrollable amount
 */
VerticalScrollbar.prototype.scrollUp=function(){
    this.setScrollPX(Math.max(0, this.scroll_pos-this.max_scroll_pos*0.1));
};

/**
 *@function
 *scroll down by 0.1 of max scrollable amount
 */
VerticalScrollbar.prototype.scrollDown=function(){
    this.setScrollPX(Math.min(this.max_scroll_pos, this.scroll_pos+this.max_scroll_pos*0.1));
};

/**
 *@class view with scrollable content !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 */
var ScrollableView=exports.ScrollableView=function(pars){
    ScrollableView.superConstructor.apply(this, [pars]);
    this.type='scrollableview';
    this.scroll_x=0;
    this.scroll_y=0;
    this.max_scroll_x=0;
    this.max_scroll_y=0;
    this.scrollable_area=[0, 0];
    this.setScrollableArea(this.size);
    this.vertical_scrollbar=null;
    this.horizontal_scrollbar=null;
};
gamejs.utils.objects.extend(ScrollableView, View);

/**
 *set vertical scrollbar for this view
 *@function
 *@param {VerticalScrollbar} scrollbar
 */
ScrollableView.prototype.setVerticalScrollbar=function(scrollbar){
    this.vertical_scrollbar=scrollbar;
    scrollbar.on(EVT_SCROLL, function(event){
        this.setScrollY(Math.ceil(event.scroll*this.max_scroll_y));
    }, this);
};

/**
 *set horizontal scrollbar for this view
 *@function
 *@param {HorizontalScrollbar} scrollbar
 */
ScrollableView.prototype.setHorizontalScrollbar=function(scrollbar){
    this.horizontal_scrollbar=scrollbar;
    scrollbar.on(EVT_SCROLL, function(event){
        this.setScrollX(Math.ceil(event.scroll*this.max_scroll_x));
    }, this);
};

/**
 *manually set size of scrollable area
 *@function
 *@param {Array} area scrollbale area, [width, height]
 */
ScrollableView.prototype.setScrollableArea=function(area){
    this.scrollable_area=area;
    this.max_scroll_y=Math.max(area[1]-this.size[1], 0);
    this.max_scroll_x=Math.max(area[0]-this.size[0], 0);
    if(this.vertical_scrollbar){
        var sz=Math.max(Math.min(1, this.size[1]/area[1]), 0.1);
        this.vertical_scrollbar.setScrollerSize(sz);
    }
    if(this.horizontal_scrollbar){
        var sz=Math.max(Math.min(1, this.size[0]/area[0]), 0.1);
        this.horizontal_scrollbar.setScrollerSize(sz);
    }
};

/**
 *automatically set scrollable area based on children positions and sizes
 *@function
 */
ScrollableView.prototype.autoSetScrollableArea=function(){
    scrollable_area=[0, 0];
    this.children.forEach(function(child){
            scrollable_area[0]=Math.max(scrollable_area[0], child.position[0]+child.size[0]+20);
            scrollable_area[1]=Math.max(scrollable_area[1], child.position[1]+child.size[1]+20);
    }, this);
    this.setScrollableArea(scrollable_area);
};

/**
 *TODO: implement optional auto setting scrollable area when children are added
 *@function
 */
ScrollableView.prototype.addChild=function(child){
    View.prototype.addChild.apply(this, [child]);
    this.refresh();    
};

/**
 *implements child blitting adjusted to scroll state
 *@function
 */
ScrollableView.prototype.blitChild=function(child){
    this.surface.blit(child.surface, [child.position[0]-this.scroll_x, child.position[1]-this.scroll_y]);
};

/**
 *adjusts event position based on scroll state
 *@function
 */
ScrollableView.prototype.despatchEvent=function(event){
    if(event.pos){
        event=cloneEvent(event);
        event.pos=[event.pos[0]+this.scroll_x, event.pos[1]+this.scroll_y];
    }
    View.prototype.despatchEvent.apply(this, [event]);
};

/**
 *increment horizontal scroll
 *@function
 *@param {Number} x px to increment horizontal scroll by
 */
ScrollableView.prototype.scrollX=function(x){
  this.setScrollX(this.scroll_x+x);
  this.refresh();
};

/**
 *increment vertical scroll
 *@function
 *@param {Number} y px to increment vertical scroll by
 */
ScrollableView.prototype.scrollY=function(y){
    this.setScrollY(this.scroll_y+y);
    this.refresh();
};

/**
 *set horizontal scroll
 *@function
 *@param {Number} x horizontal scroll, px
 */
ScrollableView.prototype.setScrollX=function(x){
    this.scroll_x=Math.min(Math.max(x, 0), this.max_scroll_x);
    this.refresh();
};

/**
 *set vertical scroll
 *@function
 *@param {Number} y vertical scroll, px
 */
ScrollableView.prototype.setScrollY=function(y){
    this.scroll_y=Math.min(Math.max(y, 0), this.max_scroll_y);
    this.refresh();
};

/**
 *@class text input !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {CachedFont} font 
 *@param {String} text
 *@param {Array} scw_size actual text display size, [width, height].
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {CachedFont} font
 *@property {String} text
 */
var TextInput=exports.TextInput=function(pars){
    TextInput.superConstructor.apply(this, [pars]);
    this.font=pars.font ? pars.font : exports.DEFAULT_FONT;
    this.text=pars.text ? pars.text : '';
    this.blip=false;
    this.pos=0;
    this.ms=500;
    
    this.scw=new ScrollableView({'parent':this,
                              'position':[0, 0],
                              'size':pars.scw_size || this.size});
    this.center(this.scw);
    this.label=new Label({'parent':this.scw,
                         'position':[0, 0],
                         'font':this.font,
                         'text':this.text});
    this.scw.center(this.label);
    this.label.move([3, this.label.position[1]]);
    
    this.bliplabel=new Label({'parent':this.scw,
                             'position':[0, 0],
                             'font':this.font,
                             'visible':false,
                             'text':'|'});
    
    this.on(EVT_KEY_DOWN, this.onKeyDown, this);
    this.on(EVT_FOCUS, this.blipon, this);
    this.on(EVT_BLUR, function(){
        this.blip=false;
    }, this);
    this.setPos(this.text.length);
};
gamejs.utils.objects.extend(TextInput, View);

/**
 *turn blip on
 *@ignore
 */
TextInput.prototype.blipon=function(event){
    this.blip=true;
    this.ms=500;
    this.refresh();
};

/**
 *implements blip updating
 *@function
 *@param {Number} msDuration
 */
TextInput.prototype.update=function(msDuration){
    if(this.isFocused()){
        this.ms-=msDuration;
        if(this.ms<0){
            this.ms=500;
            this.blip=!this.blip;
        };
        if(this.blip){
            this.bliplabel.show();    
        }else{
            this.bliplabel.hide();
        }
    }else{
        this.bliplabel.hide();
    }
};

/**
 *default implementation: white fill, gray border
 *@function
 */
TextInput.prototype.paint=function(){
    this.surface.fill('#FFF');
    gamejs.draw.rect(this.surface, '#COCOCO', new gamejs.Rect([0, 0], this.size), 1);
};

/**
 *set input text. generates EVT_CHANGE
 *@function
 *@param {String} text
 */
TextInput.prototype.setText=function(text){
    this.setPos(this.text.length);
    this._setText(text);
};

/**
 *set blip position
 *@ignore
 */
TextInput.prototype.setPos=function(pos){
    this.pos=Math.min(Math.max(pos, 0), this.text.length);

    //calc offset for scorllable area
    var ofst=0;
    var ofst=0;
    var tlen=this.font.getTextSize(this.text.substr(0, this.pos))[0];
    ofst=Math.max(tlen-this.scw.size[0]+this.font.getTextSize('s')[0]);
    
    this.scw.setScrollX(ofst);
    this.bliplabel.move([Math.max(this.font.getTextSize(this.text.substr(0, this.pos))[0]+this.label.position[0]-2, 0), this.label.position[1]]);
           
};

/**
 *@ignore
 */
TextInput.prototype._setText=function(text){
    this.text=text;
    this.label.setText(text);
    this.scw.autoSetScrollableArea();
    this.refresh();
    this.despatchEvent({'type':EVT_CHANGE,'value':text});
};

/**
 *key down handler
 *@ignore
 */
TextInput.prototype.onKeyDown=function(event){
    var charcode=event.key;
    if(charcode==13){
        //TODO
    }
    //BACKSPACE
    if(charcode==8){
        if(this.text){
            if(this.pos==this.text.length){
                this._setText(this.text.substr(0,this.text.length-1));
            }else {
                this._setText(this.text.substr(0, this.pos-1)+this.text.substr(this.pos, this.text.length));
            }
            this.blipon();
            this.setPos(this.pos-1);
        }
    }
    //WRITEABLE SYMBOLS, 0 to z or space
    if(((charcode>=48) && (charcode<=90))||(charcode==32)){
        var c=String.fromCharCode(charcode);
        if(event.shiftKey)c=c.toUpperCase();
        else c=c.toLowerCase();
        if(this.pos==this.text.length){
            this._setText(this.text+c);
        }else{
            this._setText(this.text.substr(0, this.pos)+c+this.text.substr(this.pos, this.text.length));
        }
        this.setPos(this.pos+1);
        this.blipon();
    }

    //LEFT
    if(charcode==37){
        this.setPos(this.pos-1);
        this.blipon();
    }
    //RIGHT
    if(charcode==39){
        this.setPos(this.pos+1);
        this.blipon();
    }
};

/**
 *@class a centered dialog position at the top of the GUI. disables and grays out rest of the guy
 *@augments Frame
 *
 *@param {GUI} parent parent GUI object
 *@param {Bool} constrain if true, frame cannot be moved out of visible area
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? default true
 */

var Dialog=exports.Dialog=function(pars){
    pars.position=getCenterPos(pars.parent.size, pars.size);
    Dialog.superConstructor.apply(this, [pars]);
    
};

gamejs.utils.objects.extend(Dialog, Frame);

/**
 *lock GUI & show dialog
 *@function
 */
Dialog.prototype.show=function(){
    this.getGUI().lockFrame(this);
    Frame.prototype.show.apply(this, []);
};

/**
 *unlock gui & hide dialog
 *@function
 */
Dialog.prototype.close=function(){
    this.getGUI().unlockFrame();
    Frame.prototype.close.apply(this, []);
};

/**
 *@class multi-line, line-wrapped text dislay !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {CachedFont} font 
 *@param {String} text
 *@param {Bool} justify if true, text is justified. By default, it's left-aligned
 *@param {View} parent parent element
 *@param {Integer} width text width in px. height is calculated automatically
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 */
var Text=exports.Text=function(pars){
    pars.size=[pars.width, 1];
    Text.superConstructor.apply(this, [pars]);
    this.width=pars.width;
    this.font=pars.font ? pars.font : exports.DEFAULT_FONT;
    this.setText(pars.text);
    this.justify=pars.justify;
};
gamejs.utils.objects.extend(Text, View);

/**
 *set text
 *@function
 *@param {String} text
 */
Text.prototype.setText=function(text){
    //wow, is this a hacky mess!
    
    this.text=text;
    this.lines=[];
    var nlines=text.split(/\r\n|\r|\n/);
    nlines.push(' ');
    var line, words;
    var i, ci, c, l;
    var word='';
    var height=0;
    var n_line_length=0;
    var n_line='';
    for(i=0;i<nlines.length;i++){
        line=nlines[i];
        line+=' ';
        for(ci=0;ci<line.length;ci++){
            c=line[ci];
            if(c==' ' || c=='\t'){
                if(word){
                    l=this.font.getTextSize(word)[0];
                    if((n_line_length+l>this.size[0]) && (!(n_line==''))){
                        this.lines.push({'t':n_line, 'e':false});
                        height+=this.font.getTextSize(n_line)[1];
                        n_line='';
                        n_line_length=0;
                        if(word[0]==' ' || word[0]=='\t'){
                            word=word.substr(1, word.length);
                        }
                    }
                    n_line+=word;
                    n_line_length+=l;
                    
                }
                word='';
                word+=c;
            }else{
                word+=c;
            }
        }
        if(n_line){
            this.lines.push({'t':n_line, 'e':true});
            height+=this.font.getTextSize(n_line)[1];
            n_line='';
            n_line_length=0;
        }
    }
    this.resize([this.width, height]);
    this.refresh();
};

/**
 *@function
 */
Text.prototype.paint=function(){
    View.prototype.paint.apply(this, []);
    var pos=0;
    this.lines.forEach(function(line){
        var sz=this.font.getTextSize(line.t);
        var extra_w=0;
        if(this.justify && (!line.e)){
            var space_count=0;
            for(var i=0;i<line.t.length;i++){
                if(line.t[i]==' ') space_count++;
            }
            extra_w=Math.floor((this.size[0]-sz[0])/space_count);
        }
        this.font.render(this.surface, line.t, [0, pos], this.font.space_width+extra_w);
        pos+=sz[1];
    }, this);
}

/**
 *@class root GUI object. Handles gamejs events, frames
 *@augments View
 *
 *@param {gamejs.Surface} surface surface to render GUI on
 */
var GUI=exports.GUI=function(surface){
    GUI.superConstructor.apply(this, [{'position':[0, 0],
                                      'parent':null,
                                      'size':surface.getSize(),
                                      'surface':surface}]);
    this.type='gui';
    this.locked_frame=null;
    this.frames=[];
};

gamejs.utils.objects.extend(GUI, View);

/**
 *redraw GUI, if needed
 *@function
 *@param {Bool} force_redraw if true GUI is redrawn even if tehre are no internal changes
 */
GUI.prototype.draw=function(force_redraw){
    if(force_redraw)this.refresh();
    var painted=View.prototype.draw.apply(this, []);
    this.frames.forEach(function(frame){
        if(frame.visible && (frame.draw() || painted)){
            if(this.locked_frame && (this.locked_frame.id==frame.id)){
                this.refresh();
                this.blur_bg();
            }
            this.surface.blit(frame.surface, frame.position);
        }
    }, this);
};

/**
 *Does nothing! don't remove!
 *@function
 */
GUI.prototype.paint=function(){};

GUI.prototype.blur_bg=function(){
    gamejs.draw.rect(this.surface, 'rgba(192,192, 192, 0.5)', new gamejs.Rect([0, 0], this.size),0); 
};

/**
 *Remove a frame from GUI
 *@function
 *@param {Frame|Id} frame frame object or id of frame to remove
 */

GUI.prototype.removeFrame=function(frame){
    if(typeof(frame)!='number')frame=frame.id;
    for(var i=0;i<this.frames.length;i++){
        if(this.frames[i].id==frame){
            frame=this.frames.splice(i, 1);
            this.refresh();
            return true;
        }
    }
    return false;
};

/**
 *Move a frame to the top
 *@function
 *@param {Frame} frame
 */
GUI.prototype.moveFrameToTop=function(frame){   
    for(var i=0;i<this.frames.length;i++){
        var f=this.frames[i];
        if(f.id==frame.id){
            if(i==this.frames.length-1) return;
            this.despatchEvent({'type':EVT_BLUR});
            this.frames.splice(i, 1);
            this.frames.push(f);
            this.refresh();
            frame.despatchEvent({'type':EVT_FOCUS});
            break;
        }
    }
};

/**
 *Update GUI and its child objects
 *@function
 *@param {Number} msDuration miliseconds since last update
 */
GUI.prototype.update=function(msDuration){
    this.children.forEach(function(child){
        child._update(msDuration);  
    });
    this.frames.forEach(function(frame){
        frame._update(msDuration);  
    });
    
};

/**
 *@ignore
 */
GUI.prototype.lockFrame=function(frame){
    this.locked_frame=frame;
    this.refresh();
};

/**
 *@ignore
 */
GUI.prototype.unlockFrame=function(){
    this.locked_frame=null;
    this.refresh();
};

/**
 *despatch gamejs event
 *@function
 *@param {gamejs Event| GUI event} event event generated by gamejs, or a GUI event if needed.
 */
GUI.prototype.despatchEvent=function(event){
    if(event.pos)event.global_pos=event.pos;
    
    var i, frame;
    //dispatching mouse events to frames: if event is dispatched to a frame, don't dispatch it anywhere else.
    if(event.type==EVT_MOUSE_DOWN || event.type==EVT_MOUSE_MOTION || event.type==EVT_MOUSE_UP){
        var frame;
        var hit=false;
        var clicked_on=null;
        var moused_on=null;
        var topframe=null;
        for(i=this.frames.length-1; i>=0;i--){
            frame=this.frames[i];
            
            //if frame is locked, dispatch events only to that frame
            if(this.locked_frame &&(this.locked_frame.id!=frame.id)) continue;
            
            if(frame.visible && frame.getRect().collidePoint(event.pos)){
                frame.despatchEvent(cloneEvent(event, frame.position));
                if(event.type==EVT_MOUSE_DOWN){
                    clicked_on=i;
                }
                else if(event.type==EVT_MOUSE_MOTION){
                    moused_on=i;
                }
                hit=true;
                //mouseout view if mouse is on a frame
                if(frame.isFocused())topframe=i;
                break;
            }else{
                //blur frame if focused but clicked somewhere else
                if((event.type==EVT_MOUSE_DOWN) && (frame.isFocused())){
                    frame.despatchEvent({'type':EVT_BLUR});
                }
            }
        }
        
        //blur everything else if clicked on a frame
        if(clicked_on!=null){
            View.prototype.despatchEvent.apply(this, [{'type':EVT_BLUR}]);
            for(i=0;i<this.frames.length;i++){
                if(i!=clicked_on) this.frames[i].despatchEvent({'type':EVT_BLUR});
            }
        }
         
        //mouseout everyhting else if clicked on a frame
        if(moused_on!=null){
            View.prototype.despatchEvent.apply(this, [{'type':EVT_MOUSE_OUT}]);
            for(i=0;i<this.frames.length;i++){
                if(i!=moused_on) this.frames[i].despatchEvent({'type':EVT_MOUSE_OUT});
            } 
        }
        
        if(!hit &&(!this.locked_frame)){
            View.prototype.despatchEvent.apply(this, [event]);
        }
        else{
            View.prototype.handleEvent.apply(this, [event]);
        }
        
        if(topframe!=null){
            this.moveFrameToTop(this.frames[topframe]);      
        }
        
    }else{
        if(event.type==EVT_BLUR || event.type==EVT_MOUSE_OUT || event.type==EVT_KEY_DOWN || event.type==EVT_KEY_UP){
            this.frames.forEach(function(frame){
                if(frame.visible &&(!this.locked_frame || (this.locked_frame.id==frame.id))){
                    frame.despatchEvent(cloneEvent(event, frame.position));
                }
            });  
        }
        
        if(!this.locked_frame) View.prototype.despatchEvent.apply(this, [event]);
        else View.prototype.handleEvent.apply(this, [event]);
    }
};

var layout=exports.layout={

/**
 *arranges obejcts vertically
 *@function
 *@name vertical
 *@lends layout
 *@param {Array} objects a list of gui objects (with the same parent)
 *@param {Number} y starting y coordinate, default 0
 *@param {Number} space space between objects px, default 0
 */
'vertical':function(objects, y, space){
        y=y || 0;
        space = space || 0;
        objects.forEach(function(object){
            object.move([object.position[0], y]);
            y+=object.size[1]+space;
        });
        
    },

/**
 *arranges obejcts horizontally
 *@function
 *@name horizontal
 *@lends layout
 *@param {Array} objects a list of gui objects (with the same parent)
 *@param {Number} x startingx coordinate, default 0
 *@param {Number} space space between objects px, default 0
 */
'horizontal':function(objects, x, space){
        x=x || 0;
        space = space || 0;
        objects.forEach(function(object){
            object.move([x, object.position[1]]);
            x+=object.size[0]+space;
        });
    }
};


}}, ["gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"settings-example": function(require, exports, module) {
var settings=exports.settings={SCREEN_WIDTH:800,  //screen width in pixels
                                SCREEN_HEIGHT:600, //screen height in pixels
                                FPS:60,        //logic updates per second
                                PHYS_SCALE:10,    //pixels in a meter
                                STARTING_BALANCE:100000, //default 3000
                                MAX_INDIVIDUAL_SOUND_CHANNELS:4,
                                MAX_GLOBAL_SOUND_CHANNELS:8,
                                STARTING_LEAGUE:0,
                                SERVER:'ws://www.banditracer.eu:8000',
                                DEBUG:true,
                                SOUND:true};     //game server

exports.get=function(name){
    return settings[name];
};

exports.init=function(){
    for(var key in settings){
        if(window.hasOwnProperty(key)){
            settings[key]=window[key];
        }
    }
};

exports.set=function(name, value){
    settings[name]=value;
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"settings": function(require, exports, module) {
var settings=exports.settings={SCREEN_WIDTH:800,  //screen width in pixels
                                SCREEN_HEIGHT:600, //screen height in pixels
                                FPS:60,        //logic updates per second
                                PHYS_SCALE:10,    //pixels in a meter
                                STARTING_BALANCE:100000, //default 3000
                                STARTING_LEAGUE:0,
                                SERVER:'ws://localhost:8001',
                                DEBUG:false,
                                SOUND:false,
                                ENGINE_SOUND:false};     //game server

exports.get=function(name){
    return settings[name];
};

exports.init=function(){
    for(var key in settings){
        if(window.hasOwnProperty(key)){
            settings[key]=window[key];
        }
    }
};

exports.set=function(name, value){
    settings[name]=value;
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"engine/world": function(require, exports, module) {
var box2d = require('./box2d');
var game = require('./game');
var sound = require('./sound');

var gamejs = require('gamejs');
var vectors = gamejs.utils.vectors;

var math = gamejs.utils.math;
var radians=math.radians;
var degrees=math.degrees;

var utils = require('./utils');
var arr = utils.arr;
var vec = utils.vec;


var ContactListener = function(world) {
    this.world = world;
    this.BeginContact = function(cpoint) {
        var body1 = cpoint.GetFixtureA().GetBody();
        var body2 = cpoint.GetFixtureB().GetBody();
        var obj1 = body1.GetUserData();
        var obj2 = body2.GetUserData();
        if(obj1 && obj2) {
            var manifold = new box2d.b2WorldManifold();
            cpoint.GetWorldManifold(manifold);
            var normal = arr(manifold.m_normal);
            world._register_impact(obj1, obj2, cpoint, normal);
            world._register_impact(obj2, obj1, cpoint, vectors.rotate(normal, radians(180)));
        }
    };

    this.EndContact = function() {
    };
    this.PreSolve = function() {
    };
    this.PostSolve = function() {
    };
    return this;
};



var World = exports.World = function(parameters){
    this._next_object_id = 0;
    this._next_event_id = 0;
    
    this._events = {};
    this._impacts = [];
    this.objects = {};
    this.objects_by_tag= {};
    
 
    var parlist = [['gravity', [0, 0]]];


    utils.process_parameters(parameters, parlist);
    
    this.parameters = parameters;
    
    this.b2world=new box2d.b2World(vec(parameters.gravity), false);
    this.b2world.SetContactListener(new ContactListener(this));
};

World.prototype._register_impact = function(obj1, obj2, cpoint, normal){
    this._impacts.push([obj1, obj2, cpoint, normal]);
};

World.prototype._process_impacts = function(){
    while(this._impacts.length){
        var d = this._impacts.pop();
        d[0].impact(d[1], d[2], d[3]);
    };
    
    this._impacts = [];
};


World.prototype._register_event = function(event_type, parameters){
    var event = {
                    'type':event_type,
                    'data':parameters,
                    'id':this._next_event_id++
    };
    
   // this._events[event.id] = event;
    
    //TODO: multiplayerify
    return this._process_event(event);
    
};

World.prototype._create_body = function(def){
    return this.b2world.CreateBody(def);
};

World.prototype._destroy_body = function(body){
    this.b2world.DestroyBody(body);
};

World.prototype._process_event = function(event) {
    if(event.type == 'create') {
        var pars = utils.copy(event.data, {});
        pars.world = this;
        pars.id = this._next_object_id++;
        for(var key in pars) {
            if((pars[key] + '').search('_o_') == 0) {
                var id = parseInt(pars[key].replace('_o_', ''));
                pars[key] = this.get_object(id);
            }
        }
        var fn = game.get_class_by_id(pars.class_id);
        var obj = new fn(pars);
        for(var tag in obj._tags) {
            if(!this.objects_by_tag[tag]) {
                this.objects_by_tag[tag] = [];
            }
            this.objects_by_tag[tag].push(obj);
        }
        obj.on_create();
        return obj;
    } else {
        this._destroy(this.get_object(event.data));
    }
};

World.prototype.get_object = function(id){
    var retv = this.objects[id];
    if(! retv) throw 'Uh oh. Unknown object id= '+id;
    return retv;
};

World.prototype.get_objects_by_tag = function(tag){
    if(this.objects_by_tag[tag]) return this.objects_by_tag[tag];
    return [];
};

World.prototype._destroy = function(obj){
    obj.die();
    delete this.objects[obj.id];
    
    //remove impacts for this object
    var n_impacts = [];
    this._impacts.forEach(function(impact){
        if(!(impact[0].id == obj.id || impact[1].id == obj.id )){
            n_impacts.push(impact);
        }
    });
    this._impacts = n_impacts;
    
    if(obj.body) this._destroy_body(obj.body);
    for(var tag in obj._tags){
        for(var i = 0; i < this.objects_by_tag[tag].length; i++) {
            if(this.objects_by_tag[tag][i].id == obj.id) {
                this.objects_by_tag[tag].splice(i, 1);
                break;
            }
        }
    }
};

World.prototype.create = function(fn, parameters){
    parameters.class_id = game.get_id_by_class(fn);
    for (var key in parameters){
        if(parameters[key] && parameters[key].AM_OBJECT){
            parameters[key] = '_o_' + parameters[key].id;
        }
    }
    return this._register_event('create', parameters);
};

World.prototype.destroy = function(entity){
    this._register_event('destroy', entity.id);
};

World.prototype.update = function(msDuration){
    this._process_impacts();
    for(var id in this.objects){
        this.objects[id].update(msDuration);
    }
};

World.prototype.draw = function(renderer){
    for(var id in this.objects){
        var obj = this.objects[id];
        obj.draw(renderer);
    }
};

World.prototype.play_sound = function(filename, position){
    this.create(sound.SoundObject, {'filename':filename, 'position':position});
};

}}, ["engine/box2d", "engine/game", "engine/sound", "gamejs", "engine/utils"]);/* This file has been generated by yabbler.js */
require.define({
"engine/entity": function(require, exports, module) {
var log = require('./logging');
var box2d = require('./box2d');
var object = require('./object');
var utils = require('./utils');

var gamejs = require('gamejs');
var vectors = gamejs.utils.vectors;

var math = gamejs.utils.math;
var radians=math.radians;
var degrees=math.degrees;

var utils = require('./utils');
var arr = utils.arr;
var vec = utils.vec;

var Entity = exports.Entity = function(parameters){

    var par_list = [    
                        'position',
                        'size',
                        ['angle',           0],
                        ['max_health',      0],
                        ['fixed_rotation',  false],
                        ['density',         1],
                        ['restitution',     0.4],
                        ['friction',        0.3],
                        ['linear_damping',  0.15],
                        ['angular_damping', 0.3],
                        ['bullet',          false],
                        ['body_type',       box2d.b2Body.b2_dynamicBody],
                        ['sensor',          false],
                        ['alive',           true]
                   ];
               
    utils.process_parameters(parameters, par_list);
    
    Entity.superConstructor.apply(this, [parameters]);
    
    this.add_tag('entity');
    
    if(this.parameters.sensor) this.add_tag('sensor');
    else this.add_tag('solid');
    
    this.health = this.max_health = this.parameters.max_health;
    this.alive = this.parameters.alive;
    this.buffs = [];
    this._next_buff_id = 1;
    
    if(this.parameters.angle == undefined || this.parameters.angle == null) throw 'Invaldi angle';
    if(isNaN(this.parameters.position[0]) || isNaN(this.parameters.position[1])) throw 'Invalid position: '+this.parameters.position;
    
    this.initialize_body();
    
    gamejs.utils.objects.accessor(this, 'position', this.get_position, this.set_position);
    gamejs.utils.objects.accessor(this, 'angle',    this.get_angle,    this.set_angle); 
};

gamejs.utils.objects.extend(Entity, object.Object);

Entity.prototype.initialize_body = function() {
    var def = new box2d.b2BodyDef();
    def.type = this.parameters.body_type;
    def.position = vec(this.parameters.position);

    //QUIRK setting a rounded angle causes wobbling for a few moments
    // on this box2d version

    def.angle = radians(this.parameters.angle + 0.00001);
    def.linearDamping = this.parameters.linear_damping;
    def.angularDamping = this.parameters.angular_damping;
    def.bullet = this.parameters.bullet;
    def.fixedRotation = this.parameters.fixed_rotation;
    this.body = this.world._create_body(def);
    this.body.SetUserData(this);

    var fixdef = new box2d.b2FixtureDef();
    fixdef.density = this.parameters.density;
    fixdef.friction = this.parameters.friction;
    fixdef.isSensor = this.parameters.sensor;
    //friction when rubbing agaisnt other shapes
    fixdef.restitution = this.parameters.restitution;
    //amount of force feedback when hitting something. >0 makes the car bounce off, it's fun!
    fixdef.shape = this.initialize_shape();
    this.body.CreateFixture(fixdef);
};

Entity.prototype.initialize_shape = function (){
    var shape = new box2d.b2PolygonShape();
    shape.SetAsBox(this.parameters.size[0] / 2, this.parameters.size[1] / 2);
    return shape;
};

Entity.prototype.get_position = function(){
    return arr(this.body.GetPosition());
};

Entity.prototype.set_position = function(position){
    this.body.SetPosition(vec(position));
};

Entity.prototype.get_angle = function(){
    return degrees(this.body.GetAngle());
};

Entity.prototype.set_angle = function(angle){
    this.body.SetAngle(radians(angle));
};

Entity.prototype.set_linear_velocity = function(velocity) {
    this.body.SetLinearVelocity(vec(velocity));
};

Entity.prototype.get_linear_velocity = function(local_point){
    if(local_point){
        return arr(this.body.GetLinearVelocityFromLocalPoint(vec(local_point)));
    } else {
        return  arr(this.body.GetLinearVelocity());
    }
};
/*
 * 
 *speed in kilometers per hour
 * 
 */
Entity.prototype.set_speed = function(speed){
    velocity = vectors.multiply(vectors.unit(this.get_direction_vector()), ((speed*1000.0)/3600.0));
    this.set_linear_velocity(velocity);
};

Entity.prototype.impact = function(object, cpoint, direction){
      
};

Entity.prototype.destroy = function(){
    this.world.destroy(this);
};

Entity.prototype.apply_damage = function(damage, player){
    this.health -= damage;
    if(this.health < 0){
        this.die();
    }
};

Entity.prototype.get_world_point = function(local_point){
    return arr(this.body.GetWorldPoint(vec(local_point)));
};

Entity.prototype.get_local_point = function(world_point){
    return arr(this.body.GetLocalPoint(vec(world_point)));
};

Entity.prototype.get_world_vector = function(local_vector){
    return arr(this.body.GetWorldVector(vec(local_vector)));
};

Entity.prototype.get_local_vector = function(world_vector){
    return arr(this.body.GetLocalVector(vec(world_vector)));
};

Entity.prototype.get_local_velocity = function(local_point){
    if(local_point == undefined) local_point = [0, 0];
    return arr(this.body.GetLinearVelocityFromLocalPoint(vec(local_point)));
};

Entity.prototype.get_mass = function(){
    return this.body.GetMass();
};

Entity.prototype.get_sideways_vector = function(){
    return this.get_world_vector([-1, 0]);
};

Entity.prototype.get_direction_vector = function(){
    return vectors.rotate( (this.get_local_vector(this.get_local_velocity())[1]>0) ? [0, 1]:[0, -1] , this.body.GetAngle()) ;
};

Entity.prototype.get_backward_direction_vector = function(){
    return vectors.rotate( (this.get_local_velocity()[1]>0) ? [0, -1]:[0, 1] , this.body.GetAngle()) ;
};

Entity.prototype.get_world_center = function(){
    return arr(this.body.GetWorldCenter());
};

Entity.prototype.apply_force = function(local_force_vector, local_position){
    this.body.ApplyForce(vec(this.get_world_vector(local_force_vector)), vec(this.get_world_point(local_position)));
};

Entity.prototype.apply_impulse = function(force_vector, position) {
    this.body.ApplyImpulse(vec(force_vector), vec(position));
};
}}, ["engine/logging", "engine/box2d", "engine/object", "engine/utils", "gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"engine/game": function(require, exports, module) {


exports._next_class_id = 1;

exports._registered_classes = {};

exports.register_class = function(fn){
    exports._registered_classes[exports._next_class_id++] = fn;
};

exports.get_class_by_id = function(id){
    if(id in exports._registered_classes){
        return exports._registered_classes[id];
    }else{
        throw 'Unknown class for id: '% id;
    }
};

exports.get_id_by_class = function(fn){
    for(var id in exports._registered_classes){
        if(fn === exports._registered_classes[id]) return id;
    }
    throw 'No id for class!'
};

}}, []);/* This file has been generated by yabbler.js */
require.define({
"engine/box2d": function(require, exports, module) {
/*
* Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*
*  Modified by Domas Lapinskas on 2011:
*  Box2D global and some aliases added to exports varibale to make this
*  a commonjs module
*
* 
*/
var Box2D = {};

(function (a2j, undefined) {

   if(!(Object.prototype.defineProperty instanceof Function)
      && Object.prototype.__defineGetter__ instanceof Function
      && Object.prototype.__defineSetter__ instanceof Function)
   {
      Object.defineProperty = function(obj, p, cfg) {
         if(cfg.get instanceof Function)
            obj.__defineGetter__(p, cfg.get);
         if(cfg.set instanceof Function)
            obj.__defineSetter__(p, cfg.set);
      }
   }
   
   function emptyFn() {};
   a2j.inherit = function(cls, base) {
      var tmpCtr = cls;
      emptyFn.prototype = base.prototype;
      cls.prototype = new emptyFn;
      cls.prototype.constructor = tmpCtr;
   };
   
   a2j.generateCallback = function generateCallback(context, cb) {
      return function () {
         cb.apply(context, arguments);
      };
   };
   
   a2j.NVector = function NVector(length) {
      if (length === undefined) length = 0;
      var tmp = new Array(length || 0);
      for (var i = 0; i < length; ++i)
      tmp[i] = 0;
      return tmp;
   };
   
   a2j.is = function is(o1, o2) {
      if (o1 === null) return false;
      if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
      if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
      return false;
   };
   
   a2j.parseUInt = function(v) {
      return Math.abs(parseInt(v));
   }
   
})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
   Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

   function b2AABB() {
      b2AABB.b2AABB.apply(this, arguments);
   };
   Box2D.Collision.b2AABB = b2AABB;

   function b2Bound() {
      b2Bound.b2Bound.apply(this, arguments);
   };
   Box2D.Collision.b2Bound = b2Bound;

   function b2BoundValues() {
      b2BoundValues.b2BoundValues.apply(this, arguments);
      if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
   };
   Box2D.Collision.b2BoundValues = b2BoundValues;

   function b2Collision() {
      b2Collision.b2Collision.apply(this, arguments);
   };
   Box2D.Collision.b2Collision = b2Collision;

   function b2ContactID() {
      b2ContactID.b2ContactID.apply(this, arguments);
      if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
   };
   Box2D.Collision.b2ContactID = b2ContactID;

   function b2ContactPoint() {
      b2ContactPoint.b2ContactPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ContactPoint = b2ContactPoint;

   function b2Distance() {
      b2Distance.b2Distance.apply(this, arguments);
   };
   Box2D.Collision.b2Distance = b2Distance;

   function b2DistanceInput() {
      b2DistanceInput.b2DistanceInput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceInput = b2DistanceInput;

   function b2DistanceOutput() {
      b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

   function b2DistanceProxy() {
      b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

   function b2DynamicTree() {
      b2DynamicTree.b2DynamicTree.apply(this, arguments);
      if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTree = b2DynamicTree;

   function b2DynamicTreeBroadPhase() {
      b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

   function b2DynamicTreeNode() {
      b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

   function b2DynamicTreePair() {
      b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

   function b2Manifold() {
      b2Manifold.b2Manifold.apply(this, arguments);
      if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
   };
   Box2D.Collision.b2Manifold = b2Manifold;

   function b2ManifoldPoint() {
      b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
      if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

   function b2Point() {
      b2Point.b2Point.apply(this, arguments);
   };
   Box2D.Collision.b2Point = b2Point;

   function b2RayCastInput() {
      b2RayCastInput.b2RayCastInput.apply(this, arguments);
      if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastInput = b2RayCastInput;

   function b2RayCastOutput() {
      b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

   function b2Segment() {
      b2Segment.b2Segment.apply(this, arguments);
   };
   Box2D.Collision.b2Segment = b2Segment;

   function b2SeparationFunction() {
      b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
   };
   Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

   function b2Simplex() {
      b2Simplex.b2Simplex.apply(this, arguments);
      if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
   };
   Box2D.Collision.b2Simplex = b2Simplex;

   function b2SimplexCache() {
      b2SimplexCache.b2SimplexCache.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexCache = b2SimplexCache;

   function b2SimplexVertex() {
      b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

   function b2TimeOfImpact() {
      b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
   };
   Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

   function b2TOIInput() {
      b2TOIInput.b2TOIInput.apply(this, arguments);
   };
   Box2D.Collision.b2TOIInput = b2TOIInput;

   function b2WorldManifold() {
      b2WorldManifold.b2WorldManifold.apply(this, arguments);
      if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
   };
   Box2D.Collision.b2WorldManifold = b2WorldManifold;

   function ClipVertex() {
      ClipVertex.ClipVertex.apply(this, arguments);
   };
   Box2D.Collision.ClipVertex = ClipVertex;

   function Features() {
      Features.Features.apply(this, arguments);
   };
   Box2D.Collision.Features = Features;

   function b2CircleShape() {
      b2CircleShape.b2CircleShape.apply(this, arguments);
      if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

   function b2EdgeChainDef() {
      b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
      if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

   function b2EdgeShape() {
      b2EdgeShape.b2EdgeShape.apply(this, arguments);
      if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

   function b2MassData() {
      b2MassData.b2MassData.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2MassData = b2MassData;

   function b2PolygonShape() {
      b2PolygonShape.b2PolygonShape.apply(this, arguments);
      if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

   function b2Shape() {
      b2Shape.b2Shape.apply(this, arguments);
      if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2Shape = b2Shape;
   Box2D.Common.b2internal = 'Box2D.Common.b2internal';

   function b2Color() {
      b2Color.b2Color.apply(this, arguments);
      if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
   };
   Box2D.Common.b2Color = b2Color;

   function b2Settings() {
      b2Settings.b2Settings.apply(this, arguments);
   };
   Box2D.Common.b2Settings = b2Settings;

   function b2Mat22() {
      b2Mat22.b2Mat22.apply(this, arguments);
      if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat22 = b2Mat22;

   function b2Mat33() {
      b2Mat33.b2Mat33.apply(this, arguments);
      if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat33 = b2Mat33;

   function b2Math() {
      b2Math.b2Math.apply(this, arguments);
   };
   Box2D.Common.Math.b2Math = b2Math;

   function b2Sweep() {
      b2Sweep.b2Sweep.apply(this, arguments);
   };
   Box2D.Common.Math.b2Sweep = b2Sweep;

   function b2Transform() {
      b2Transform.b2Transform.apply(this, arguments);
      if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
   };
   Box2D.Common.Math.b2Transform = b2Transform;

   function b2Vec2() {
      b2Vec2.b2Vec2.apply(this, arguments);
      if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec2 = b2Vec2;

   function b2Vec3() {
      b2Vec3.b2Vec3.apply(this, arguments);
      if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec3 = b2Vec3;

   function b2Body() {
      b2Body.b2Body.apply(this, arguments);
      if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
   };
   Box2D.Dynamics.b2Body = b2Body;

   function b2BodyDef() {
      b2BodyDef.b2BodyDef.apply(this, arguments);
      if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2BodyDef = b2BodyDef;

   function b2ContactFilter() {
      b2ContactFilter.b2ContactFilter.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

   function b2ContactImpulse() {
      b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

   function b2ContactListener() {
      b2ContactListener.b2ContactListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactListener = b2ContactListener;

   function b2ContactManager() {
      b2ContactManager.b2ContactManager.apply(this, arguments);
      if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactManager = b2ContactManager;

   function b2DebugDraw() {
      b2DebugDraw.b2DebugDraw.apply(this, arguments);
      if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
   };
   Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

   function b2DestructionListener() {
      b2DestructionListener.b2DestructionListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

   function b2FilterData() {
      b2FilterData.b2FilterData.apply(this, arguments);
   };
   Box2D.Dynamics.b2FilterData = b2FilterData;

   function b2Fixture() {
      b2Fixture.b2Fixture.apply(this, arguments);
      if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
   };
   Box2D.Dynamics.b2Fixture = b2Fixture;

   function b2FixtureDef() {
      b2FixtureDef.b2FixtureDef.apply(this, arguments);
      if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

   function b2Island() {
      b2Island.b2Island.apply(this, arguments);
      if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
   };
   Box2D.Dynamics.b2Island = b2Island;

   function b2TimeStep() {
      b2TimeStep.b2TimeStep.apply(this, arguments);
   };
   Box2D.Dynamics.b2TimeStep = b2TimeStep;

   function b2World() {
      b2World.b2World.apply(this, arguments);
      if (this.constructor === b2World) this.b2World.apply(this, arguments);
   };
   Box2D.Dynamics.b2World = b2World;

   function b2CircleContact() {
      b2CircleContact.b2CircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

   function b2Contact() {
      b2Contact.b2Contact.apply(this, arguments);
      if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2Contact = b2Contact;

   function b2ContactConstraint() {
      b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
      if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

   function b2ContactConstraintPoint() {
      b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

   function b2ContactEdge() {
      b2ContactEdge.b2ContactEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

   function b2ContactFactory() {
      b2ContactFactory.b2ContactFactory.apply(this, arguments);
      if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

   function b2ContactRegister() {
      b2ContactRegister.b2ContactRegister.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

   function b2ContactResult() {
      b2ContactResult.b2ContactResult.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

   function b2ContactSolver() {
      b2ContactSolver.b2ContactSolver.apply(this, arguments);
      if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

   function b2EdgeAndCircleContact() {
      b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

   function b2NullContact() {
      b2NullContact.b2NullContact.apply(this, arguments);
      if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

   function b2PolyAndCircleContact() {
      b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

   function b2PolyAndEdgeContact() {
      b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

   function b2PolygonContact() {
      b2PolygonContact.b2PolygonContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

   function b2PositionSolverManifold() {
      b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
      if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

   function b2BuoyancyController() {
      b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

   function b2ConstantAccelController() {
      b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

   function b2ConstantForceController() {
      b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

   function b2Controller() {
      b2Controller.b2Controller.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2Controller = b2Controller;

   function b2ControllerEdge() {
      b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

   function b2GravityController() {
      b2GravityController.b2GravityController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

   function b2TensorDampingController() {
      b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

   function b2DistanceJoint() {
      b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
      if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

   function b2DistanceJointDef() {
      b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
      if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

   function b2FrictionJoint() {
      b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
      if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

   function b2FrictionJointDef() {
      b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
      if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

   function b2GearJoint() {
      b2GearJoint.b2GearJoint.apply(this, arguments);
      if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

   function b2GearJointDef() {
      b2GearJointDef.b2GearJointDef.apply(this, arguments);
      if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

   function b2Jacobian() {
      b2Jacobian.b2Jacobian.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

   function b2Joint() {
      b2Joint.b2Joint.apply(this, arguments);
      if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Joint = b2Joint;

   function b2JointDef() {
      b2JointDef.b2JointDef.apply(this, arguments);
      if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

   function b2JointEdge() {
      b2JointEdge.b2JointEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

   function b2LineJoint() {
      b2LineJoint.b2LineJoint.apply(this, arguments);
      if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

   function b2LineJointDef() {
      b2LineJointDef.b2LineJointDef.apply(this, arguments);
      if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

   function b2MouseJoint() {
      b2MouseJoint.b2MouseJoint.apply(this, arguments);
      if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

   function b2MouseJointDef() {
      b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
      if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

   function b2PrismaticJoint() {
      b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
      if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

   function b2PrismaticJointDef() {
      b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
      if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

   function b2PulleyJoint() {
      b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
      if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

   function b2PulleyJointDef() {
      b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
      if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

   function b2RevoluteJoint() {
      b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
      if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

   function b2RevoluteJointDef() {
      b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
      if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

   function b2WeldJoint() {
      b2WeldJoint.b2WeldJoint.apply(this, arguments);
      if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

   function b2WeldJointDef() {
      b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
      if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   b2AABB.b2AABB = function () {
      this.lowerBound = new b2Vec2();
      this.upperBound = new b2Vec2();
   };
   b2AABB.prototype.IsValid = function () {
      var dX = this.upperBound.x - this.lowerBound.x;
      var dY = this.upperBound.y - this.lowerBound.y;
      var valid = dX >= 0.0 && dY >= 0.0;
      valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
      return valid;
   }
   b2AABB.prototype.GetCenter = function () {
      return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
   }
   b2AABB.prototype.GetExtents = function () {
      return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
   }
   b2AABB.prototype.Contains = function (aabb) {
      var result = true;
      result = result && this.lowerBound.x <= aabb.lowerBound.x;
      result = result && this.lowerBound.y <= aabb.lowerBound.y;
      result = result && aabb.upperBound.x <= this.upperBound.x;
      result = result && aabb.upperBound.y <= this.upperBound.y;
      return result;
   }
   b2AABB.prototype.RayCast = function (output, input) {
      var tmin = (-Number.MAX_VALUE);
      var tmax = Number.MAX_VALUE;
      var pX = input.p1.x;
      var pY = input.p1.y;
      var dX = input.p2.x - input.p1.x;
      var dY = input.p2.y - input.p1.y;
      var absDX = Math.abs(dX);
      var absDY = Math.abs(dY);
      var normal = output.normal;
      var inv_d = 0;
      var t1 = 0;
      var t2 = 0;
      var t3 = 0;
      var s = 0; {
         if (absDX < Number.MIN_VALUE) {
            if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
         }
         else {
            inv_d = 1.0 / dX;
            t1 = (this.lowerBound.x - pX) * inv_d;
            t2 = (this.upperBound.x - pX) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.x = s;
               normal.y = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      } {
         if (absDY < Number.MIN_VALUE) {
            if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
         }
         else {
            inv_d = 1.0 / dY;
            t1 = (this.lowerBound.y - pY) * inv_d;
            t2 = (this.upperBound.y - pY) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.y = s;
               normal.x = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      }
      output.fraction = tmin;
      return true;
   }
   b2AABB.prototype.TestOverlap = function (other) {
      var d1X = other.lowerBound.x - this.upperBound.x;
      var d1Y = other.lowerBound.y - this.upperBound.y;
      var d2X = this.lowerBound.x - other.upperBound.x;
      var d2Y = this.lowerBound.y - other.upperBound.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   b2AABB.Combine = function (aabb1, aabb2) {
      var aabb = new b2AABB();
      aabb.Combine(aabb1, aabb2);
      return aabb;
   }
   b2AABB.prototype.Combine = function (aabb1, aabb2) {
      this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
      this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
      this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
      this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
   }
   b2Bound.b2Bound = function () {};
   b2Bound.prototype.IsLower = function () {
      return (this.value & 1) == 0;
   }
   b2Bound.prototype.IsUpper = function () {
      return (this.value & 1) == 1;
   }
   b2Bound.prototype.Swap = function (b) {
      var tempValue = this.value;
      var tempProxy = this.proxy;
      var tempStabbingCount = this.stabbingCount;
      this.value = b.value;
      this.proxy = b.proxy;
      this.stabbingCount = b.stabbingCount;
      b.value = tempValue;
      b.proxy = tempProxy;
      b.stabbingCount = tempStabbingCount;
   }
   b2BoundValues.b2BoundValues = function () {};
   b2BoundValues.prototype.b2BoundValues = function () {
      this.lowerValues = new Vector_a2j_Number();
      this.lowerValues[0] = 0.0;
      this.lowerValues[1] = 0.0;
      this.upperValues = new Vector_a2j_Number();
      this.upperValues[0] = 0.0;
      this.upperValues[1] = 0.0;
   }
   b2Collision.b2Collision = function () {};
   b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
      if (offset === undefined) offset = 0;
      var cv;
      var numOut = 0;
      cv = vIn[0];
      var vIn0 = cv.v;
      cv = vIn[1];
      var vIn1 = cv.v;
      var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
      var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
      if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
      if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
      if (distance0 * distance1 < 0.0) {
         var interp = distance0 / (distance0 - distance1);
         cv = vOut[numOut];
         var tVec = cv.v;
         tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
         tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
         cv = vOut[numOut];
         var cv2;
         if (distance0 > 0.0) {
            cv2 = vIn[0];
            cv.id = cv2.id;
         }
         else {
            cv2 = vIn[1];
            cv.id = cv2.id;
         }++numOut;
      }
      return numOut;
   }
   b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
      var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = vertices2[i];
         var dot = tVec.x * normal1X + tVec.y * normal1Y;
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      tVec = vertices1[edge1];
      tMat = xf1.R;
      var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = vertices2[index];
      tMat = xf2.R;
      var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      v2X -= v1X;
      v2Y -= v1Y;
      var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
      return separation;
   }
   b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = poly2.m_centroid;
      var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf1.R;
      tVec = poly1.m_centroid;
      dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
      var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
      var edge = 0;
      var maxDot = (-Number.MAX_VALUE);
      for (var i = 0; i < count1; ++i) {
         tVec = normals1[i];
         var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
         if (dot > maxDot) {
            maxDot = dot;
            edge = i;
         }
      }
      var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
      var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
      var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
      var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
      var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
      var bestEdge = 0;
      var bestSeparation = 0;
      var increment = 0;
      if (sPrev > s && sPrev > sNext) {
         increment = (-1);
         bestEdge = prevEdge;
         bestSeparation = sPrev;
      }
      else if (sNext > s) {
         increment = 1;
         bestEdge = nextEdge;
         bestSeparation = sNext;
      }
      else {
         edgeIndex[0] = edge;
         return s;
      }
      while (true) {
         if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
         else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
         if (s > bestSeparation) {
            bestEdge = edge;
            bestSeparation = s;
         }
         else {
            break;
         }
      }
      edgeIndex[0] = bestEdge;
      return bestSeparation;
   }
   b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var normals2 = poly2.m_normals;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
      normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
      normal1X = tX;
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = normals2[i];
         var dot = (normal1X * tVec.x + normal1Y * tVec.y);
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      var tClip;
      var i1 = parseInt(index);
      var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
      tClip = c[0];
      tVec = vertices2[i1];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i1;
      tClip.id.features.incidentVertex = 0;
      tClip = c[1];
      tVec = vertices2[i2];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i2;
      tClip.id.features.incidentVertex = 1;
   }
   b2Collision.MakeClipPointVector = function () {
      var r = new Vector(2);
      r[0] = new ClipVertex();
      r[1] = new ClipVertex();
      return r;
   }
   b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
      var cv;
      manifold.m_pointCount = 0;
      var totalRadius = polyA.m_radius + polyB.m_radius;
      var edgeA = 0;
      b2Collision.s_edgeAO[0] = edgeA;
      var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
      edgeA = b2Collision.s_edgeAO[0];
      if (separationA > totalRadius) return;
      var edgeB = 0;
      b2Collision.s_edgeBO[0] = edgeB;
      var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
      edgeB = b2Collision.s_edgeBO[0];
      if (separationB > totalRadius) return;
      var poly1;
      var poly2;
      var xf1;
      var xf2;
      var edge1 = 0;
      var flip = 0;
      var k_relativeTol = 0.98;
      var k_absoluteTol = 0.001;
      var tMat;
      if (separationB > k_relativeTol * separationA + k_absoluteTol) {
         poly1 = polyB;
         poly2 = polyA;
         xf1 = xfB;
         xf2 = xfA;
         edge1 = edgeB;
         manifold.m_type = b2Manifold.e_faceB;
         flip = 1;
      }
      else {
         poly1 = polyA;
         poly2 = polyB;
         xf1 = xfA;
         xf2 = xfB;
         edge1 = edgeA;
         manifold.m_type = b2Manifold.e_faceA;
         flip = 0;
      }
      var incidentEdge = b2Collision.s_incidentEdge;
      b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var local_v11 = vertices1[edge1];
      var local_v12;
      if (edge1 + 1 < count1) {
         local_v12 = vertices1[parseInt(edge1 + 1)];
      }
      else {
         local_v12 = vertices1[0];
      }
      var localTangent = b2Collision.s_localTangent;
      localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
      localTangent.Normalize();
      var localNormal = b2Collision.s_localNormal;
      localNormal.x = localTangent.y;
      localNormal.y = (-localTangent.x);
      var planePoint = b2Collision.s_planePoint;
      planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
      var tangent = b2Collision.s_tangent;
      tMat = xf1.R;
      tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
      tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
      var tangent2 = b2Collision.s_tangent2;
      tangent2.x = (-tangent.x);
      tangent2.y = (-tangent.y);
      var normal = b2Collision.s_normal;
      normal.x = tangent.y;
      normal.y = (-tangent.x);
      var v11 = b2Collision.s_v11;
      var v12 = b2Collision.s_v12;
      v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
      v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
      v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
      v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
      var frontOffset = normal.x * v11.x + normal.y * v11.y;
      var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
      var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
      var clipPoints1 = b2Collision.s_clipPoints1;
      var clipPoints2 = b2Collision.s_clipPoints2;
      var np = 0;
      np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
      if (np < 2) return;
      np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
      if (np < 2) return;
      manifold.m_localPlaneNormal.SetV(localNormal);
      manifold.m_localPoint.SetV(planePoint);
      var pointCount = 0;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
         cv = clipPoints2[i];
         var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
         if (separation <= totalRadius) {
            var cp = manifold.m_points[pointCount];
            tMat = xf2.R;
            var tX = cv.v.x - xf2.position.x;
            var tY = cv.v.y - xf2.position.y;
            cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
            cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
            cp.m_id.Set(cv.id);
            cp.m_id.features.flip = flip;
            ++pointCount;
         }
      }
      manifold.m_pointCount = pointCount;
   }
   b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
      manifold.m_pointCount = 0;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = circle1.m_p;
      var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      tVec = circle2.m_p;
      var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var distSqr = dX * dX + dY * dY;
      var radius = circle1.m_radius + circle2.m_radius;
      if (distSqr > radius * radius) {
         return;
      }
      manifold.m_type = b2Manifold.e_circles;
      manifold.m_localPoint.SetV(circle1.m_p);
      manifold.m_localPlaneNormal.SetZero();
      manifold.m_pointCount = 1;
      manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
      manifold.m_points[0].m_id.key = 0;
   }
   b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
      manifold.m_pointCount = 0;
      var tPoint;
      var dX = 0;
      var dY = 0;
      var positionX = 0;
      var positionY = 0;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = circle.m_p;
      var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      dX = cX - xf1.position.x;
      dY = cY - xf1.position.y;
      tMat = xf1.R;
      var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
      var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
      var dist = 0;
      var normalIndex = 0;
      var separation = (-Number.MAX_VALUE);
      var radius = polygon.m_radius + circle.m_radius;
      var vertexCount = parseInt(polygon.m_vertexCount);
      var vertices = polygon.m_vertices;
      var normals = polygon.m_normals;
      for (var i = 0; i < vertexCount; ++i) {
         tVec = vertices[i];
         dX = cLocalX - tVec.x;
         dY = cLocalY - tVec.y;
         tVec = normals[i];
         var s = tVec.x * dX + tVec.y * dY;
         if (s > radius) {
            return;
         }
         if (s > separation) {
            separation = s;
            normalIndex = i;
         }
      }
      var vertIndex1 = parseInt(normalIndex);
      var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
      var v1 = vertices[vertIndex1];
      var v2 = vertices[vertIndex2];
      if (separation < Number.MIN_VALUE) {
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
         manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
         manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
         return;
      }
      var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
      var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
      if (u1 <= 0.0) {
         if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v1.x;
         manifold.m_localPlaneNormal.y = cLocalY - v1.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v1);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else if (u2 <= 0) {
         if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v2.x;
         manifold.m_localPlaneNormal.y = cLocalY - v2.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v2);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else {
         var faceCenterX = 0.5 * (v1.x + v2.x);
         var faceCenterY = 0.5 * (v1.y + v2.y);
         separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
         if (separation > radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
         manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.Set(faceCenterX, faceCenterY);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
   }
   b2Collision.TestOverlap = function (a, b) {
      var t1 = b.lowerBound;
      var t2 = a.upperBound;
      var d1X = t1.x - t2.x;
      var d1Y = t1.y - t2.y;
      t1 = a.lowerBound;
      t2 = b.upperBound;
      var d2X = t1.x - t2.x;
      var d2Y = t1.y - t2.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
      Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
      Box2D.Collision.b2Collision.s_normal = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
      Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
      Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
   });
   b2ContactID.b2ContactID = function () {
      this.features = new Features();
   };
   b2ContactID.prototype.b2ContactID = function () {
      this.features._m_id = this;
   }
   b2ContactID.prototype.Set = function (id) {
      this.key = id._key;
   }
   b2ContactID.prototype.Copy = function () {
      var id = new b2ContactID();
      id.key = this.key;
      return id;
   }
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._key;
      }
   });
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._key = value;
         this.features._referenceEdge = this._key & 0x000000ff;
         this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
         this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
         this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
      }
   });
   b2ContactPoint.b2ContactPoint = function () {
      this.position = new b2Vec2();
      this.velocity = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2Distance.b2Distance = function () {};
   b2Distance.Distance = function (output, cache, input) {
      ++b2Distance.b2_gjkCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var transformA = input.transformA;
      var transformB = input.transformB;
      var simplex = b2Distance.s_simplex;
      simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
      var vertices = simplex.m_vertices;
      var k_maxIters = 20;
      var saveA = b2Distance.s_saveA;
      var saveB = b2Distance.s_saveB;
      var saveCount = 0;
      var closestPoint = simplex.GetClosestPoint();
      var distanceSqr1 = closestPoint.LengthSquared();
      var distanceSqr2 = distanceSqr1;
      var i = 0;
      var p;
      var iter = 0;
      while (iter < k_maxIters) {
         saveCount = simplex.m_count;
         for (i = 0;
         i < saveCount; i++) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
         }
         switch (simplex.m_count) {
         case 1:
            break;
         case 2:
            simplex.Solve2();
            break;
         case 3:
            simplex.Solve3();
            break;
         default:
            b2Settings.b2Assert(false);
         }
         if (simplex.m_count == 3) {
            break;
         }
         p = simplex.GetClosestPoint();
         distanceSqr2 = p.LengthSquared();
         if (distanceSqr2 > distanceSqr1) {}
         distanceSqr1 = distanceSqr2;
         var d = simplex.GetSearchDirection();
         if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
            break;
         }
         var vertex = vertices[simplex.m_count];
         vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
         vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
         vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
         vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
         vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
         ++iter;
         ++b2Distance.b2_gjkIters;
         var duplicate = false;
         for (i = 0;
         i < saveCount; i++) {
            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
               duplicate = true;
               break;
            }
         }
         if (duplicate) {
            break;
         }++simplex.m_count;
      }
      b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
      simplex.GetWitnessPoints(output.pointA, output.pointB);
      output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
      output.iterations = iter;
      simplex.WriteCache(cache);
      if (input.useRadii) {
         var rA = proxyA.m_radius;
         var rB = proxyB.m_radius;
         if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
            output.distance -= rA + rB;
            var normal = b2Math.SubtractVV(output.pointB, output.pointA);
            normal.Normalize();
            output.pointA.x += rA * normal.x;
            output.pointA.y += rA * normal.y;
            output.pointB.x -= rB * normal.x;
            output.pointB.y -= rB * normal.y;
         }
         else {
            p = new b2Vec2();
            p.x = .5 * (output.pointA.x + output.pointB.x);
            p.y = .5 * (output.pointA.y + output.pointB.y);
            output.pointA.x = output.pointB.x = p.x;
            output.pointA.y = output.pointB.y = p.y;
            output.distance = 0.0;
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
      Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
      Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
   });
   b2DistanceInput.b2DistanceInput = function () {};
   b2DistanceOutput.b2DistanceOutput = function () {
      this.pointA = new b2Vec2();
      this.pointB = new b2Vec2();
   };
   b2DistanceProxy.b2DistanceProxy = function () {};
   b2DistanceProxy.prototype.Set = function (shape) {
      switch (shape.GetType()) {
      case b2Shape.e_circleShape:
         {
            var circle = (shape instanceof b2CircleShape ? shape : null);
            this.m_vertices = new Vector(1, true);
            this.m_vertices[0] = circle.m_p;
            this.m_count = 1;
            this.m_radius = circle.m_radius;
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var polygon = (shape instanceof b2PolygonShape ? shape : null);
            this.m_vertices = polygon.m_vertices;
            this.m_count = polygon.m_vertexCount;
            this.m_radius = polygon.m_radius;
         }
         break;
      default:
         b2Settings.b2Assert(false);
      }
   }
   b2DistanceProxy.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2DistanceProxy.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2DistanceProxy.prototype.GetVertexCount = function () {
      return this.m_count;
   }
   b2DistanceProxy.prototype.GetVertex = function (index) {
      if (index === undefined) index = 0;
      b2Settings.b2Assert(0 <= index && index < this.m_count);
      return this.m_vertices[index];
   }
   b2DynamicTree.b2DynamicTree = function () {};
   b2DynamicTree.prototype.b2DynamicTree = function () {
      this.m_root = null;
      this.m_freeList = null;
      this.m_path = 0;
      this.m_insertionCount = 0;
   }
   b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
      var node = this.AllocateNode();
      var extendX = b2Settings.b2_aabbExtension;
      var extendY = b2Settings.b2_aabbExtension;
      node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      node.aabb.upperBound.x = aabb.upperBound.x + extendX;
      node.aabb.upperBound.y = aabb.upperBound.y + extendY;
      node.userData = userData;
      this.InsertLeaf(node);
      return node;
   }
   b2DynamicTree.prototype.DestroyProxy = function (proxy) {
      this.RemoveLeaf(proxy);
      this.FreeNode(proxy);
   }
   b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
      b2Settings.b2Assert(proxy.IsLeaf());
      if (proxy.aabb.Contains(aabb)) {
         return false;
      }
      this.RemoveLeaf(proxy);
      var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
      var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
      proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
      proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
      this.InsertLeaf(proxy);
      return true;
   }
   b2DynamicTree.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      if (this.m_root == null) return;
      for (var i = 0; i < iterations; i++) {
         var node = this.m_root;
         var bit = 0;
         while (node.IsLeaf() == false) {
            node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
            bit = (bit + 1) & 31;
         }++this.m_path;
         this.RemoveLeaf(node);
         this.InsertLeaf(node);
      }
   }
   b2DynamicTree.prototype.GetFatAABB = function (proxy) {
      return proxy.aabb;
   }
   b2DynamicTree.prototype.GetUserData = function (proxy) {
      return proxy.userData;
   }
   b2DynamicTree.prototype.Query = function (callback, aabb) {
      if (this.m_root == null) return;
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(aabb)) {
            if (node.IsLeaf()) {
               var proceed = callback(node);
               if (!proceed) return;
            }
            else {
               stack[count++] = node.child1;
               stack[count++] = node.child2;
            }
         }
      }
   }
   b2DynamicTree.prototype.RayCast = function (callback, input) {
      if (this.m_root == null) return;
      var p1 = input.p1;
      var p2 = input.p2;
      var r = b2Math.SubtractVV(p1, p2);
      r.Normalize();
      var v = b2Math.CrossFV(1.0, r);
      var abs_v = b2Math.AbsV(v);
      var maxFraction = input.maxFraction;
      var segmentAABB = new b2AABB();
      var tX = 0;
      var tY = 0; {
         tX = p1.x + maxFraction * (p2.x - p1.x);
         tY = p1.y + maxFraction * (p2.y - p1.y);
         segmentAABB.lowerBound.x = Math.min(p1.x, tX);
         segmentAABB.lowerBound.y = Math.min(p1.y, tY);
         segmentAABB.upperBound.x = Math.max(p1.x, tX);
         segmentAABB.upperBound.y = Math.max(p1.y, tY);
      }
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(segmentAABB) == false) {
            continue;
         }
         var c = node.aabb.GetCenter();
         var h = node.aabb.GetExtents();
         var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
         if (separation > 0.0) continue;
         if (node.IsLeaf()) {
            var subInput = new b2RayCastInput();
            subInput.p1 = input.p1;
            subInput.p2 = input.p2;
            subInput.maxFraction = input.maxFraction;
            maxFraction = callback(subInput, node);
            if (maxFraction == 0.0) return;
            if (maxFraction > 0.0) {
               tX = p1.x + maxFraction * (p2.x - p1.x);
               tY = p1.y + maxFraction * (p2.y - p1.y);
               segmentAABB.lowerBound.x = Math.min(p1.x, tX);
               segmentAABB.lowerBound.y = Math.min(p1.y, tY);
               segmentAABB.upperBound.x = Math.max(p1.x, tX);
               segmentAABB.upperBound.y = Math.max(p1.y, tY);
            }
         }
         else {
            stack[count++] = node.child1;
            stack[count++] = node.child2;
         }
      }
   }
   b2DynamicTree.prototype.AllocateNode = function () {
      if (this.m_freeList) {
         var node = this.m_freeList;
         this.m_freeList = node.parent;
         node.parent = null;
         node.child1 = null;
         node.child2 = null;
         return node;
      }
      return new b2DynamicTreeNode();
   }
   b2DynamicTree.prototype.FreeNode = function (node) {
      node.parent = this.m_freeList;
      this.m_freeList = node;
   }
   b2DynamicTree.prototype.InsertLeaf = function (leaf) {
      ++this.m_insertionCount;
      if (this.m_root == null) {
         this.m_root = leaf;
         this.m_root.parent = null;
         return;
      }
      var center = leaf.aabb.GetCenter();
      var sibling = this.m_root;
      if (sibling.IsLeaf() == false) {
         do {
            var child1 = sibling.child1;
            var child2 = sibling.child2;
            var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
            var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
            if (norm1 < norm2) {
               sibling = child1;
            }
            else {
               sibling = child2;
            }
         }
         while (sibling.IsLeaf() == false)
      }
      var node1 = sibling.parent;
      var node2 = this.AllocateNode();
      node2.parent = node1;
      node2.userData = null;
      node2.aabb.Combine(leaf.aabb, sibling.aabb);
      if (node1) {
         if (sibling.parent.child1 == sibling) {
            node1.child1 = node2;
         }
         else {
            node1.child2 = node2;
         }
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         do {
            if (node1.aabb.Contains(node2.aabb)) break;
            node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
            node2 = node1;
            node1 = node1.parent;
         }
         while (node1)
      }
      else {
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         this.m_root = node2;
      }
   }
   b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
      if (leaf == this.m_root) {
         this.m_root = null;
         return;
      }
      var node2 = leaf.parent;
      var node1 = node2.parent;
      var sibling;
      if (node2.child1 == leaf) {
         sibling = node2.child2;
      }
      else {
         sibling = node2.child1;
      }
      if (node1) {
         if (node1.child1 == node2) {
            node1.child1 = sibling;
         }
         else {
            node1.child2 = sibling;
         }
         sibling.parent = node1;
         this.FreeNode(node2);
         while (node1) {
            var oldAABB = node1.aabb;
            node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
            if (oldAABB.Contains(node1.aabb)) break;
            node1 = node1.parent;
         }
      }
      else {
         this.m_root = sibling;
         sibling.parent = null;
         this.FreeNode(node2);
      }
   }
   b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new b2DynamicTree();
      this.m_moveBuffer = new Vector();
      this.m_pairBuffer = new Vector();
      this.m_pairCount = 0;
   };
   b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
      var proxy = this.m_tree.CreateProxy(aabb, userData);
      ++this.m_proxyCount;
      this.BufferMove(proxy);
      return proxy;
   }
   b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
      this.UnBufferMove(proxy);
      --this.m_proxyCount;
      this.m_tree.DestroyProxy(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
      var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
      if (buffer) {
         this.BufferMove(proxy);
      }
   }
   b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
      var aabbA = this.m_tree.GetFatAABB(proxyA);
      var aabbB = this.m_tree.GetFatAABB(proxyB);
      return aabbA.TestOverlap(aabbB);
   }
   b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
      return this.m_tree.GetUserData(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
      return this.m_tree.GetFatAABB(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
   }
   b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
      var __this = this;
      __this.m_pairCount = 0;
      var i = 0,
         queryProxy;
      for (i = 0;
      i < __this.m_moveBuffer.length; ++i) {
         queryProxy = __this.m_moveBuffer[i];

         function QueryCallback(proxy) {
            if (proxy == queryProxy) return true;
            if (__this.m_pairCount == __this.m_pairBuffer.length) {
               __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
            }
            var pair = __this.m_pairBuffer[__this.m_pairCount];
            pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
            pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
            return true;
         };
         var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
         __this.m_tree.Query(QueryCallback, fatAABB);
      }
      __this.m_moveBuffer.length = 0;
      for (var i = 0; i < __this.m_pairCount;) {
         var primaryPair = __this.m_pairBuffer[i];
         var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
         var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
         callback(userDataA, userDataB);
         ++i;
         while (i < __this.m_pairCount) {
            var pair = __this.m_pairBuffer[i];
            if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
               break;
            }++i;
         }
      }
   }
   b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
      this.m_tree.Query(callback, aabb);
   }
   b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
      this.m_tree.RayCast(callback, input);
   }
   b2DynamicTreeBroadPhase.prototype.Validate = function () {}
   b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      this.m_tree.Rebalance(iterations);
   }
   b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
      this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
   }
   b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
      var i = parseInt(this.m_moveBuffer.indexOf(proxy));
      this.m_moveBuffer.splice(i, 1);
   }
   b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
      return 0;
   }
   b2DynamicTreeBroadPhase.__implements = {};
   b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
   b2DynamicTreeNode.b2DynamicTreeNode = function () {
      this.aabb = new b2AABB();
   };
   b2DynamicTreeNode.prototype.IsLeaf = function () {
      return this.child1 == null;
   }
   b2DynamicTreePair.b2DynamicTreePair = function () {};
   b2Manifold.b2Manifold = function () {
      this.m_pointCount = 0;
   };
   b2Manifold.prototype.b2Manifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2ManifoldPoint();
      }
      this.m_localPlaneNormal = new b2Vec2();
      this.m_localPoint = new b2Vec2();
   }
   b2Manifold.prototype.Reset = function () {
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
      }
      this.m_localPlaneNormal.SetZero();
      this.m_localPoint.SetZero();
      this.m_type = 0;
      this.m_pointCount = 0;
   }
   b2Manifold.prototype.Set = function (m) {
      this.m_pointCount = m.m_pointCount;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
      }
      this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_type = m.m_type;
   }
   b2Manifold.prototype.Copy = function () {
      var copy = new b2Manifold();
      copy.Set(this);
      return copy;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Manifold.e_circles = 0x0001;
      Box2D.Collision.b2Manifold.e_faceA = 0x0002;
      Box2D.Collision.b2Manifold.e_faceB = 0x0004;
   });
   b2ManifoldPoint.b2ManifoldPoint = function () {
      this.m_localPoint = new b2Vec2();
      this.m_id = new b2ContactID();
   };
   b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
      this.Reset();
   }
   b2ManifoldPoint.prototype.Reset = function () {
      this.m_localPoint.SetZero();
      this.m_normalImpulse = 0.0;
      this.m_tangentImpulse = 0.0;
      this.m_id.key = 0;
   }
   b2ManifoldPoint.prototype.Set = function (m) {
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_normalImpulse = m.m_normalImpulse;
      this.m_tangentImpulse = m.m_tangentImpulse;
      this.m_id.Set(m.m_id);
   }
   b2Point.b2Point = function () {
      this.p = new b2Vec2();
   };
   b2Point.prototype.Support = function (xf, vX, vY) {
      if (vX === undefined) vX = 0;
      if (vY === undefined) vY = 0;
      return this.p;
   }
   b2Point.prototype.GetFirstVertex = function (xf) {
      return this.p;
   }
   b2RayCastInput.b2RayCastInput = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
      if (p1 === undefined) p1 = null;
      if (p2 === undefined) p2 = null;
      if (maxFraction === undefined) maxFraction = 1;
      if (p1) this.p1.SetV(p1);
      if (p2) this.p2.SetV(p2);
      this.maxFraction = maxFraction;
   }
   b2RayCastOutput.b2RayCastOutput = function () {
      this.normal = new b2Vec2();
   };
   b2Segment.b2Segment = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
      if (maxLambda === undefined) maxLambda = 0;
      var s = segment.p1;
      var rX = segment.p2.x - s.x;
      var rY = segment.p2.y - s.y;
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var nX = dY;
      var nY = (-dX);
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = s.x - this.p1.x;
         var bY = s.y - this.p1.y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= maxLambda * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               nX /= nLen;
               nY /= nLen;
               lambda[0] = a;
               normal.Set(nX, nY);
               return true;
            }
         }
      }
      return false;
   }
   b2Segment.prototype.Extend = function (aabb) {
      this.ExtendForward(aabb);
      this.ExtendBackward(aabb);
   }
   b2Segment.prototype.ExtendForward = function (aabb) {
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + dX * lambda;
      this.p2.y = this.p1.y + dY * lambda;
   }
   b2Segment.prototype.ExtendBackward = function (aabb) {
      var dX = (-this.p2.x) + this.p1.x;
      var dY = (-this.p2.y) + this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + dX * lambda;
      this.p1.y = this.p2.y + dY * lambda;
   }
   b2SeparationFunction.b2SeparationFunction = function () {
      this.m_localPoint = new b2Vec2();
      this.m_axis = new b2Vec2();
   };
   b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
      this.m_proxyA = proxyA;
      this.m_proxyB = proxyB;
      var count = parseInt(cache.count);
      b2Settings.b2Assert(0 < count && count < 3);
      var localPointA;
      var localPointA1;
      var localPointA2;
      var localPointB;
      var localPointB1;
      var localPointB2;
      var pointAX = 0;
      var pointAY = 0;
      var pointBX = 0;
      var pointBY = 0;
      var normalX = 0;
      var normalY = 0;
      var tMat;
      var tVec;
      var s = 0;
      var sgn = 0;
      if (count == 1) {
         this.m_type = b2SeparationFunction.e_points;
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         this.m_axis.x = pointBX - pointAX;
         this.m_axis.y = pointBY - pointAY;
         this.m_axis.Normalize();
      }
      else if (cache.indexB[0] == cache.indexB[1]) {
         this.m_type = b2SeparationFunction.e_faceA;
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
         this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformA.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else if (cache.indexA[0] == cache.indexA[0]) {
         this.m_type = b2SeparationFunction.e_faceB;
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
         this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformB.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else {
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         var pA = b2Math.MulX(transformA, localPointA);
         var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
         var pB = b2Math.MulX(transformB, localPointB);
         var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
         var a = dA.x * dA.x + dA.y * dA.y;
         var e = dB.x * dB.x + dB.y * dB.y;
         var r = b2Math.SubtractVV(dB, dA);
         var c = dA.x * r.x + dA.y * r.y;
         var f = dB.x * r.x + dB.y * r.y;
         var b = dA.x * dB.x + dA.y * dB.y;
         var denom = a * e - b * b;
         s = 0.0;
         if (denom != 0.0) {
            s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
         }
         var t = (b * s + f) / e;
         if (t < 0.0) {
            t = 0.0;
            s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
         }
         localPointA = new b2Vec2();
         localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
         localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
         localPointB = new b2Vec2();
         localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
         localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
         if (s == 0.0 || s == 1.0) {
            this.m_type = b2SeparationFunction.e_faceB;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            this.m_localPoint = localPointB;
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
         else {
            this.m_type = b2SeparationFunction.e_faceA;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_localPoint = localPointA;
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
      }
   }
   b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
      var axisA;
      var axisB;
      var localPointA;
      var localPointB;
      var pointA;
      var pointB;
      var seperation = 0;
      var normal;
      switch (this.m_type) {
      case b2SeparationFunction.e_points:
         {
            axisA = b2Math.MulTMV(transformA.R, this.m_axis);
            axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointA = b2Math.MulX(transformA, localPointA);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceA:
         {
            normal = b2Math.MulMV(transformA.R, this.m_axis);
            pointA = b2Math.MulX(transformA, this.m_localPoint);
            axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceB:
         {
            normal = b2Math.MulMV(transformB.R, this.m_axis);
            pointB = b2Math.MulX(transformB, this.m_localPoint);
            axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            pointA = b2Math.MulX(transformA, localPointA);
            seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
            return seperation;
         }
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2SeparationFunction.e_points = 0x01;
      Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
      Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
   });
   b2Simplex.b2Simplex = function () {
      this.m_v1 = new b2SimplexVertex();
      this.m_v2 = new b2SimplexVertex();
      this.m_v3 = new b2SimplexVertex();
      this.m_vertices = new Vector(3);
   };
   b2Simplex.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1;
      this.m_vertices[1] = this.m_v2;
      this.m_vertices[2] = this.m_v3;
   }
   b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
      b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
      var wALocal;
      var wBLocal;
      this.m_count = cache.count;
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         var v = vertices[i];
         v.indexA = cache.indexA[i];
         v.indexB = cache.indexB[i];
         wALocal = proxyA.GetVertex(v.indexA);
         wBLocal = proxyB.GetVertex(v.indexB);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         v.a = 0;
      }
      if (this.m_count > 1) {
         var metric1 = cache.metric;
         var metric2 = this.GetMetric();
         if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
            this.m_count = 0;
         }
      }
      if (this.m_count == 0) {
         v = vertices[0];
         v.indexA = 0;
         v.indexB = 0;
         wALocal = proxyA.GetVertex(0);
         wBLocal = proxyB.GetVertex(0);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         this.m_count = 1;
      }
   }
   b2Simplex.prototype.WriteCache = function (cache) {
      cache.metric = this.GetMetric();
      cache.count = Box2D.parseUInt(this.m_count);
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
         cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
      }
   }
   b2Simplex.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
      case 1:
         return this.m_v1.w.GetNegative();
      case 2:
         {
            var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
            var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
            if (sgn > 0.0) {
               return b2Math.CrossFV(1.0, e12);
            }
            else {
               return b2Math.CrossVF(e12, 1.0);
            }
         }
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      case 1:
         return this.m_v1.w;
      case 2:
         return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         break;
      case 1:
         pA.SetV(this.m_v1.wA);
         pB.SetV(this.m_v1.wB);
         break;
      case 2:
         pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
         pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
         pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
         pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
         break;
      case 3:
         pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
         pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
         break;
      default:
         b2Settings.b2Assert(false);
         break;
      }
   }
   b2Simplex.prototype.GetMetric = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return 0.0;
      case 1:
         return 0.0;
      case 2:
         return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
      case 3:
         return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   b2Simplex.prototype.Solve2 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
      if (d12_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      var d12_1 = (w2.x * e12.x + w2.y * e12.y);
      if (d12_1 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      var inv_d12 = 1.0 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
   }
   b2Simplex.prototype.Solve3 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var w3 = this.m_v3.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var w1e12 = b2Math.Dot(w1, e12);
      var w2e12 = b2Math.Dot(w2, e12);
      var d12_1 = w2e12;
      var d12_2 = (-w1e12);
      var e13 = b2Math.SubtractVV(w3, w1);
      var w1e13 = b2Math.Dot(w1, e13);
      var w3e13 = b2Math.Dot(w3, e13);
      var d13_1 = w3e13;
      var d13_2 = (-w1e13);
      var e23 = b2Math.SubtractVV(w3, w2);
      var w2e23 = b2Math.Dot(w2, e23);
      var w3e23 = b2Math.Dot(w3, e23);
      var d23_1 = w3e23;
      var d23_2 = (-w2e23);
      var n123 = b2Math.CrossVV(e12, e13);
      var d123_1 = n123 * b2Math.CrossVV(w2, w3);
      var d123_2 = n123 * b2Math.CrossVV(w3, w1);
      var d123_3 = n123 * b2Math.CrossVV(w1, w2);
      if (d12_2 <= 0.0 && d13_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
         var inv_d12 = 1.0 / (d12_1 + d12_2);
         this.m_v1.a = d12_1 * inv_d12;
         this.m_v2.a = d12_2 * inv_d12;
         this.m_count = 2;
         return;
      }
      if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
         var inv_d13 = 1.0 / (d13_1 + d13_2);
         this.m_v1.a = d13_1 * inv_d13;
         this.m_v3.a = d13_2 * inv_d13;
         this.m_count = 2;
         this.m_v2.Set(this.m_v3);
         return;
      }
      if (d12_1 <= 0.0 && d23_2 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      if (d13_1 <= 0.0 && d23_1 <= 0.0) {
         this.m_v3.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v3);
         return;
      }
      if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
         var inv_d23 = 1.0 / (d23_1 + d23_2);
         this.m_v2.a = d23_1 * inv_d23;
         this.m_v3.a = d23_2 * inv_d23;
         this.m_count = 2;
         this.m_v1.Set(this.m_v3);
         return;
      }
      var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
      this.m_v1.a = d123_1 * inv_d123;
      this.m_v2.a = d123_2 * inv_d123;
      this.m_v3.a = d123_3 * inv_d123;
      this.m_count = 3;
   }
   b2SimplexCache.b2SimplexCache = function () {
      this.indexA = new Vector_a2j_Number(3);
      this.indexB = new Vector_a2j_Number(3);
   };
   b2SimplexVertex.b2SimplexVertex = function () {};
   b2SimplexVertex.prototype.Set = function (other) {
      this.wA.SetV(other.wA);
      this.wB.SetV(other.wB);
      this.w.SetV(other.w);
      this.a = other.a;
      this.indexA = other.indexA;
      this.indexB = other.indexB;
   }
   b2TimeOfImpact.b2TimeOfImpact = function () {};
   b2TimeOfImpact.TimeOfImpact = function (input) {
      ++b2TimeOfImpact.b2_toiCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var sweepA = input.sweepA;
      var sweepB = input.sweepB;
      b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
      b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
      var radius = proxyA.m_radius + proxyB.m_radius;
      var tolerance = input.tolerance;
      var alpha = 0.0;
      var k_maxIterations = 1000;
      var iter = 0;
      var target = 0.0;
      b2TimeOfImpact.s_cache.count = 0;
      b2TimeOfImpact.s_distanceInput.useRadii = false;
      for (;;) {
         sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
         sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
         b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
         b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
         b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
         b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
         b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
         if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
            alpha = 1.0;
            break;
         }
         b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
         var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
         if (separation <= 0.0) {
            alpha = 1.0;
            break;
         }
         if (iter == 0) {
            if (separation > radius) {
               target = b2Math.Max(radius - tolerance, 0.75 * radius);
            }
            else {
               target = b2Math.Max(separation - tolerance, 0.02 * radius);
            }
         }
         if (separation - target < 0.5 * tolerance) {
            if (iter == 0) {
               alpha = 1.0;
               break;
            }
            break;
         }
         var newAlpha = alpha; {
            var x1 = alpha;
            var x2 = 1.0;
            var f1 = separation;
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
            var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (f2 >= target) {
               alpha = 1.0;
               break;
            }
            var rootIterCount = 0;
            for (;;) {
               var x = 0;
               if (rootIterCount & 1) {
                  x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
               }
               else {
                  x = 0.5 * (x1 + x2);
               }
               sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
               sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
               var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
               if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                  newAlpha = x;
                  break;
               }
               if (f > target) {
                  x1 = x;
                  f1 = f;
               }
               else {
                  x2 = x;
                  f2 = f;
               }++rootIterCount;
               ++b2TimeOfImpact.b2_toiRootIters;
               if (rootIterCount == 50) {
                  break;
               }
            }
            b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
         }
         if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
            break;
         }
         alpha = newAlpha;
         iter++;
         ++b2TimeOfImpact.b2_toiIters;
         if (iter == k_maxIterations) {
            break;
         }
      }
      b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
      return alpha;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
      Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
      Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
      Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
   });
   b2TOIInput.b2TOIInput = function () {
      this.proxyA = new b2DistanceProxy();
      this.proxyB = new b2DistanceProxy();
      this.sweepA = new b2Sweep();
      this.sweepB = new b2Sweep();
   };
   b2WorldManifold.b2WorldManifold = function () {
      this.m_normal = new b2Vec2();
   };
   b2WorldManifold.prototype.b2WorldManifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
      if (radiusA === undefined) radiusA = 0;
      if (radiusB === undefined) radiusB = 0;
      if (manifold.m_pointCount == 0) {
         return;
      }
      var i = 0;
      var tVec;
      var tMat;
      var normalX = 0;
      var normalY = 0;
      var planePointX = 0;
      var planePointY = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      switch (manifold.m_type) {
      case b2Manifold.e_circles:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_points[0].m_localPoint;
            var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1;
               this.m_normal.y = 0;
            }
            var cAX = pointAX + radiusA * this.m_normal.x;
            var cAY = pointAY + radiusA * this.m_normal.y;
            var cBX = pointBX - radiusB * this.m_normal.x;
            var cBY = pointBY - radiusB * this.m_normal.y;
            this.m_points[0].x = 0.5 * (cAX + cBX);
            this.m_points[0].y = 0.5 * (cAY + cBY);
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = normalX;
            this.m_normal.y = normalY;
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfB.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = xfB.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_localPoint;
            planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = (-normalX);
            this.m_normal.y = (-normalY);
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfA.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
            }
         }
         break;
      }
   }
   ClipVertex.ClipVertex = function () {
      this.v = new b2Vec2();
      this.id = new b2ContactID();
   };
   ClipVertex.prototype.Set = function (other) {
      this.v.SetV(other.v);
      this.id.Set(other.id);
   }
   Features.Features = function () {};
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._referenceEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._referenceEdge = value;
         this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentEdge = value;
         this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentVertex;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentVertex = value;
         this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._flip;
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._flip = value;
         this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
      }
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
   b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2CircleShape.b2CircleShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.m_p = new b2Vec2();
   };
   b2CircleShape.prototype.Copy = function () {
      var s = new b2CircleShape();
      s.Set(this);
      return s;
   }
   b2CircleShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2CircleShape)) {
         var other2 = (other instanceof b2CircleShape ? other : null);
         this.m_p.SetV(other2.m_p);
      }
   }
   b2CircleShape.prototype.TestPoint = function (transform, p) {
      var tMat = transform.R;
      var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      dX = p.x - dX;
      dY = p.y - dY;
      return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
   }
   b2CircleShape.prototype.RayCast = function (output, input, transform) {
      var tMat = transform.R;
      var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      var sX = input.p1.x - positionX;
      var sY = input.p1.y - positionY;
      var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      var c = (sX * rX + sY * rY);
      var rr = (rX * rX + rY * rY);
      var sigma = c * c - rr * b;
      if (sigma < 0.0 || rr < Number.MIN_VALUE) {
         return false;
      }
      var a = (-(c + Math.sqrt(sigma)));
      if (0.0 <= a && a <= input.maxFraction * rr) {
         a /= rr;
         output.fraction = a;
         output.normal.x = sX + a * rX;
         output.normal.y = sY + a * rY;
         output.normal.Normalize();
         return true;
      }
      return false;
   }
   b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
      aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
   }
   b2CircleShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
      massData.center.SetV(this.m_p);
      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
   }
   b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var p = b2Math.MulX(xf, this.m_p);
      var l = (-(b2Math.Dot(normal, p) - offset));
      if (l < (-this.m_radius) + Number.MIN_VALUE) {
         return 0;
      }
      if (l > this.m_radius) {
         c.SetV(p);
         return Math.PI * this.m_radius * this.m_radius;
      }
      var r2 = this.m_radius * this.m_radius;
      var l2 = l * l;
      var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
      var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
      c.x = p.x + normal.x * com;
      c.y = p.y + normal.y * com;
      return area;
   }
   b2CircleShape.prototype.GetLocalPosition = function () {
      return this.m_p;
   }
   b2CircleShape.prototype.SetLocalPosition = function (position) {
      this.m_p.SetV(position);
   }
   b2CircleShape.prototype.GetRadius = function () {
      return this.m_radius;
   }
   b2CircleShape.prototype.SetRadius = function (radius) {
      if (radius === undefined) radius = 0;
      this.m_radius = radius;
   }
   b2CircleShape.prototype.b2CircleShape = function (radius) {
      if (radius === undefined) radius = 0;
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_circleShape;
      this.m_radius = radius;
   }
   b2EdgeChainDef.b2EdgeChainDef = function () {};
   b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
      this.vertexCount = 0;
      this.isALoop = true;
      this.vertices = [];
   }
   Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
   b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2EdgeShape.b2EdgeShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.s_supportVec = new b2Vec2();
      this.m_v1 = new b2Vec2();
      this.m_v2 = new b2Vec2();
      this.m_coreV1 = new b2Vec2();
      this.m_coreV2 = new b2Vec2();
      this.m_normal = new b2Vec2();
      this.m_direction = new b2Vec2();
      this.m_cornerDir1 = new b2Vec2();
      this.m_cornerDir2 = new b2Vec2();
   };
   b2EdgeShape.prototype.TestPoint = function (transform, p) {
      return false;
   }
   b2EdgeShape.prototype.RayCast = function (output, input, transform) {
      var tMat;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
      var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = input.p1.x - v1X;
         var bY = input.p1.y - v1Y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= input.maxFraction * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               output.fraction = a;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               output.normal.x = nX / nLen;
               output.normal.y = nY / nLen;
               return true;
            }
         }
      }
      return false;
   }
   b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
      var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
      if (v1X < v2X) {
         aabb.lowerBound.x = v1X;
         aabb.upperBound.x = v2X;
      }
      else {
         aabb.lowerBound.x = v2X;
         aabb.upperBound.x = v1X;
      }
      if (v1Y < v2Y) {
         aabb.lowerBound.y = v1Y;
         aabb.upperBound.y = v2Y;
      }
      else {
         aabb.lowerBound.y = v2Y;
         aabb.upperBound.y = v1Y;
      }
   }
   b2EdgeShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = 0;
      massData.center.SetV(this.m_v1);
      massData.I = 0;
   }
   b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
      var v1 = b2Math.MulX(xf, this.m_v1);
      var v2 = b2Math.MulX(xf, this.m_v2);
      var d1 = b2Math.Dot(normal, v1) - offset;
      var d2 = b2Math.Dot(normal, v2) - offset;
      if (d1 > 0) {
         if (d2 > 0) {
            return 0;
         }
         else {
            v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
      }
      else {
         if (d2 > 0) {
            v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
         else {}
      }
      c.x = (v0.x + v1.x + v2.x) / 3;
      c.y = (v0.y + v1.y + v2.y) / 3;
      return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
   }
   b2EdgeShape.prototype.GetLength = function () {
      return this.m_length;
   }
   b2EdgeShape.prototype.GetVertex1 = function () {
      return this.m_v1;
   }
   b2EdgeShape.prototype.GetVertex2 = function () {
      return this.m_v2;
   }
   b2EdgeShape.prototype.GetCoreVertex1 = function () {
      return this.m_coreV1;
   }
   b2EdgeShape.prototype.GetCoreVertex2 = function () {
      return this.m_coreV2;
   }
   b2EdgeShape.prototype.GetNormalVector = function () {
      return this.m_normal;
   }
   b2EdgeShape.prototype.GetDirectionVector = function () {
      return this.m_direction;
   }
   b2EdgeShape.prototype.GetCorner1Vector = function () {
      return this.m_cornerDir1;
   }
   b2EdgeShape.prototype.GetCorner2Vector = function () {
      return this.m_cornerDir2;
   }
   b2EdgeShape.prototype.Corner1IsConvex = function () {
      return this.m_cornerConvex1;
   }
   b2EdgeShape.prototype.Corner2IsConvex = function () {
      return this.m_cornerConvex2;
   }
   b2EdgeShape.prototype.GetFirstVertex = function (xf) {
      var tMat = xf.R;
      return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
   }
   b2EdgeShape.prototype.GetNextEdge = function () {
      return this.m_nextEdge;
   }
   b2EdgeShape.prototype.GetPrevEdge = function () {
      return this.m_prevEdge;
   }
   b2EdgeShape.prototype.Support = function (xf, dX, dY) {
      if (dX === undefined) dX = 0;
      if (dY === undefined) dY = 0;
      var tMat = xf.R;
      var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
      var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
      var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
      var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
      if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
         this.s_supportVec.x = v1X;
         this.s_supportVec.y = v1Y;
      }
      else {
         this.s_supportVec.x = v2X;
         this.s_supportVec.y = v2Y;
      }
      return this.s_supportVec;
   }
   b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_edgeShape;
      this.m_prevEdge = null;
      this.m_nextEdge = null;
      this.m_v1 = v1;
      this.m_v2 = v2;
      this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
      this.m_length = this.m_direction.Normalize();
      this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
      this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
      this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
      this.m_cornerDir1 = this.m_normal;
      this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
   }
   b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
      this.m_prevEdge = edge;
      this.m_coreV1 = core;
      this.m_cornerDir1 = cornerDir;
      this.m_cornerConvex1 = convex;
   }
   b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
      this.m_nextEdge = edge;
      this.m_coreV2 = core;
      this.m_cornerDir2 = cornerDir;
      this.m_cornerConvex2 = convex;
   }
   b2MassData.b2MassData = function () {
      this.mass = 0.0;
      this.center = new b2Vec2(0, 0);
      this.I = 0.0;
   };
   Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
   b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2PolygonShape.b2PolygonShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
   };
   b2PolygonShape.prototype.Copy = function () {
      var s = new b2PolygonShape();
      s.Set(this);
      return s;
   }
   b2PolygonShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2PolygonShape)) {
         var other2 = (other instanceof b2PolygonShape ? other : null);
         this.m_centroid.SetV(other2.m_centroid);
         this.m_vertexCount = other2.m_vertexCount;
         this.Reserve(this.m_vertexCount);
         for (var i = 0; i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(other2.m_vertices[i]);
            this.m_normals[i].SetV(other2.m_normals[i]);
         }
      }
   }
   b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var v = new Vector();
      var i = 0,
         tVec;
      for (i = 0;
      i < vertices.length; ++i) {
         tVec = vertices[i];
         v.push(tVec);
      }
      this.SetAsVector(v, vertexCount);
   }
   b2PolygonShape.AsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsArray(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      if (vertexCount == 0) vertexCount = vertices.length;
      b2Settings.b2Assert(2 <= vertexCount);
      this.m_vertexCount = vertexCount;
      this.Reserve(vertexCount);
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; i++) {
         this.m_vertices[i].SetV(vertices[i]);
      }
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         var i1 = parseInt(i);
         var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
         var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
         b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
         this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
         this.m_normals[i].Normalize();
      }
      this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
   }
   b2PolygonShape.AsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsVector(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid.SetZero();
   }
   b2PolygonShape.AsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsBox(hx, hy);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid = center;
      var xf = new b2Transform();
      xf.position = center;
      xf.R.Set(angle);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
         this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
      }
   }
   b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsOrientedBox(hx, hy, center, angle);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
      this.m_vertexCount = 2;
      this.Reserve(2);
      this.m_vertices[0].SetV(v1);
      this.m_vertices[1].SetV(v2);
      this.m_centroid.x = 0.5 * (v1.x + v2.x);
      this.m_centroid.y = 0.5 * (v1.y + v2.y);
      this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
      this.m_normals[0].Normalize();
      this.m_normals[1].x = (-this.m_normals[0].x);
      this.m_normals[1].y = (-this.m_normals[0].y);
   }
   b2PolygonShape.AsEdge = function (v1, v2) {
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsEdge(v1, v2);
      return polygonShape;
   }
   b2PolygonShape.prototype.TestPoint = function (xf, p) {
      var tVec;
      var tMat = xf.R;
      var tX = p.x - xf.position.x;
      var tY = p.y - xf.position.y;
      var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
      var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = pLocalX - tVec.x;
         tY = pLocalY - tVec.y;
         tVec = this.m_normals[i];
         var dot = (tVec.x * tX + tVec.y * tY);
         if (dot > 0.0) {
            return false;
         }
      }
      return true;
   }
   b2PolygonShape.prototype.RayCast = function (output, input, transform) {
      var lower = 0.0;
      var upper = input.maxFraction;
      var tX = 0;
      var tY = 0;
      var tMat;
      var tVec;
      tX = input.p1.x - transform.position.x;
      tY = input.p1.y - transform.position.y;
      tMat = transform.R;
      var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      tX = input.p2.x - transform.position.x;
      tY = input.p2.y - transform.position.y;
      tMat = transform.R;
      var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var index = parseInt((-1));
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = tVec.x - p1X;
         tY = tVec.y - p1Y;
         tVec = this.m_normals[i];
         var numerator = (tVec.x * tX + tVec.y * tY);
         var denominator = (tVec.x * dX + tVec.y * dY);
         if (denominator == 0.0) {
            if (numerator < 0.0) {
               return false;
            }
         }
         else {
            if (denominator < 0.0 && numerator < lower * denominator) {
               lower = numerator / denominator;
               index = i;
            }
            else if (denominator > 0.0 && numerator < upper * denominator) {
               upper = numerator / denominator;
            }
         }
         if (upper < lower - Number.MIN_VALUE) {
            return false;
         }
      }
      if (index >= 0) {
         output.fraction = lower;
         tMat = transform.R;
         tVec = this.m_normals[index];
         output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         return true;
      }
      return false;
   }
   b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
      var tMat = xf.R;
      var tVec = this.m_vertices[0];
      var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var upperX = lowerX;
      var upperY = lowerY;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         lowerX = lowerX < vX ? lowerX : vX;
         lowerY = lowerY < vY ? lowerY : vY;
         upperX = upperX > vX ? upperX : vX;
         upperY = upperY > vY ? upperY : vY;
      }
      aabb.lowerBound.x = lowerX - this.m_radius;
      aabb.lowerBound.y = lowerY - this.m_radius;
      aabb.upperBound.x = upperX + this.m_radius;
      aabb.upperBound.y = upperY + this.m_radius;
   }
   b2PolygonShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      if (this.m_vertexCount == 2) {
         massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
         massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
         massData.mass = 0.0;
         massData.I = 0.0;
         return;
      }
      var centerX = 0.0;
      var centerY = 0.0;
      var area = 0.0;
      var I = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var k_inv3 = 1.0 / 3.0;
      for (var i = 0; i < this.m_vertexCount; ++i) {
         var p2 = this.m_vertices[i];
         var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = e1X * e2Y - e1Y * e2X;
         var triangleArea = 0.5 * D;area += triangleArea;
         centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
         centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
         var px = p1X;
         var py = p1Y;
         var ex1 = e1X;
         var ey1 = e1Y;
         var ex2 = e2X;
         var ey2 = e2Y;
         var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
         var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
      }
      massData.mass = density * area;
      centerX *= 1.0 / area;
      centerY *= 1.0 / area;
      massData.center.Set(centerX, centerY);
      massData.I = density * I;
   }
   b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var normalL = b2Math.MulTMV(xf.R, normal);
      var offsetL = offset - b2Math.Dot(normal, xf.position);
      var depths = new Vector_a2j_Number();
      var diveCount = 0;
      var intoIndex = parseInt((-1));
      var outoIndex = parseInt((-1));
      var lastSubmerged = false;
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
         var isSubmerged = depths[i] < (-Number.MIN_VALUE);
         if (i > 0) {
            if (isSubmerged) {
               if (!lastSubmerged) {
                  intoIndex = i - 1;
                  diveCount++;
               }
            }
            else {
               if (lastSubmerged) {
                  outoIndex = i - 1;
                  diveCount++;
               }
            }
         }
         lastSubmerged = isSubmerged;
      }
      switch (diveCount) {
      case 0:
         if (lastSubmerged) {
            var md = new b2MassData();
            this.ComputeMass(md, 1);
            c.SetV(b2Math.MulX(xf, md.center));
            return md.mass;
         }
         else {
            return 0;
         }
         break;
      case 1:
         if (intoIndex == (-1)) {
            intoIndex = this.m_vertexCount - 1;
         }
         else {
            outoIndex = this.m_vertexCount - 1;
         }
         break;
      }
      var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
      var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
      var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
      var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
      var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
      var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
      var area = 0;
      var center = new b2Vec2();
      var p2 = this.m_vertices[intoIndex2];
      var p3;
      i = intoIndex2;
      while (i != outoIndex2) {
         i = (i + 1) % this.m_vertexCount;
         if (i == outoIndex2) p3 = outoVec;
         else p3 = this.m_vertices[i];
         var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
         area += triangleArea;
         center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
         center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
         p2 = p3;
      }
      center.Multiply(1 / area);
      c.SetV(b2Math.MulX(xf, center));
      return area;
   }
   b2PolygonShape.prototype.GetVertexCount = function () {
      return this.m_vertexCount;
   }
   b2PolygonShape.prototype.GetVertices = function () {
      return this.m_vertices;
   }
   b2PolygonShape.prototype.GetNormals = function () {
      return this.m_normals;
   }
   b2PolygonShape.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2PolygonShape.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2PolygonShape.prototype.Validate = function () {
      return false;
   }
   b2PolygonShape.prototype.b2PolygonShape = function () {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_polygonShape;
      this.m_centroid = new b2Vec2();
      this.m_vertices = new Vector();
      this.m_normals = new Vector();
   }
   b2PolygonShape.prototype.Reserve = function (count) {
      if (count === undefined) count = 0;
      for (var i = parseInt(this.m_vertices.length); i < count; i++) {
         this.m_vertices[i] = new b2Vec2();
         this.m_normals[i] = new b2Vec2();
      }
   }
   b2PolygonShape.ComputeCentroid = function (vs, count) {
      if (count === undefined) count = 0;
      var c = new b2Vec2();
      var area = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var inv3 = 1.0 / 3.0;
      for (var i = 0; i < count; ++i) {
         var p2 = vs[i];
         var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = (e1X * e2Y - e1Y * e2X);
         var triangleArea = 0.5 * D;area += triangleArea;
         c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
         c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
      }
      c.x *= 1.0 / area;
      c.y *= 1.0 / area;
      return c;
   }
   b2PolygonShape.ComputeOBB = function (obb, vs, count) {
      if (count === undefined) count = 0;
      var i = 0;
      var p = new Vector(count + 1);
      for (i = 0;
      i < count; ++i) {
         p[i] = vs[i];
      }
      p[count] = p[0];
      var minArea = Number.MAX_VALUE;
      for (i = 1;
      i <= count; ++i) {
         var root = p[parseInt(i - 1)];
         var uxX = p[i].x - root.x;
         var uxY = p[i].y - root.y;
         var length = Math.sqrt(uxX * uxX + uxY * uxY);
         uxX /= length;
         uxY /= length;
         var uyX = (-uxY);
         var uyY = uxX;
         var lowerX = Number.MAX_VALUE;
         var lowerY = Number.MAX_VALUE;
         var upperX = (-Number.MAX_VALUE);
         var upperY = (-Number.MAX_VALUE);
         for (var j = 0; j < count; ++j) {
            var dX = p[j].x - root.x;
            var dY = p[j].y - root.y;
            var rX = (uxX * dX + uxY * dY);
            var rY = (uyX * dX + uyY * dY);
            if (rX < lowerX) lowerX = rX;
            if (rY < lowerY) lowerY = rY;
            if (rX > upperX) upperX = rX;
            if (rY > upperY) upperY = rY;
         }
         var area = (upperX - lowerX) * (upperY - lowerY);
         if (area < 0.95 * minArea) {
            minArea = area;
            obb.R.col1.x = uxX;
            obb.R.col1.y = uxY;
            obb.R.col2.x = uyX;
            obb.R.col2.y = uyY;
            var centerX = 0.5 * (lowerX + upperX);
            var centerY = 0.5 * (lowerY + upperY);
            var tMat = obb.R;
            obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
            obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
            obb.extents.x = 0.5 * (upperX - lowerX);
            obb.extents.y = 0.5 * (upperY - lowerY);
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
   });
   b2Shape.b2Shape = function () {};
   b2Shape.prototype.Copy = function () {
      return null;
   }
   b2Shape.prototype.Set = function (other) {
      this.m_radius = other.m_radius;
   }
   b2Shape.prototype.GetType = function () {
      return this.m_type;
   }
   b2Shape.prototype.TestPoint = function (xf, p) {
      return false;
   }
   b2Shape.prototype.RayCast = function (output, input, transform) {
      return false;
   }
   b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
   b2Shape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
   }
   b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      return 0;
   }
   b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
      var input = new b2DistanceInput();
      input.proxyA = new b2DistanceProxy();
      input.proxyA.Set(shape1);
      input.proxyB = new b2DistanceProxy();
      input.proxyB.Set(shape2);
      input.transformA = transform1;
      input.transformB = transform2;
      input.useRadii = true;
      var simplexCache = new b2SimplexCache();
      simplexCache.count = 0;
      var output = new b2DistanceOutput();
      b2Distance.Distance(output, simplexCache, input);
      return output.distance < 10.0 * Number.MIN_VALUE;
   }
   b2Shape.prototype.b2Shape = function () {
      this.m_type = b2Shape.e_unknownShape;
      this.m_radius = b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
      Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
      Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
      Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
      Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
      Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
      Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
      Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Color.b2Color = function () {
      this._r = 0;
      this._g = 0;
      this._b = 0;
   };
   b2Color.prototype.b2Color = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   b2Color.prototype.Set = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   Object.defineProperty(b2Color.prototype, 'r', {
      enumerable: false,
      configurable: true,
      set: function (rr) {
         if (rr === undefined) rr = 0;
         this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'g', {
      enumerable: false,
      configurable: true,
      set: function (gg) {
         if (gg === undefined) gg = 0;
         this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'b', {
      enumerable: false,
      configurable: true,
      set: function (bb) {
         if (bb === undefined) bb = 0;
         this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'color', {
      enumerable: false,
      configurable: true,
      get: function () {
         return (this._r << 16) | (this._g << 8) | (this._b);
      }
   });
   b2Settings.b2Settings = function () {};
   b2Settings.b2MixFriction = function (friction1, friction2) {
      if (friction1 === undefined) friction1 = 0;
      if (friction2 === undefined) friction2 = 0;
      return Math.sqrt(friction1 * friction2);
   }
   b2Settings.b2MixRestitution = function (restitution1, restitution2) {
      if (restitution1 === undefined) restitution1 = 0;
      if (restitution2 === undefined) restitution2 = 0;
      return restitution1 > restitution2 ? restitution1 : restitution2;
   }
   b2Settings.b2Assert = function (a) {
      if (!a) {
         throw "Assertion Failed";
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.b2Settings.VERSION = "2.1alpha";
      Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
      Box2D.Common.b2Settings.b2_pi = Math.PI;
      Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
      Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
      Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
      Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_linearSlop = 0.005;
      Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
      Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
      Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
      Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
      Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxTranslation = 10.0;
      Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
      Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
      Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
      Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
      Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
      Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
   });
})();
(function () {
   var b2AABB = Box2D.Collision.b2AABB,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Mat22.b2Mat22 = function () {
      this.col1 = new b2Vec2();
      this.col2 = new b2Vec2();
   };
   b2Mat22.prototype.b2Mat22 = function () {
      this.SetIdentity();
   }
   b2Mat22.FromAngle = function (angle) {
      if (angle === undefined) angle = 0;
      var mat = new b2Mat22();
      mat.Set(angle);
      return mat;
   }
   b2Mat22.FromVV = function (c1, c2) {
      var mat = new b2Mat22();
      mat.SetVV(c1, c2);
      return mat;
   }
   b2Mat22.prototype.Set = function (angle) {
      if (angle === undefined) angle = 0;
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      this.col1.x = c;
      this.col2.x = (-s);
      this.col1.y = s;
      this.col2.y = c;
   }
   b2Mat22.prototype.SetVV = function (c1, c2) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
   }
   b2Mat22.prototype.Copy = function () {
      var mat = new b2Mat22();
      mat.SetM(this);
      return mat;
   }
   b2Mat22.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
   }
   b2Mat22.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
   }
   b2Mat22.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
   }
   b2Mat22.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
   }
   b2Mat22.prototype.GetAngle = function () {
      return Math.atan2(this.col1.y, this.col1.x);
   }
   b2Mat22.prototype.GetInverse = function (out) {
      var a = this.col1.x;
      var b = this.col2.x;
      var c = this.col1.y;
      var d = this.col2.y;
      var det = a * d - b * c;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.col1.x = det * d;
      out.col2.x = (-det * b);
      out.col1.y = (-det * c);
      out.col2.y = det * a;
      return out;
   }
   b2Mat22.prototype.Solve = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat22.prototype.Abs = function () {
      this.col1.Abs();
      this.col2.Abs();
   }
   b2Mat33.b2Mat33 = function () {
      this.col1 = new b2Vec3();
      this.col2 = new b2Vec3();
      this.col3 = new b2Vec3();
   };
   b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
      if (c1 === undefined) c1 = null;
      if (c2 === undefined) c2 = null;
      if (c3 === undefined) c3 = null;
      if (!c1 && !c2 && !c3) {
         this.col1.SetZero();
         this.col2.SetZero();
         this.col3.SetZero();
      }
      else {
         this.col1.SetV(c1);
         this.col2.SetV(c2);
         this.col3.SetV(c3);
      }
   }
   b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
      this.col3.SetV(c3);
   }
   b2Mat33.prototype.Copy = function () {
      return new b2Mat33(this.col1, this.col2, this.col3);
   }
   b2Mat33.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
      this.col3.SetV(m.col3);
   }
   b2Mat33.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col1.z += m.col1.z;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
      this.col2.z += m.col2.z;
      this.col3.x += m.col3.x;
      this.col3.y += m.col3.y;
      this.col3.z += m.col3.z;
   }
   b2Mat33.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 1.0;
   }
   b2Mat33.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 0.0;
   }
   b2Mat33.prototype.Solve22 = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      if (bZ === undefined) bZ = 0;
      var a11 = this.col1.x;
      var a21 = this.col1.y;
      var a31 = this.col1.z;
      var a12 = this.col2.x;
      var a22 = this.col2.y;
      var a32 = this.col2.z;
      var a13 = this.col3.x;
      var a23 = this.col3.y;
      var a33 = this.col3.z;
      var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
      out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
      out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
      return out;
   }
   b2Math.b2Math = function () {};
   b2Math.IsValid = function (x) {
      if (x === undefined) x = 0;
      return isFinite(x);
   }
   b2Math.Dot = function (a, b) {
      return a.x * b.x + a.y * b.y;
   }
   b2Math.CrossVV = function (a, b) {
      return a.x * b.y - a.y * b.x;
   }
   b2Math.CrossVF = function (a, s) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.y, (-s * a.x));
      return v;
   }
   b2Math.CrossFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2((-s * a.y), s * a.x);
      return v;
   }
   b2Math.MulMV = function (A, v) {
      var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
      return u;
   }
   b2Math.MulTMV = function (A, v) {
      var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
      return u;
   }
   b2Math.MulX = function (T, v) {
      var a = b2Math.MulMV(T.R, v);
      a.x += T.position.x;
      a.y += T.position.y;
      return a;
   }
   b2Math.MulXT = function (T, v) {
      var a = b2Math.SubtractVV(v, T.position);
      var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
      a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
      a.x = tX;
      return a;
   }
   b2Math.AddVV = function (a, b) {
      var v = new b2Vec2(a.x + b.x, a.y + b.y);
      return v;
   }
   b2Math.SubtractVV = function (a, b) {
      var v = new b2Vec2(a.x - b.x, a.y - b.y);
      return v;
   }
   b2Math.Distance = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return Math.sqrt(cX * cX + cY * cY);
   }
   b2Math.DistanceSquared = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return (cX * cX + cY * cY);
   }
   b2Math.MulFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.x, s * a.y);
      return v;
   }
   b2Math.AddMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
      return C;
   }
   b2Math.MulMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
      return C;
   }
   b2Math.MulTMM = function (A, B) {
      var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
      var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
      var C = b2Mat22.FromVV(c1, c2);
      return C;
   }
   b2Math.Abs = function (a) {
      if (a === undefined) a = 0;
      return a > 0.0 ? a : (-a);
   }
   b2Math.AbsV = function (a) {
      var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
      return b;
   }
   b2Math.AbsM = function (A) {
      var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
      return B;
   }
   b2Math.Min = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a < b ? a : b;
   }
   b2Math.MinV = function (a, b) {
      var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
      return c;
   }
   b2Math.Max = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a > b ? a : b;
   }
   b2Math.MaxV = function (a, b) {
      var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
      return c;
   }
   b2Math.Clamp = function (a, low, high) {
      if (a === undefined) a = 0;
      if (low === undefined) low = 0;
      if (high === undefined) high = 0;
      return a < low ? low : a > high ? high : a;
   }
   b2Math.ClampV = function (a, low, high) {
      return b2Math.MaxV(low, b2Math.MinV(a, high));
   }
   b2Math.Swap = function (a, b) {
      var tmp = a[0];
      a[0] = b[0];
      b[0] = tmp;
   }
   b2Math.Random = function () {
      return Math.random() * 2 - 1;
   }
   b2Math.RandomRange = function (lo, hi) {
      if (lo === undefined) lo = 0;
      if (hi === undefined) hi = 0;
      var r = Math.random();
      r = (hi - lo) * r + lo;
      return r;
   }
   b2Math.NextPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      x |= (x >> 1) & 0x7FFFFFFF;
      x |= (x >> 2) & 0x3FFFFFFF;
      x |= (x >> 4) & 0x0FFFFFFF;
      x |= (x >> 8) & 0x00FFFFFF;
      x |= (x >> 16) & 0x0000FFFF;
      return x + 1;
   }
   b2Math.IsPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      var result = x > 0 && (x & (x - 1)) == 0;
      return result;
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
      Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
      Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
   });
   b2Sweep.b2Sweep = function () {
      this.localCenter = new b2Vec2();
      this.c0 = new b2Vec2;
      this.c = new b2Vec2();
   };
   b2Sweep.prototype.Set = function (other) {
      this.localCenter.SetV(other.localCenter);
      this.c0.SetV(other.c0);
      this.c.SetV(other.c);
      this.a0 = other.a0;
      this.a = other.a;
      this.t0 = other.t0;
   }
   b2Sweep.prototype.Copy = function () {
      var copy = new b2Sweep();
      copy.localCenter.SetV(this.localCenter);
      copy.c0.SetV(this.c0);
      copy.c.SetV(this.c);
      copy.a0 = this.a0;
      copy.a = this.a;
      copy.t0 = this.t0;
      return copy;
   }
   b2Sweep.prototype.GetTransform = function (xf, alpha) {
      if (alpha === undefined) alpha = 0;
      xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
      xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
      var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
      xf.R.Set(angle);
      var tMat = xf.R;
      xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
      xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
   }
   b2Sweep.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
         var alpha = (t - this.t0) / (1.0 - this.t0);
         this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
         this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
         this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
         this.t0 = t;
      }
   }
   b2Transform.b2Transform = function () {
      this.position = new b2Vec2;
      this.R = new b2Mat22();
   };
   b2Transform.prototype.b2Transform = function (pos, r) {
      if (pos === undefined) pos = null;
      if (r === undefined) r = null;
      if (pos) {
         this.position.SetV(pos);
         this.R.SetM(r);
      }
   }
   b2Transform.prototype.Initialize = function (pos, r) {
      this.position.SetV(pos);
      this.R.SetM(r);
   }
   b2Transform.prototype.SetIdentity = function () {
      this.position.SetZero();
      this.R.SetIdentity();
   }
   b2Transform.prototype.Set = function (x) {
      this.position.SetV(x.position);
      this.R.SetM(x.R);
   }
   b2Transform.prototype.GetAngle = function () {
      return Math.atan2(this.R.col1.y, this.R.col1.x);
   }
   b2Vec2.b2Vec2 = function () {};
   b2Vec2.prototype.b2Vec2 = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetZero = function () {
      this.x = 0.0;
      this.y = 0.0;
   }
   b2Vec2.prototype.Set = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
   }
   b2Vec2.prototype.GetNegative = function () {
      return new b2Vec2((-this.x), (-this.y));
   }
   b2Vec2.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
   }
   b2Vec2.Make = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      return new b2Vec2(x_, y_);
   }
   b2Vec2.prototype.Copy = function () {
      return new b2Vec2(this.x, this.y);
   }
   b2Vec2.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
   }
   b2Vec2.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
   }
   b2Vec2.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
   }
   b2Vec2.prototype.MulM = function (A) {
      var tX = this.x;
      this.x = A.col1.x * tX + A.col2.x * this.y;
      this.y = A.col1.y * tX + A.col2.y * this.y;
   }
   b2Vec2.prototype.MulTM = function (A) {
      var tX = b2Math.Dot(this, A.col1);
      this.y = b2Math.Dot(this, A.col2);
      this.x = tX;
   }
   b2Vec2.prototype.CrossVF = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = s * this.y;
      this.y = (-s * tX);
   }
   b2Vec2.prototype.CrossFV = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = (-s * this.y);
      this.y = s * tX;
   }
   b2Vec2.prototype.MinV = function (b) {
      this.x = this.x < b.x ? this.x : b.x;
      this.y = this.y < b.y ? this.y : b.y;
   }
   b2Vec2.prototype.MaxV = function (b) {
      this.x = this.x > b.x ? this.x : b.x;
      this.y = this.y > b.y ? this.y : b.y;
   }
   b2Vec2.prototype.Abs = function () {
      if (this.x < 0) this.x = (-this.x);
      if (this.y < 0) this.y = (-this.y);
   }
   b2Vec2.prototype.Length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.LengthSquared = function () {
      return (this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.Normalize = function () {
      var length = Math.sqrt(this.x * this.x + this.y * this.y);
      if (length < Number.MIN_VALUE) {
         return 0.0;
      }
      var invLength = 1.0 / length;
      this.x *= invLength;
      this.y *= invLength;
      return length;
   }
   b2Vec2.prototype.IsValid = function () {
      return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
   }
   b2Vec3.b2Vec3 = function () {};
   b2Vec3.prototype.b2Vec3 = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetZero = function () {
      this.x = this.y = this.z = 0.0;
   }
   b2Vec3.prototype.Set = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
   }
   b2Vec3.prototype.GetNegative = function () {
      return new b2Vec3((-this.x), (-this.y), (-this.z));
   }
   b2Vec3.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
      this.z = (-this.z);
   }
   b2Vec3.prototype.Copy = function () {
      return new b2Vec3(this.x, this.y, this.z);
   }
   b2Vec3.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
   }
   b2Vec3.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
   }
   b2Vec3.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
      this.z *= a;
   }
})();
(function () {
   var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

   b2Body.b2Body = function () {
      this.m_xf = new b2Transform();
      this.m_sweep = new b2Sweep();
      this.m_linearVelocity = new b2Vec2();
      this.m_force = new b2Vec2();
   };
   b2Body.prototype.connectEdges = function (s1, s2, angle1) {
      if (angle1 === undefined) angle1 = 0;
      var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
      var coreOffset = Math.tan((angle2 - angle1) * 0.5);
      var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
      core = b2Math.SubtractVV(core, s2.GetNormalVector());
      core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
      core = b2Math.AddVV(core, s2.GetVertex1());
      var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
      cornerDir.Normalize();
      var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
      s1.SetNextEdge(s2, core, cornerDir, convex);
      s2.SetPrevEdge(s1, core, cornerDir, convex);
      return angle2;
   }
   b2Body.prototype.CreateFixture = function (def) {
      if (this.m_world.IsLocked() == true) {
         return null;
      }
      var fixture = new b2Fixture();
      fixture.Create(this, this.m_xf, def);
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.CreateProxy(broadPhase, this.m_xf);
      }
      fixture.m_next = this.m_fixtureList;
      this.m_fixtureList = fixture;
      ++this.m_fixtureCount;
      fixture.m_body = this;
      if (fixture.m_density > 0.0) {
         this.ResetMassData();
      }
      this.m_world.m_flags |= b2World.e_newFixture;
      return fixture;
   }
   b2Body.prototype.CreateFixture2 = function (shape, density) {
      if (density === undefined) density = 0.0;
      var def = new b2FixtureDef();
      def.shape = shape;
      def.density = density;
      return this.CreateFixture(def);
   }
   b2Body.prototype.DestroyFixture = function (fixture) {
      if (this.m_world.IsLocked() == true) {
         return;
      }
      var node = this.m_fixtureList;
      var ppF = null;
      var found = false;
      while (node != null) {
         if (node == fixture) {
            if (ppF) ppF.m_next = fixture.m_next;
            else this.m_fixtureList = fixture.m_next;
            found = true;
            break;
         }
         ppF = node;
         node = node.m_next;
      }
      var edge = this.m_contactList;
      while (edge) {
         var c = edge.contact;
         edge = edge.next;
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         if (fixture == fixtureA || fixture == fixtureB) {
            this.m_world.m_contactManager.Destroy(c);
         }
      }
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.DestroyProxy(broadPhase);
      }
      else {}
      fixture.Destroy();
      fixture.m_body = null;
      fixture.m_next = null;
      --this.m_fixtureCount;
      this.ResetMassData();
   }
   b2Body.prototype.SetPositionAndAngle = function (position, angle) {
      if (angle === undefined) angle = 0;
      var f;
      if (this.m_world.IsLocked() == true) {
         return;
      }
      this.m_xf.R.Set(angle);
      this.m_xf.position.SetV(position);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_sweep.a0 = this.m_sweep.a = angle;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, this.m_xf, this.m_xf);
      }
      this.m_world.m_contactManager.FindNewContacts();
   }
   b2Body.prototype.SetTransform = function (xf) {
      this.SetPositionAndAngle(xf.position, xf.GetAngle());
   }
   b2Body.prototype.GetTransform = function () {
      return this.m_xf;
   }
   b2Body.prototype.GetPosition = function () {
      return this.m_xf.position;
   }
   b2Body.prototype.SetPosition = function (position) {
      this.SetPositionAndAngle(position, this.GetAngle());
   }
   b2Body.prototype.GetAngle = function () {
      return this.m_sweep.a;
   }
   b2Body.prototype.SetAngle = function (angle) {
      if (angle === undefined) angle = 0;
      this.SetPositionAndAngle(this.GetPosition(), angle);
   }
   b2Body.prototype.GetWorldCenter = function () {
      return this.m_sweep.c;
   }
   b2Body.prototype.GetLocalCenter = function () {
      return this.m_sweep.localCenter;
   }
   b2Body.prototype.SetLinearVelocity = function (v) {
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_linearVelocity.SetV(v);
   }
   b2Body.prototype.GetLinearVelocity = function () {
      return this.m_linearVelocity;
   }
   b2Body.prototype.SetAngularVelocity = function (omega) {
      if (omega === undefined) omega = 0;
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_angularVelocity = omega;
   }
   b2Body.prototype.GetAngularVelocity = function () {
      return this.m_angularVelocity;
   }
   b2Body.prototype.GetDefinition = function () {
      var bd = new b2BodyDef();
      bd.type = this.GetType();
      bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
      bd.angle = this.GetAngle();
      bd.angularDamping = this.m_angularDamping;
      bd.angularVelocity = this.m_angularVelocity;
      bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
      bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
      bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
      bd.linearDamping = this.m_linearDamping;
      bd.linearVelocity.SetV(this.GetLinearVelocity());
      bd.position = this.GetPosition();
      bd.userData = this.GetUserData();
      return bd;
   }
   b2Body.prototype.ApplyForce = function (force, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_force.x += force.x;
      this.m_force.y += force.y;
      this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
   }
   b2Body.prototype.ApplyTorque = function (torque) {
      if (torque === undefined) torque = 0;
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_torque += torque;
   }
   b2Body.prototype.ApplyImpulse = function (impulse, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_linearVelocity.x += this.m_invMass * impulse.x;
      this.m_linearVelocity.y += this.m_invMass * impulse.y;
      this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
   }
   b2Body.prototype.Split = function (callback) {
      var linearVelocity = this.GetLinearVelocity().Copy();
      var angularVelocity = this.GetAngularVelocity();
      var center = this.GetWorldCenter();
      var body1 = this;
      var body2 = this.m_world.CreateBody(this.GetDefinition());
      var prev;
      for (var f = body1.m_fixtureList; f;) {
         if (callback(f)) {
            var next = f.m_next;
            if (prev) {
               prev.m_next = next;
            }
            else {
               body1.m_fixtureList = next;
            }
            body1.m_fixtureCount--;
            f.m_next = body2.m_fixtureList;
            body2.m_fixtureList = f;
            body2.m_fixtureCount++;
            f.m_body = body2;
            f = next;
         }
         else {
            prev = f;
            f = f.m_next;
         }
      }
      body1.ResetMassData();
      body2.ResetMassData();
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
      var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
      body1.SetLinearVelocity(velocity1);
      body2.SetLinearVelocity(velocity2);
      body1.SetAngularVelocity(angularVelocity);
      body2.SetAngularVelocity(angularVelocity);
      body1.SynchronizeFixtures();
      body2.SynchronizeFixtures();
      return body2;
   }
   b2Body.prototype.Merge = function (other) {
      var f;
      for (f = other.m_fixtureList;
      f;) {
         var next = f.m_next;
         other.m_fixtureCount--;
         f.m_next = this.m_fixtureList;
         this.m_fixtureList = f;
         this.m_fixtureCount++;
         f.m_body = body2;
         f = next;
      }
      body1.m_fixtureCount = 0;
      var body1 = this;
      var body2 = other;
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = body1.GetLinearVelocity().Copy();
      var velocity2 = body2.GetLinearVelocity().Copy();
      var angular1 = body1.GetAngularVelocity();
      var angular = body2.GetAngularVelocity();
      body1.ResetMassData();
      this.SynchronizeFixtures();
   }
   b2Body.prototype.GetMass = function () {
      return this.m_mass;
   }
   b2Body.prototype.GetInertia = function () {
      return this.m_I;
   }
   b2Body.prototype.GetMassData = function (data) {
      data.mass = this.m_mass;
      data.I = this.m_I;
      data.center.SetV(this.m_sweep.localCenter);
   }
   b2Body.prototype.SetMassData = function (massData) {
      b2Settings.b2Assert(this.m_world.IsLocked() == false);
      if (this.m_world.IsLocked() == true) {
         return;
      }
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_mass = massData.mass;
      if (this.m_mass <= 0.0) {
         this.m_mass = 1.0;
      }
      this.m_invMass = 1.0 / this.m_mass;
      if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
         this.m_invI = 1.0 / this.m_I;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(massData.center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.ResetMassData = function () {
      this.m_mass = 0.0;
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_sweep.localCenter.SetZero();
      if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
         return;
      }
      var center = b2Vec2.Make(0, 0);
      for (var f = this.m_fixtureList; f; f = f.m_next) {
         if (f.m_density == 0.0) {
            continue;
         }
         var massData = f.GetMassData();
         this.m_mass += massData.mass;
         center.x += massData.center.x * massData.mass;
         center.y += massData.center.y * massData.mass;
         this.m_I += massData.I;
      }
      if (this.m_mass > 0.0) {
         this.m_invMass = 1.0 / this.m_mass;
         center.x *= this.m_invMass;
         center.y *= this.m_invMass;
      }
      else {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
         this.m_I *= this.m_inertiaScale;
         b2Settings.b2Assert(this.m_I > 0);
         this.m_invI = 1.0 / this.m_I;
      }
      else {
         this.m_I = 0.0;
         this.m_invI = 0.0;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.GetWorldPoint = function (localPoint) {
      var A = this.m_xf.R;
      var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      u.x += this.m_xf.position.x;
      u.y += this.m_xf.position.y;
      return u;
   }
   b2Body.prototype.GetWorldVector = function (localVector) {
      return b2Math.MulMV(this.m_xf.R, localVector);
   }
   b2Body.prototype.GetLocalPoint = function (worldPoint) {
      return b2Math.MulXT(this.m_xf, worldPoint);
   }
   b2Body.prototype.GetLocalVector = function (worldVector) {
      return b2Math.MulTMV(this.m_xf.R, worldVector);
   }
   b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
      var A = this.m_xf.R;
      var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      worldPoint.x += this.m_xf.position.x;
      worldPoint.y += this.m_xf.position.y;
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearDamping = function () {
      return this.m_linearDamping;
   }
   b2Body.prototype.SetLinearDamping = function (linearDamping) {
      if (linearDamping === undefined) linearDamping = 0;
      this.m_linearDamping = linearDamping;
   }
   b2Body.prototype.GetAngularDamping = function () {
      return this.m_angularDamping;
   }
   b2Body.prototype.SetAngularDamping = function (angularDamping) {
      if (angularDamping === undefined) angularDamping = 0;
      this.m_angularDamping = angularDamping;
   }
   b2Body.prototype.SetType = function (type) {
      if (type === undefined) type = 0;
      if (this.m_type == type) {
         return;
      }
      this.m_type = type;
      this.ResetMassData();
      if (this.m_type == b2Body.b2_staticBody) {
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
      }
      this.SetAwake(true);
      this.m_force.SetZero();
      this.m_torque = 0.0;
      for (var ce = this.m_contactList; ce; ce = ce.next) {
         ce.contact.FlagForFiltering();
      }
   }
   b2Body.prototype.GetType = function () {
      return this.m_type;
   }
   b2Body.prototype.SetBullet = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_bulletFlag;
      }
   }
   b2Body.prototype.IsBullet = function () {
      return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
   }
   b2Body.prototype.SetSleepingAllowed = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_allowSleepFlag;
         this.SetAwake(true);
      }
   }
   b2Body.prototype.SetAwake = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
      }
      else {
         this.m_flags &= ~b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
         this.m_force.SetZero();
         this.m_torque = 0.0;
      }
   }
   b2Body.prototype.IsAwake = function () {
      return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
   }
   b2Body.prototype.SetFixedRotation = function (fixed) {
      if (fixed) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_fixedRotationFlag;
      }
      this.ResetMassData();
   }
   b2Body.prototype.IsFixedRotation = function () {
      return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
   }
   b2Body.prototype.SetActive = function (flag) {
      if (flag == this.IsActive()) {
         return;
      }
      var broadPhase;
      var f;
      if (flag) {
         this.m_flags |= b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.CreateProxy(broadPhase, this.m_xf);
         }
      }
      else {
         this.m_flags &= ~b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.DestroyProxy(broadPhase);
         }
         var ce = this.m_contactList;
         while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
         }
         this.m_contactList = null;
      }
   }
   b2Body.prototype.IsActive = function () {
      return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
   }
   b2Body.prototype.IsSleepingAllowed = function () {
      return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
   }
   b2Body.prototype.GetFixtureList = function () {
      return this.m_fixtureList;
   }
   b2Body.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2Body.prototype.GetControllerList = function () {
      return this.m_controllerList;
   }
   b2Body.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2Body.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Body.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Body.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Body.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Body.prototype.b2Body = function (bd, world) {
      this.m_flags = 0;
      if (bd.bullet) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      if (bd.fixedRotation) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      if (bd.allowSleep) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      if (bd.awake) {
         this.m_flags |= b2Body.e_awakeFlag;
      }
      if (bd.active) {
         this.m_flags |= b2Body.e_activeFlag;
      }
      this.m_world = world;
      this.m_xf.position.SetV(bd.position);
      this.m_xf.R.Set(bd.angle);
      this.m_sweep.localCenter.SetZero();
      this.m_sweep.t0 = 1.0;
      this.m_sweep.a0 = this.m_sweep.a = bd.angle;
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_contactList = null;
      this.m_controllerCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_linearVelocity.SetV(bd.linearVelocity);
      this.m_angularVelocity = bd.angularVelocity;
      this.m_linearDamping = bd.linearDamping;
      this.m_angularDamping = bd.angularDamping;
      this.m_force.Set(0.0, 0.0);
      this.m_torque = 0.0;
      this.m_sleepTime = 0.0;
      this.m_type = bd.type;
      if (this.m_type == b2Body.b2_dynamicBody) {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      else {
         this.m_mass = 0.0;
         this.m_invMass = 0.0;
      }
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_inertiaScale = bd.inertiaScale;
      this.m_userData = bd.userData;
      this.m_fixtureList = null;
      this.m_fixtureCount = 0;
   }
   b2Body.prototype.SynchronizeFixtures = function () {
      var xf1 = b2Body.s_xf1;
      xf1.R.Set(this.m_sweep.a0);
      var tMat = xf1.R;
      var tVec = this.m_sweep.localCenter;
      xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var f;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, xf1, this.m_xf);
      }
   }
   b2Body.prototype.SynchronizeTransform = function () {
      this.m_xf.R.Set(this.m_sweep.a);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
   }
   b2Body.prototype.ShouldCollide = function (other) {
      if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
         return false;
      }
      for (var jn = this.m_jointList; jn; jn = jn.next) {
         if (jn.other == other) if (jn.joint.m_collideConnected == false) {
            return false;
         }
      }
      return true;
   }
   b2Body.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      this.m_sweep.Advance(t);
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_sweep.a = this.m_sweep.a0;
      this.SynchronizeTransform();
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
      Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
      Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
      Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
      Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
      Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
      Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
      Box2D.Dynamics.b2Body.b2_staticBody = 0;
      Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
      Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
   });
   b2BodyDef.b2BodyDef = function () {
      this.position = new b2Vec2();
      this.linearVelocity = new b2Vec2();
   };
   b2BodyDef.prototype.b2BodyDef = function () {
      this.userData = null;
      this.position.Set(0.0, 0.0);
      this.angle = 0.0;
      this.linearVelocity.Set(0, 0);
      this.angularVelocity = 0.0;
      this.linearDamping = 0.0;
      this.angularDamping = 0.0;
      this.allowSleep = true;
      this.awake = true;
      this.fixedRotation = false;
      this.bullet = false;
      this.type = b2Body.b2_staticBody;
      this.active = true;
      this.inertiaScale = 1.0;
   }
   b2ContactFilter.b2ContactFilter = function () {};
   b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
      var filter1 = fixtureA.GetFilterData();
      var filter2 = fixtureB.GetFilterData();
      if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
         return filter1.groupIndex > 0;
      }
      var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
      return collide;
   }
   b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
      if (!userData) return true;
      return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
   });
   b2ContactImpulse.b2ContactImpulse = function () {
      this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
   };
   b2ContactListener.b2ContactListener = function () {};
   b2ContactListener.prototype.BeginContact = function (contact) {}
   b2ContactListener.prototype.EndContact = function (contact) {}
   b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
   b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
   });
   b2ContactManager.b2ContactManager = function () {};
   b2ContactManager.prototype.b2ContactManager = function () {
      this.m_world = null;
      this.m_contactCount = 0;
      this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
      this.m_contactListener = b2ContactListener.b2_defaultListener;
      this.m_contactFactory = new b2ContactFactory(this.m_allocator);
      this.m_broadPhase = new b2DynamicTreeBroadPhase();
   }
   b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
      var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
      var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA == bodyB) return;
      var edge = bodyB.GetContactList();
      while (edge) {
         if (edge.other == bodyA) {
            var fA = edge.contact.GetFixtureA();
            var fB = edge.contact.GetFixtureB();
            if (fA == fixtureA && fB == fixtureB) return;
            if (fA == fixtureB && fB == fixtureA) return;
         }
         edge = edge.next;
      }
      if (bodyB.ShouldCollide(bodyA) == false) {
         return;
      }
      if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
         return;
      }
      var c = this.m_contactFactory.Create(fixtureA, fixtureB);
      fixtureA = c.GetFixtureA();
      fixtureB = c.GetFixtureB();
      bodyA = fixtureA.m_body;
      bodyB = fixtureB.m_body;
      c.m_prev = null;
      c.m_next = this.m_world.m_contactList;
      if (this.m_world.m_contactList != null) {
         this.m_world.m_contactList.m_prev = c;
      }
      this.m_world.m_contactList = c;
      c.m_nodeA.contact = c;
      c.m_nodeA.other = bodyB;
      c.m_nodeA.prev = null;
      c.m_nodeA.next = bodyA.m_contactList;
      if (bodyA.m_contactList != null) {
         bodyA.m_contactList.prev = c.m_nodeA;
      }
      bodyA.m_contactList = c.m_nodeA;
      c.m_nodeB.contact = c;
      c.m_nodeB.other = bodyA;
      c.m_nodeB.prev = null;
      c.m_nodeB.next = bodyB.m_contactList;
      if (bodyB.m_contactList != null) {
         bodyB.m_contactList.prev = c.m_nodeB;
      }
      bodyB.m_contactList = c.m_nodeB;
      ++this.m_world.m_contactCount;
      return;
   }
   b2ContactManager.prototype.FindNewContacts = function () {
      this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
   }
   b2ContactManager.prototype.Destroy = function (c) {
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (c.IsTouching()) {
         this.m_contactListener.EndContact(c);
      }
      if (c.m_prev) {
         c.m_prev.m_next = c.m_next;
      }
      if (c.m_next) {
         c.m_next.m_prev = c.m_prev;
      }
      if (c == this.m_world.m_contactList) {
         this.m_world.m_contactList = c.m_next;
      }
      if (c.m_nodeA.prev) {
         c.m_nodeA.prev.next = c.m_nodeA.next;
      }
      if (c.m_nodeA.next) {
         c.m_nodeA.next.prev = c.m_nodeA.prev;
      }
      if (c.m_nodeA == bodyA.m_contactList) {
         bodyA.m_contactList = c.m_nodeA.next;
      }
      if (c.m_nodeB.prev) {
         c.m_nodeB.prev.next = c.m_nodeB.next;
      }
      if (c.m_nodeB.next) {
         c.m_nodeB.next.prev = c.m_nodeB.prev;
      }
      if (c.m_nodeB == bodyB.m_contactList) {
         bodyB.m_contactList = c.m_nodeB.next;
      }
      this.m_contactFactory.Destroy(c);
      --this.m_contactCount;
   }
   b2ContactManager.prototype.Collide = function () {
      var c = this.m_world.m_contactList;
      while (c) {
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         var bodyA = fixtureA.GetBody();
         var bodyB = fixtureB.GetBody();
         if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
            c = c.GetNext();
            continue;
         }
         if (c.m_flags & b2Contact.e_filterFlag) {
            if (bodyB.ShouldCollide(bodyA) == false) {
               var cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
               cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            c.m_flags &= ~b2Contact.e_filterFlag;
         }
         var proxyA = fixtureA.m_proxy;
         var proxyB = fixtureB.m_proxy;
         var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
         if (overlap == false) {
            cNuke = c;
            c = cNuke.GetNext();
            this.Destroy(cNuke);
            continue;
         }
         c.Update(this.m_contactListener);
         c = c.GetNext();
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
   });
   b2DebugDraw.b2DebugDraw = function () {};
   b2DebugDraw.prototype.b2DebugDraw = function () {}
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.GetFlags = function () {}
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.SetSprite = function (sprite) {}
   b2DebugDraw.prototype.GetSprite = function () {}
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
   }
   b2DebugDraw.prototype.GetDrawScale = function () {}
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
   }
   b2DebugDraw.prototype.GetLineThickness = function () {}
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetAlpha = function () {}
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetFillAlpha = function () {}
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
   }
   b2DebugDraw.prototype.GetXFormScale = function () {}
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
   b2DebugDraw.prototype.DrawTransform = function (xf) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
      Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
      Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
      Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
      Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
      Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
   });
   b2DestructionListener.b2DestructionListener = function () {};
   b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
   b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
   b2FilterData.b2FilterData = function () {
      this.categoryBits = 0x0001;
      this.maskBits = 0xFFFF;
      this.groupIndex = 0;
   };
   b2FilterData.prototype.Copy = function () {
      var copy = new b2FilterData();
      copy.categoryBits = this.categoryBits;
      copy.maskBits = this.maskBits;
      copy.groupIndex = this.groupIndex;
      return copy;
   }
   b2Fixture.b2Fixture = function () {
      this.m_filter = new b2FilterData();
   };
   b2Fixture.prototype.GetType = function () {
      return this.m_shape.GetType();
   }
   b2Fixture.prototype.GetShape = function () {
      return this.m_shape;
   }
   b2Fixture.prototype.SetSensor = function (sensor) {
      if (this.m_isSensor == sensor) return;
      this.m_isSensor = sensor;
      if (this.m_body == null) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
         edge = edge.next;
      }
   }
   b2Fixture.prototype.IsSensor = function () {
      return this.m_isSensor;
   }
   b2Fixture.prototype.SetFilterData = function (filter) {
      this.m_filter = filter.Copy();
      if (this.m_body) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
         edge = edge.next;
      }
   }
   b2Fixture.prototype.GetFilterData = function () {
      return this.m_filter.Copy();
   }
   b2Fixture.prototype.GetBody = function () {
      return this.m_body;
   }
   b2Fixture.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Fixture.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Fixture.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Fixture.prototype.TestPoint = function (p) {
      return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
   }
   b2Fixture.prototype.RayCast = function (output, input) {
      return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
   }
   b2Fixture.prototype.GetMassData = function (massData) {
      if (massData === undefined) massData = null;
      if (massData == null) {
         massData = new b2MassData();
      }
      this.m_shape.ComputeMass(massData, this.m_density);
      return massData;
   }
   b2Fixture.prototype.SetDensity = function (density) {
      if (density === undefined) density = 0;
      this.m_density = density;
   }
   b2Fixture.prototype.GetDensity = function () {
      return this.m_density;
   }
   b2Fixture.prototype.GetFriction = function () {
      return this.m_friction;
   }
   b2Fixture.prototype.SetFriction = function (friction) {
      if (friction === undefined) friction = 0;
      this.m_friction = friction;
   }
   b2Fixture.prototype.GetRestitution = function () {
      return this.m_restitution;
   }
   b2Fixture.prototype.SetRestitution = function (restitution) {
      if (restitution === undefined) restitution = 0;
      this.m_restitution = restitution;
   }
   b2Fixture.prototype.GetAABB = function () {
      return this.m_aabb;
   }
   b2Fixture.prototype.b2Fixture = function () {
      this.m_aabb = new b2AABB();
      this.m_userData = null;
      this.m_body = null;
      this.m_next = null;
      this.m_shape = null;
      this.m_density = 0.0;
      this.m_friction = 0.0;
      this.m_restitution = 0.0;
   }
   b2Fixture.prototype.Create = function (body, xf, def) {
      this.m_userData = def.userData;
      this.m_friction = def.friction;
      this.m_restitution = def.restitution;
      this.m_body = body;
      this.m_next = null;
      this.m_filter = def.filter.Copy();
      this.m_isSensor = def.isSensor;
      this.m_shape = def.shape.Copy();
      this.m_density = def.density;
   }
   b2Fixture.prototype.Destroy = function () {
      this.m_shape = null;
   }
   b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
      this.m_shape.ComputeAABB(this.m_aabb, xf);
      this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
   }
   b2Fixture.prototype.DestroyProxy = function (broadPhase) {
      if (this.m_proxy == null) {
         return;
      }
      broadPhase.DestroyProxy(this.m_proxy);
      this.m_proxy = null;
   }
   b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
      if (!this.m_proxy) return;
      var aabb1 = new b2AABB();
      var aabb2 = new b2AABB();
      this.m_shape.ComputeAABB(aabb1, transform1);
      this.m_shape.ComputeAABB(aabb2, transform2);
      this.m_aabb.Combine(aabb1, aabb2);
      var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
      broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
   }
   b2FixtureDef.b2FixtureDef = function () {
      this.filter = new b2FilterData();
   };
   b2FixtureDef.prototype.b2FixtureDef = function () {
      this.shape = null;
      this.userData = null;
      this.friction = 0.2;
      this.restitution = 0.0;
      this.density = 0.0;
      this.filter.categoryBits = 0x0001;
      this.filter.maskBits = 0xFFFF;
      this.filter.groupIndex = 0;
      this.isSensor = false;
   }
   b2Island.b2Island = function () {};
   b2Island.prototype.b2Island = function () {
      this.m_bodies = new Vector();
      this.m_contacts = new Vector();
      this.m_joints = new Vector();
   }
   b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
      if (bodyCapacity === undefined) bodyCapacity = 0;
      if (contactCapacity === undefined) contactCapacity = 0;
      if (jointCapacity === undefined) jointCapacity = 0;
      var i = 0;
      this.m_bodyCapacity = bodyCapacity;
      this.m_contactCapacity = contactCapacity;
      this.m_jointCapacity = jointCapacity;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_allocator = allocator;
      this.m_listener = listener;
      this.m_contactSolver = contactSolver;
      for (i = this.m_bodies.length;
      i < bodyCapacity; i++)
      this.m_bodies[i] = null;
      for (i = this.m_contacts.length;
      i < contactCapacity; i++)
      this.m_contacts[i] = null;
      for (i = this.m_joints.length;
      i < jointCapacity; i++)
      this.m_joints[i] = null;
   }
   b2Island.prototype.Clear = function () {
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
   }
   b2Island.prototype.Solve = function (step, gravity, allowSleep) {
      var i = 0;
      var j = 0;
      var b;
      var joint;
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() != b2Body.b2_dynamicBody) continue;
         b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
         b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
         b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
         b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
         b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
      }
      this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      contactSolver.InitVelocityConstraints(step);
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.InitVelocityConstraints(step);
      }
      for (i = 0;
      i < step.velocityIterations; ++i) {
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            joint.SolveVelocityConstraints(step);
         }
         contactSolver.SolveVelocityConstraints();
      }
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.FinalizeVelocityConstraints();
      }
      contactSolver.FinalizeVelocityConstraints();
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = step.dt * b.m_linearVelocity.x;
         var translationY = step.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
         }
         var rotation = step.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
         b.m_sweep.a += step.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      for (i = 0;
      i < step.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
      if (allowSleep) {
         var minSleepTime = Number.MAX_VALUE;
         var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
         var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
         for (i = 0;
         i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            else {
               b.m_sleepTime += step.dt;
               minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
            }
         }
         if (minSleepTime >= b2Settings.b2_timeToSleep) {
            for (i = 0;
            i < this.m_bodyCount; ++i) {
               b = this.m_bodies[i];
               b.SetAwake(false);
            }
         }
      }
   }
   b2Island.prototype.SolveTOI = function (subStep) {
      var i = 0;
      var j = 0;
      this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      for (i = 0;
      i < this.m_jointCount; ++i) {
         this.m_joints[i].InitVelocityConstraints(subStep);
      }
      for (i = 0;
      i < subStep.velocityIterations; ++i) {
         contactSolver.SolveVelocityConstraints();
         for (j = 0;
         j < this.m_jointCount; ++j) {
            this.m_joints[j].SolveVelocityConstraints(subStep);
         }
      }
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         var b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = subStep.dt * b.m_linearVelocity.x;
         var translationY = subStep.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
         }
         var rotation = subStep.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
         b.m_sweep.a += subStep.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      var k_toiBaumgarte = 0.75;
      for (i = 0;
      i < subStep.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
   }
   b2Island.prototype.Report = function (constraints) {
      if (this.m_listener == null) {
         return;
      }
      for (var i = 0; i < this.m_contactCount; ++i) {
         var c = this.m_contacts[i];
         var cc = constraints[i];
         for (var j = 0; j < cc.pointCount; ++j) {
            b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
            b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
         }
         this.m_listener.PostSolve(c, b2Island.s_impulse);
      }
   }
   b2Island.prototype.AddBody = function (body) {
      body.m_islandIndex = this.m_bodyCount;
      this.m_bodies[this.m_bodyCount++] = body;
   }
   b2Island.prototype.AddContact = function (contact) {
      this.m_contacts[this.m_contactCount++] = contact;
   }
   b2Island.prototype.AddJoint = function (joint) {
      this.m_joints[this.m_jointCount++] = joint;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
   });
   b2TimeStep.b2TimeStep = function () {};
   b2TimeStep.prototype.Set = function (step) {
      this.dt = step.dt;
      this.inv_dt = step.inv_dt;
      this.positionIterations = step.positionIterations;
      this.velocityIterations = step.velocityIterations;
      this.warmStarting = step.warmStarting;
   }
   b2World.b2World = function () {
      this.s_stack = new Vector();
      this.m_contactManager = new b2ContactManager();
      this.m_contactSolver = new b2ContactSolver();
      this.m_island = new b2Island();
   };
   b2World.prototype.b2World = function (gravity, doSleep) {
      this.m_destructionListener = null;
      this.m_debugDraw = null;
      this.m_bodyList = null;
      this.m_contactList = null;
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_controllerCount = 0;
      b2World.m_warmStarting = true;
      b2World.m_continuousPhysics = true;
      this.m_allowSleep = doSleep;
      this.m_gravity = gravity;
      this.m_inv_dt0 = 0.0;
      this.m_contactManager.m_world = this;
      var bd = new b2BodyDef();
      this.m_groundBody = this.CreateBody(bd);
   }
   b2World.prototype.SetDestructionListener = function (listener) {
      this.m_destructionListener = listener;
   }
   b2World.prototype.SetContactFilter = function (filter) {
      this.m_contactManager.m_contactFilter = filter;
   }
   b2World.prototype.SetContactListener = function (listener) {
      this.m_contactManager.m_contactListener = listener;
   }
   b2World.prototype.SetDebugDraw = function (debugDraw) {
      this.m_debugDraw = debugDraw;
   }
   b2World.prototype.SetBroadPhase = function (broadPhase) {
      var oldBroadPhase = this.m_contactManager.m_broadPhase;
      this.m_contactManager.m_broadPhase = broadPhase;
      for (var b = this.m_bodyList; b; b = b.m_next) {
         for (var f = b.m_fixtureList; f; f = f.m_next) {
            f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
         }
      }
   }
   b2World.prototype.Validate = function () {
      this.m_contactManager.m_broadPhase.Validate();
   }
   b2World.prototype.GetProxyCount = function () {
      return this.m_contactManager.m_broadPhase.GetProxyCount();
   }
   b2World.prototype.CreateBody = function (def) {
      if (this.IsLocked() == true) {
         return null;
      }
      var b = new b2Body(def, this);
      b.m_prev = null;
      b.m_next = this.m_bodyList;
      if (this.m_bodyList) {
         this.m_bodyList.m_prev = b;
      }
      this.m_bodyList = b;
      ++this.m_bodyCount;
      return b;
   }
   b2World.prototype.DestroyBody = function (b) {
      if (this.IsLocked() == true) {
         return;
      }
      var jn = b.m_jointList;
      while (jn) {
         var jn0 = jn;
         jn = jn.next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
         }
         this.DestroyJoint(jn0.joint);
      }
      var coe = b.m_controllerList;
      while (coe) {
         var coe0 = coe;
         coe = coe.nextController;
         coe0.controller.RemoveBody(b);
      }
      var ce = b.m_contactList;
      while (ce) {
         var ce0 = ce;
         ce = ce.next;
         this.m_contactManager.Destroy(ce0.contact);
      }
      b.m_contactList = null;
      var f = b.m_fixtureList;
      while (f) {
         var f0 = f;
         f = f.m_next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeFixture(f0);
         }
         f0.DestroyProxy(this.m_contactManager.m_broadPhase);
         f0.Destroy();
      }
      b.m_fixtureList = null;
      b.m_fixtureCount = 0;
      if (b.m_prev) {
         b.m_prev.m_next = b.m_next;
      }
      if (b.m_next) {
         b.m_next.m_prev = b.m_prev;
      }
      if (b == this.m_bodyList) {
         this.m_bodyList = b.m_next;
      }--this.m_bodyCount;
   }
   b2World.prototype.CreateJoint = function (def) {
      var j = b2Joint.Create(def, null);
      j.m_prev = null;
      j.m_next = this.m_jointList;
      if (this.m_jointList) {
         this.m_jointList.m_prev = j;
      }
      this.m_jointList = j;
      ++this.m_jointCount;
      j.m_edgeA.joint = j;
      j.m_edgeA.other = j.m_bodyB;
      j.m_edgeA.prev = null;
      j.m_edgeA.next = j.m_bodyA.m_jointList;
      if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
      j.m_bodyA.m_jointList = j.m_edgeA;
      j.m_edgeB.joint = j;
      j.m_edgeB.other = j.m_bodyA;
      j.m_edgeB.prev = null;
      j.m_edgeB.next = j.m_bodyB.m_jointList;
      if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
      j.m_bodyB.m_jointList = j.m_edgeB;
      var bodyA = def.bodyA;
      var bodyB = def.bodyB;
      if (def.collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
      return j;
   }
   b2World.prototype.DestroyJoint = function (j) {
      var collideConnected = j.m_collideConnected;
      if (j.m_prev) {
         j.m_prev.m_next = j.m_next;
      }
      if (j.m_next) {
         j.m_next.m_prev = j.m_prev;
      }
      if (j == this.m_jointList) {
         this.m_jointList = j.m_next;
      }
      var bodyA = j.m_bodyA;
      var bodyB = j.m_bodyB;
      bodyA.SetAwake(true);
      bodyB.SetAwake(true);
      if (j.m_edgeA.prev) {
         j.m_edgeA.prev.next = j.m_edgeA.next;
      }
      if (j.m_edgeA.next) {
         j.m_edgeA.next.prev = j.m_edgeA.prev;
      }
      if (j.m_edgeA == bodyA.m_jointList) {
         bodyA.m_jointList = j.m_edgeA.next;
      }
      j.m_edgeA.prev = null;
      j.m_edgeA.next = null;
      if (j.m_edgeB.prev) {
         j.m_edgeB.prev.next = j.m_edgeB.next;
      }
      if (j.m_edgeB.next) {
         j.m_edgeB.next.prev = j.m_edgeB.prev;
      }
      if (j.m_edgeB == bodyB.m_jointList) {
         bodyB.m_jointList = j.m_edgeB.next;
      }
      j.m_edgeB.prev = null;
      j.m_edgeB.next = null;
      b2Joint.Destroy(j, null);
      --this.m_jointCount;
      if (collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
   }
   b2World.prototype.AddController = function (c) {
      c.m_next = this.m_controllerList;
      c.m_prev = null;
      this.m_controllerList = c;
      c.m_world = this;
      this.m_controllerCount++;
      return c;
   }
   b2World.prototype.RemoveController = function (c) {
      if (c.m_prev) c.m_prev.m_next = c.m_next;
      if (c.m_next) c.m_next.m_prev = c.m_prev;
      if (this.m_controllerList == c) this.m_controllerList = c.m_next;
      this.m_controllerCount--;
   }
   b2World.prototype.CreateController = function (controller) {
      if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
      controller.m_next = this.m_controllerList;
      controller.m_prev = null;
      if (this.m_controllerList) this.m_controllerList.m_prev = controller;
      this.m_controllerList = controller;
      ++this.m_controllerCount;
      controller.m_world = this;
      return controller;
   }
   b2World.prototype.DestroyController = function (controller) {
      controller.Clear();
      if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
      if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
      if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
      --this.m_controllerCount;
   }
   b2World.prototype.SetWarmStarting = function (flag) {
      b2World.m_warmStarting = flag;
   }
   b2World.prototype.SetContinuousPhysics = function (flag) {
      b2World.m_continuousPhysics = flag;
   }
   b2World.prototype.GetBodyCount = function () {
      return this.m_bodyCount;
   }
   b2World.prototype.GetJointCount = function () {
      return this.m_jointCount;
   }
   b2World.prototype.GetContactCount = function () {
      return this.m_contactCount;
   }
   b2World.prototype.SetGravity = function (gravity) {
      this.m_gravity = gravity;
   }
   b2World.prototype.GetGravity = function () {
      return this.m_gravity;
   }
   b2World.prototype.GetGroundBody = function () {
      return this.m_groundBody;
   }
   b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
      if (dt === undefined) dt = 0;
      if (velocityIterations === undefined) velocityIterations = 0;
      if (positionIterations === undefined) positionIterations = 0;
      if (this.m_flags & b2World.e_newFixture) {
         this.m_contactManager.FindNewContacts();
         this.m_flags &= ~b2World.e_newFixture;
      }
      this.m_flags |= b2World.e_locked;
      var step = b2World.s_timestep2;
      step.dt = dt;
      step.velocityIterations = velocityIterations;
      step.positionIterations = positionIterations;
      if (dt > 0.0) {
         step.inv_dt = 1.0 / dt;
      }
      else {
         step.inv_dt = 0.0;
      }
      step.dtRatio = this.m_inv_dt0 * dt;
      step.warmStarting = b2World.m_warmStarting;
      this.m_contactManager.Collide();
      if (step.dt > 0.0) {
         this.Solve(step);
      }
      if (b2World.m_continuousPhysics && step.dt > 0.0) {
         this.SolveTOI(step);
      }
      if (step.dt > 0.0) {
         this.m_inv_dt0 = step.inv_dt;
      }
      this.m_flags &= ~b2World.e_locked;
   }
   b2World.prototype.ClearForces = function () {
      for (var body = this.m_bodyList; body; body = body.m_next) {
         body.m_force.SetZero();
         body.m_torque = 0.0;
      }
   }
   b2World.prototype.DrawDebugData = function () {
      if (this.m_debugDraw == null) {
         return;
      }
      this.m_debugDraw.m_sprite.graphics.clear();
      var flags = this.m_debugDraw.GetFlags();
      var i = 0;
      var b;
      var f;
      var s;
      var j;
      var bp;
      var invQ = new b2Vec2;
      var x1 = new b2Vec2;
      var x2 = new b2Vec2;
      var xf;
      var b1 = new b2AABB();
      var b2 = new b2AABB();
      var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
      var color = new b2Color(0, 0, 0);
      if (flags & b2DebugDraw.e_shapeBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b.m_xf;
            for (f = b.GetFixtureList();
            f; f = f.m_next) {
               s = f.GetShape();
               if (b.IsActive() == false) {
                  color.Set(0.5, 0.5, 0.3);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_staticBody) {
                  color.Set(0.5, 0.9, 0.5);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_kinematicBody) {
                  color.Set(0.5, 0.5, 0.9);
                  this.DrawShape(s, xf, color);
               }
               else if (b.IsAwake() == false) {
                  color.Set(0.6, 0.6, 0.6);
                  this.DrawShape(s, xf, color);
               }
               else {
                  color.Set(0.9, 0.7, 0.7);
                  this.DrawShape(s, xf, color);
               }
            }
         }
      }
      if (flags & b2DebugDraw.e_jointBit) {
         for (j = this.m_jointList;
         j; j = j.m_next) {
            this.DrawJoint(j);
         }
      }
      if (flags & b2DebugDraw.e_controllerBit) {
         for (var c = this.m_controllerList; c; c = c.m_next) {
            c.Draw(this.m_debugDraw);
         }
      }
      if (flags & b2DebugDraw.e_pairBit) {
         color.Set(0.3, 0.9, 0.9);
         for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            var cA = fixtureA.GetAABB().GetCenter();
            var cB = fixtureB.GetAABB().GetCenter();
            this.m_debugDraw.DrawSegment(cA, cB, color);
         }
      }
      if (flags & b2DebugDraw.e_aabbBit) {
         bp = this.m_contactManager.m_broadPhase;
         vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
         for (b = this.m_bodyList;
         b; b = b.GetNext()) {
            if (b.IsActive() == false) {
               continue;
            }
            for (f = b.GetFixtureList();
            f; f = f.GetNext()) {
               var aabb = bp.GetFatAABB(f.m_proxy);
               vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
               vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
               vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
               vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
               this.m_debugDraw.DrawPolygon(vs, 4, color);
            }
         }
      }
      if (flags & b2DebugDraw.e_centerOfMassBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b2World.s_xf;
            xf.R = b.m_xf.R;
            xf.position = b.GetWorldCenter();
            this.m_debugDraw.DrawTransform(xf);
         }
      }
   }
   b2World.prototype.QueryAABB = function (callback, aabb) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         return callback(broadPhase.GetUserData(proxy));
      };
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryShape = function (callback, shape, transform) {
      var __this = this;
      if (transform === undefined) transform = null;
      if (transform == null) {
         transform = new b2Transform();
         transform.SetIdentity();
      }
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      shape.ComputeAABB(aabb, transform);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryPoint = function (callback, p) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (fixture.TestPoint(p)) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
      aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.RayCast = function (callback, point1, point2) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;
      var output = new b2RayCastOutput;

      function RayCastWrapper(input, proxy) {
         var userData = broadPhase.GetUserData(proxy);
         var fixture = (userData instanceof b2Fixture ? userData : null);
         var hit = fixture.RayCast(output, input);
         if (hit) {
            var fraction = output.fraction;
            var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
            return callback(fixture, point, output.normal, fraction);
         }
         return input.maxFraction;
      };
      var input = new b2RayCastInput(point1, point2);
      broadPhase.RayCast(RayCastWrapper, input);
   }
   b2World.prototype.RayCastOne = function (point1, point2) {
      var __this = this;
      var result;

      function RayCastOneWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result = fixture;
         return fraction;
      };
      __this.RayCast(RayCastOneWrapper, point1, point2);
      return result;
   }
   b2World.prototype.RayCastAll = function (point1, point2) {
      var __this = this;
      var result = new Vector();

      function RayCastAllWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result[result.length] = fixture;
         return 1;
      };
      __this.RayCast(RayCastAllWrapper, point1, point2);
      return result;
   }
   b2World.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2World.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2World.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2World.prototype.IsLocked = function () {
      return (this.m_flags & b2World.e_locked) > 0;
   }
   b2World.prototype.Solve = function (step) {
      var b;
      for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
         controller.Step(step);
      }
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
      }
      for (var c = this.m_contactList; c; c = c.m_next) {
         c.m_flags &= ~b2Contact.e_islandFlag;
      }
      for (var j = this.m_jointList; j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      var stackSize = parseInt(this.m_bodyCount);
      var stack = this.s_stack;
      for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
         if (seed.m_flags & b2Body.e_islandFlag) {
            continue;
         }
         if (seed.IsAwake() == false || seed.IsActive() == false) {
            continue;
         }
         if (seed.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         island.Clear();
         var stackCount = 0;
         stack[stackCount++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (stackCount > 0) {
            b = stack[--stackCount];
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            var other;
            for (var ce = b.m_contactList; ce; ce = ce.next) {
               if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(ce.contact);
               ce.contact.m_flags |= b2Contact.e_islandFlag;
               other = ce.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jn = b.m_jointList; jn; jn = jn.next) {
               if (jn.joint.m_islandFlag == true) {
                  continue;
               }
               other = jn.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jn.joint);
               jn.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         island.Solve(step, this.m_gravity, this.m_allowSleep);
         for (var i = 0; i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               b.m_flags &= ~b2Body.e_islandFlag;
            }
         }
      }
      for (i = 0;
      i < stack.length; ++i) {
         if (!stack[i]) break;
         stack[i] = null;
      }
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         if (b.IsAwake() == false || b.IsActive() == false) {
            continue;
         }
         if (b.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         b.SynchronizeFixtures();
      }
      this.m_contactManager.FindNewContacts();
   }
   b2World.prototype.SolveTOI = function (step) {
      var b;
      var fA;
      var fB;
      var bA;
      var bB;
      var cEdge;
      var j;
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      var queue = b2World.s_queue;
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
         b.m_sweep.t0 = 0.0;
      }
      var c;
      for (c = this.m_contactList;
      c; c = c.m_next) {
         c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
      }
      for (j = this.m_jointList;
      j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      for (;;) {
         var minContact = null;
         var minTOI = 1.0;
         for (c = this.m_contactList;
         c; c = c.m_next) {
            if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
               continue;
            }
            var toi = 1.0;
            if (c.m_flags & b2Contact.e_toiFlag) {
               toi = c.m_toi;
            }
            else {
               fA = c.m_fixtureA;
               fB = c.m_fixtureB;
               bA = fA.m_body;
               bB = fB.m_body;
               if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                  continue;
               }
               var t0 = bA.m_sweep.t0;
               if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                  t0 = bB.m_sweep.t0;
                  bA.m_sweep.Advance(t0);
               }
               else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                  t0 = bA.m_sweep.t0;
                  bB.m_sweep.Advance(t0);
               }
               toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
               b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
               if (toi > 0.0 && toi < 1.0) {
                  toi = (1.0 - toi) * t0 + toi;
                  if (toi > 1) toi = 1;
               }
               c.m_toi = toi;
               c.m_flags |= b2Contact.e_toiFlag;
            }
            if (Number.MIN_VALUE < toi && toi < minTOI) {
               minContact = c;
               minTOI = toi;
            }
         }
         if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
            break;
         }
         fA = minContact.m_fixtureA;
         fB = minContact.m_fixtureB;
         bA = fA.m_body;
         bB = fB.m_body;
         b2World.s_backupA.Set(bA.m_sweep);
         b2World.s_backupB.Set(bB.m_sweep);
         bA.Advance(minTOI);
         bB.Advance(minTOI);
         minContact.Update(this.m_contactManager.m_contactListener);
         minContact.m_flags &= ~b2Contact.e_toiFlag;
         if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
            bA.m_sweep.Set(b2World.s_backupA);
            bB.m_sweep.Set(b2World.s_backupB);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
            continue;
         }
         if (minContact.IsTouching() == false) {
            continue;
         }
         var seed = bA;
         if (seed.GetType() != b2Body.b2_dynamicBody) {
            seed = bB;
         }
         island.Clear();
         var queueStart = 0;
         var queueSize = 0;
         queue[queueStart + queueSize++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (queueSize > 0) {
            b = queue[queueStart++];
            --queueSize;
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               if (island.m_contactCount == island.m_contactCapacity) {
                  break;
               }
               if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(cEdge.contact);
               cEdge.contact.m_flags |= b2Contact.e_islandFlag;
               var other = cEdge.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
               if (island.m_jointCount == island.m_jointCapacity) continue;
               if (jEdge.joint.m_islandFlag == true) continue;
               other = jEdge.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jEdge.joint);
               jEdge.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) continue;
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         var subStep = b2World.s_timestep;
         subStep.warmStarting = false;
         subStep.dt = (1.0 - minTOI) * step.dt;
         subStep.inv_dt = 1.0 / subStep.dt;
         subStep.dtRatio = 0.0;
         subStep.velocityIterations = step.velocityIterations;
         subStep.positionIterations = step.positionIterations;
         island.SolveTOI(subStep);
         var i = 0;
         for (i = 0;
         i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            b.m_flags &= ~b2Body.e_islandFlag;
            if (b.IsAwake() == false) {
               continue;
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            b.SynchronizeFixtures();
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
            }
         }
         for (i = 0;
         i < island.m_contactCount; ++i) {
            c = island.m_contacts[i];
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
         }
         for (i = 0;
         i < island.m_jointCount; ++i) {
            j = island.m_joints[i];
            j.m_islandFlag = false;
         }
         this.m_contactManager.FindNewContacts();
      }
   }
   b2World.prototype.DrawJoint = function (joint) {
      var b1 = joint.GetBodyA();
      var b2 = joint.GetBodyB();
      var xf1 = b1.m_xf;
      var xf2 = b2.m_xf;
      var x1 = xf1.position;
      var x2 = xf2.position;
      var p1 = joint.GetAnchorA();
      var p2 = joint.GetAnchorB();
      var color = b2World.s_jointColor;
      switch (joint.m_type) {
      case b2Joint.e_distanceJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      case b2Joint.e_pulleyJoint:
         {
            var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(s1, p1, color);
            this.m_debugDraw.DrawSegment(s2, p2, color);
            this.m_debugDraw.DrawSegment(s1, s2, color);
         }
         break;
      case b2Joint.e_mouseJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      default:
         if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
         this.m_debugDraw.DrawSegment(p1, p2, color);
         if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
      }
   }
   b2World.prototype.DrawShape = function (shape, xf, color) {
      switch (shape.m_type) {
      case b2Shape.e_circleShape:
         {
            var circle = ((shape instanceof b2CircleShape ? shape : null));
            var center = b2Math.MulX(xf, circle.m_p);
            var radius = circle.m_radius;
            var axis = xf.R.col1;
            this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var i = 0;
            var poly = ((shape instanceof b2PolygonShape ? shape : null));
            var vertexCount = parseInt(poly.GetVertexCount());
            var localVertices = poly.GetVertices();
            var vertices = new Vector(vertexCount);
            for (i = 0;
            i < vertexCount; ++i) {
               vertices[i] = b2Math.MulX(xf, localVertices[i]);
            }
            this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
         }
         break;
      case b2Shape.e_edgeShape:
         {
            var edge = (shape instanceof b2EdgeShape ? shape : null);
            this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
      Box2D.Dynamics.b2World.s_xf = new b2Transform();
      Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
      Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
      Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
      Box2D.Dynamics.b2World.s_queue = new Vector();
      Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
      Box2D.Dynamics.b2World.e_newFixture = 0x0001;
      Box2D.Dynamics.b2World.e_locked = 0x0002;
   });
})();
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2CircleContact.b2CircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2CircleContact.Create = function (allocator) {
      return new b2CircleContact();
   }
   b2CircleContact.Destroy = function (contact, allocator) {}
   b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2CircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2Contact.b2Contact = function () {
      this.m_nodeA = new b2ContactEdge();
      this.m_nodeB = new b2ContactEdge();
      this.m_manifold = new b2Manifold();
      this.m_oldManifold = new b2Manifold();
   };
   b2Contact.prototype.GetManifold = function () {
      return this.m_manifold;
   }
   b2Contact.prototype.GetWorldManifold = function (worldManifold) {
      var bodyA = this.m_fixtureA.GetBody();
      var bodyB = this.m_fixtureB.GetBody();
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
   }
   b2Contact.prototype.IsTouching = function () {
      return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
   }
   b2Contact.prototype.IsContinuous = function () {
      return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
   }
   b2Contact.prototype.SetSensor = function (sensor) {
      if (sensor) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_sensorFlag;
      }
   }
   b2Contact.prototype.IsSensor = function () {
      return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
   }
   b2Contact.prototype.SetEnabled = function (flag) {
      if (flag) {
         this.m_flags |= b2Contact.e_enabledFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_enabledFlag;
      }
   }
   b2Contact.prototype.IsEnabled = function () {
      return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
   }
   b2Contact.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Contact.prototype.GetFixtureA = function () {
      return this.m_fixtureA;
   }
   b2Contact.prototype.GetFixtureB = function () {
      return this.m_fixtureB;
   }
   b2Contact.prototype.FlagForFiltering = function () {
      this.m_flags |= b2Contact.e_filterFlag;
   }
   b2Contact.prototype.b2Contact = function () {}
   b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
      if (fixtureA === undefined) fixtureA = null;
      if (fixtureB === undefined) fixtureB = null;
      this.m_flags = b2Contact.e_enabledFlag;
      if (!fixtureA || !fixtureB) {
         this.m_fixtureA = null;
         this.m_fixtureB = null;
         return;
      }
      if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
         this.m_flags |= b2Contact.e_continuousFlag;
      }
      this.m_fixtureA = fixtureA;
      this.m_fixtureB = fixtureB;
      this.m_manifold.m_pointCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_nodeA.contact = null;
      this.m_nodeA.prev = null;
      this.m_nodeA.next = null;
      this.m_nodeA.other = null;
      this.m_nodeB.contact = null;
      this.m_nodeB.prev = null;
      this.m_nodeB.next = null;
      this.m_nodeB.other = null;
   }
   b2Contact.prototype.Update = function (listener) {
      var tManifold = this.m_oldManifold;
      this.m_oldManifold = this.m_manifold;
      this.m_manifold = tManifold;
      this.m_flags |= b2Contact.e_enabledFlag;
      var touching = false;
      var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
      var bodyA = this.m_fixtureA.m_body;
      var bodyB = this.m_fixtureB.m_body;
      var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
      if (this.m_flags & b2Contact.e_sensorFlag) {
         if (aabbOverlap) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            var xfA = bodyA.GetTransform();
            var xfB = bodyB.GetTransform();
            touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
         }
         this.m_manifold.m_pointCount = 0;
      }
      else {
         if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
         }
         else {
            this.m_flags &= ~b2Contact.e_continuousFlag;
         }
         if (aabbOverlap) {
            this.Evaluate();
            touching = this.m_manifold.m_pointCount > 0;
            for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
               var mp2 = this.m_manifold.m_points[i];
               mp2.m_normalImpulse = 0.0;
               mp2.m_tangentImpulse = 0.0;
               var id2 = mp2.m_id;
               for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                  var mp1 = this.m_oldManifold.m_points[j];
                  if (mp1.m_id.key == id2.key) {
                     mp2.m_normalImpulse = mp1.m_normalImpulse;
                     mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                     break;
                  }
               }
            }
         }
         else {
            this.m_manifold.m_pointCount = 0;
         }
         if (touching != wasTouching) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
         }
      }
      if (touching) {
         this.m_flags |= b2Contact.e_touchingFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_touchingFlag;
      }
      if (wasTouching == false && touching == true) {
         listener.BeginContact(this);
      }
      if (wasTouching == true && touching == false) {
         listener.EndContact(this);
      }
      if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
         listener.PreSolve(this, this.m_oldManifold);
      }
   }
   b2Contact.prototype.Evaluate = function () {}
   b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
      b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
      b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
      b2Contact.s_input.sweepA = sweepA;
      b2Contact.s_input.sweepB = sweepB;
      b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
      return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
      Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
      Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
      Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
      Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
      Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
      Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
      Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
   });
   b2ContactConstraint.b2ContactConstraint = function () {
      this.localPlaneNormal = new b2Vec2();
      this.localPoint = new b2Vec2();
      this.normal = new b2Vec2();
      this.normalMass = new b2Mat22();
      this.K = new b2Mat22();
   };
   b2ContactConstraint.prototype.b2ContactConstraint = function () {
      this.points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.points[i] = new b2ContactConstraintPoint();
      }
   }
   b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
      this.localPoint = new b2Vec2();
      this.rA = new b2Vec2();
      this.rB = new b2Vec2();
   };
   b2ContactEdge.b2ContactEdge = function () {};
   b2ContactFactory.b2ContactFactory = function () {};
   b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
      this.m_allocator = allocator;
      this.InitializeRegisters();
   }
   b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
      if (type1 === undefined) type1 = 0;
      if (type2 === undefined) type2 = 0;
      this.m_registers[type1][type2].createFcn = createFcn;
      this.m_registers[type1][type2].destroyFcn = destroyFcn;
      this.m_registers[type1][type2].primary = true;
      if (type1 != type2) {
         this.m_registers[type2][type1].createFcn = createFcn;
         this.m_registers[type2][type1].destroyFcn = destroyFcn;
         this.m_registers[type2][type1].primary = false;
      }
   }
   b2ContactFactory.prototype.InitializeRegisters = function () {
      this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
      for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
         this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
         for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
            this.m_registers[i][j] = new b2ContactRegister();
         }
      }
      this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
      this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
      this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
   }
   b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
      var type1 = parseInt(fixtureA.GetType());
      var type2 = parseInt(fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      var c;
      if (reg.pool) {
         c = reg.pool;
         reg.pool = c.m_next;
         reg.poolCount--;
         c.Reset(fixtureA, fixtureB);
         return c;
      }
      var createFcn = reg.createFcn;
      if (createFcn != null) {
         if (reg.primary) {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureA, fixtureB);
            return c;
         }
         else {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureB, fixtureA);
            return c;
         }
      }
      else {
         return null;
      }
   }
   b2ContactFactory.prototype.Destroy = function (contact) {
      if (contact.m_manifold.m_pointCount > 0) {
         contact.m_fixtureA.m_body.SetAwake(true);
         contact.m_fixtureB.m_body.SetAwake(true);
      }
      var type1 = parseInt(contact.m_fixtureA.GetType());
      var type2 = parseInt(contact.m_fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      if (true) {
         reg.poolCount++;
         contact.m_next = reg.pool;
         reg.pool = contact;
      }
      var destroyFcn = reg.destroyFcn;
      destroyFcn(contact, this.m_allocator);
   }
   b2ContactRegister.b2ContactRegister = function () {};
   b2ContactResult.b2ContactResult = function () {
      this.position = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2ContactSolver.b2ContactSolver = function () {
      this.m_step = new b2TimeStep();
      this.m_constraints = new Vector();
   };
   b2ContactSolver.prototype.b2ContactSolver = function () {}
   b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
      if (contactCount === undefined) contactCount = 0;
      var contact;
      this.m_step.Set(step);
      this.m_allocator = allocator;
      var i = 0;
      var tVec;
      var tMat;
      this.m_constraintCount = contactCount;
      while (this.m_constraints.length < this.m_constraintCount) {
         this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
      }
      for (i = 0;
      i < contactCount; ++i) {
         contact = contacts[i];
         var fixtureA = contact.m_fixtureA;
         var fixtureB = contact.m_fixtureB;
         var shapeA = fixtureA.m_shape;
         var shapeB = fixtureB.m_shape;
         var radiusA = shapeA.m_radius;
         var radiusB = shapeB.m_radius;
         var bodyA = fixtureA.m_body;
         var bodyB = fixtureB.m_body;
         var manifold = contact.GetManifold();
         var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
         var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
         var vAX = bodyA.m_linearVelocity.x;
         var vAY = bodyA.m_linearVelocity.y;
         var vBX = bodyB.m_linearVelocity.x;
         var vBY = bodyB.m_linearVelocity.y;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         b2Settings.b2Assert(manifold.m_pointCount > 0);
         b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
         var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
         var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
         var cc = this.m_constraints[i];
         cc.bodyA = bodyA;
         cc.bodyB = bodyB;
         cc.manifold = manifold;
         cc.normal.x = normalX;
         cc.normal.y = normalY;
         cc.pointCount = manifold.m_pointCount;
         cc.friction = friction;
         cc.restitution = restitution;
         cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
         cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
         cc.localPoint.x = manifold.m_localPoint.x;
         cc.localPoint.y = manifold.m_localPoint.y;
         cc.radius = radiusA + radiusB;
         cc.type = manifold.m_type;
         for (var k = 0; k < cc.pointCount; ++k) {
            var cp = manifold.m_points[k];
            var ccp = cc.points[k];
            ccp.normalImpulse = cp.m_normalImpulse;
            ccp.tangentImpulse = cp.m_tangentImpulse;
            ccp.localPoint.SetV(cp.m_localPoint);
            var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
            var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
            var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
            var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
            var rnA = rAX * normalY - rAY * normalX;
            var rnB = rBX * normalY - rBY * normalX;
            rnA *= rnA;
            rnB *= rnB;
            var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
            ccp.normalMass = 1.0 / kNormal;
            var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
            kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
            ccp.equalizedMass = 1.0 / kEqualized;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var rtA = rAX * tangentY - rAY * tangentX;
            var rtB = rBX * tangentY - rBY * tangentX;
            rtA *= rtA;
            rtB *= rtB;
            var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
            ccp.tangentMass = 1.0 / kTangent;
            ccp.velocityBias = 0.0;
            var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
            var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
            var vRel = cc.normal.x * tX + cc.normal.y * tY;
            if (vRel < (-b2Settings.b2_velocityThreshold)) {
               ccp.velocityBias += (-cc.restitution * vRel);
            }
         }
         if (cc.pointCount == 2) {
            var ccp1 = cc.points[0];
            var ccp2 = cc.points[1];
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
            var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
            var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
            var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
            var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
            var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
            var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
            var k_maxConditionNumber = 100.0;
            if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
               cc.K.col1.Set(k11, k12);
               cc.K.col2.Set(k12, k22);
               cc.K.GetInverse(cc.normalMass);
            }
            else {
               cc.pointCount = 1;
            }
         }
      }
   }
   b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
      var tVec;
      var tVec2;
      var tMat;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var tX = 0;
         var j = 0;
         var tCount = 0;
         if (step.warmStarting) {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp = c.points[j];
               ccp.normalImpulse *= step.dtRatio;
               ccp.tangentImpulse *= step.dtRatio;
               var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
               var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
               bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
               bodyA.m_linearVelocity.x -= invMassA * PX;
               bodyA.m_linearVelocity.y -= invMassA * PY;
               bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
               bodyB.m_linearVelocity.x += invMassB * PX;
               bodyB.m_linearVelocity.y += invMassB * PY;
            }
         }
         else {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp2 = c.points[j];
               ccp2.normalImpulse = 0.0;
               ccp2.tangentImpulse = 0.0;
            }
         }
      }
   }
   b2ContactSolver.prototype.SolveVelocityConstraints = function () {
      var j = 0;
      var ccp;
      var rAX = 0;
      var rAY = 0;
      var rBX = 0;
      var rBY = 0;
      var dvX = 0;
      var dvY = 0;
      var vn = 0;
      var vt = 0;
      var lambda = 0;
      var maxFriction = 0;
      var newImpulse = 0;
      var PX = 0;
      var PY = 0;
      var dX = 0;
      var dY = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var tMat;
      var tVec;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         var vA = bodyA.m_linearVelocity;
         var vB = bodyB.m_linearVelocity;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var friction = c.friction;
         var tX = 0;
         for (j = 0;
         j < c.pointCount; j++) {
            ccp = c.points[j];
            dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
            dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
            vt = dvX * tangentX + dvY * tangentY;
            lambda = ccp.tangentMass * (-vt);
            maxFriction = friction * ccp.normalImpulse;
            newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
            lambda = newImpulse - ccp.tangentImpulse;
            PX = lambda * tangentX;
            PY = lambda * tangentY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.tangentImpulse = newImpulse;
         }
         var tCount = parseInt(c.pointCount);
         if (c.pointCount == 1) {
            ccp = c.points[0];
            dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
            dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
            vn = dvX * normalX + dvY * normalY;
            lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
            newImpulse = ccp.normalImpulse + lambda;
            newImpulse = newImpulse > 0 ? newImpulse : 0.0;
            lambda = newImpulse - ccp.normalImpulse;
            PX = lambda * normalX;
            PY = lambda * normalY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.normalImpulse = newImpulse;
         }
         else {
            var cp1 = c.points[0];
            var cp2 = c.points[1];
            var aX = cp1.normalImpulse;
            var aY = cp2.normalImpulse;
            var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
            var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
            var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
            var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
            var vn1 = dv1X * normalX + dv1Y * normalY;
            var vn2 = dv2X * normalX + dv2Y * normalY;
            var bX = vn1 - cp1.velocityBias;
            var bY = vn2 - cp2.velocityBias;
            tMat = c.K;
            bX -= tMat.col1.x * aX + tMat.col2.x * aY;
            bY -= tMat.col1.y * aX + tMat.col2.y * aY;
            var k_errorTol = 0.001;
            for (;;) {
               tMat = c.normalMass;
               var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
               var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
               if (xX >= 0.0 && xY >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = (-cp1.normalMass * bX);
               xY = 0.0;
               vn1 = 0.0;
               vn2 = c.K.col1.y * xX + bY;
               if (xX >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = (-cp2.normalMass * bY);
               vn1 = c.K.col2.x * xY + bX;
               vn2 = 0.0;
               if (xY >= 0.0 && vn1 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = 0.0;
               vn1 = bX;
               vn2 = bY;
               if (vn1 >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               break;
            }
         }
         bodyA.m_angularVelocity = wA;
         bodyB.m_angularVelocity = wB;
      }
   }
   b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var m = c.manifold;
         for (var j = 0; j < c.pointCount; ++j) {
            var point1 = m.m_points[j];
            var point2 = c.points[j];
            point1.m_normalImpulse = point2.normalImpulse;
            point1.m_tangentImpulse = point2.tangentImpulse;
         }
      }
   }
   b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var minSeparation = 0.0;
      for (var i = 0; i < this.m_constraintCount; i++) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_mass * bodyA.m_invMass;
         var invIA = bodyA.m_mass * bodyA.m_invI;
         var invMassB = bodyB.m_mass * bodyB.m_invMass;
         var invIB = bodyB.m_mass * bodyB.m_invI;
         b2ContactSolver.s_psm.Initialize(c);
         var normal = b2ContactSolver.s_psm.m_normal;
         for (var j = 0; j < c.pointCount; j++) {
            var ccp = c.points[j];
            var point = b2ContactSolver.s_psm.m_points[j];
            var separation = b2ContactSolver.s_psm.m_separations[j];
            var rAX = point.x - bodyA.m_sweep.c.x;
            var rAY = point.y - bodyA.m_sweep.c.y;
            var rBX = point.x - bodyB.m_sweep.c.x;
            var rBY = point.y - bodyB.m_sweep.c.y;
            minSeparation = minSeparation < separation ? minSeparation : separation;
            var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
            var impulse = (-ccp.equalizedMass * C);
            var PX = impulse * normal.x;
            var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
            bodyA.m_sweep.c.y -= invMassA * PY;
            bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
            bodyA.SynchronizeTransform();
            bodyB.m_sweep.c.x += invMassB * PX;
            bodyB.m_sweep.c.y += invMassB * PY;
            bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
            bodyB.SynchronizeTransform();
         }
      }
      return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
      Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
   });
   Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2EdgeAndCircleContact.Create = function (allocator) {
      return new b2EdgeAndCircleContact();
   }
   b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
   b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2EdgeAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {}
   Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
   b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2NullContact.b2NullContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2NullContact.prototype.b2NullContact = function () {
      this.__super.b2Contact.call(this);
   }
   b2NullContact.prototype.Evaluate = function () {}
   Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndCircleContact.Create = function (allocator) {
      return new b2PolyAndCircleContact();
   }
   b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
   b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
   }
   b2PolyAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.m_body;
      var bB = this.m_fixtureB.m_body;
      b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndEdgeContact.Create = function (allocator) {
      return new b2PolyAndEdgeContact();
   }
   b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
   b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
   }
   b2PolyAndEdgeContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
   Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolygonContact.b2PolygonContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolygonContact.Create = function (allocator) {
      return new b2PolygonContact();
   }
   b2PolygonContact.Destroy = function (contact, allocator) {}
   b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2PolygonContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PositionSolverManifold.b2PositionSolverManifold = function () {};
   b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
      this.m_normal = new b2Vec2();
      this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2PositionSolverManifold.prototype.Initialize = function (cc) {
      b2Settings.b2Assert(cc.pointCount > 0);
      var i = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      var tMat;
      var tVec;
      var planePointX = 0;
      var planePointY = 0;
      switch (cc.type) {
      case b2Manifold.e_circles:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.points[0].localPoint;
            var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1.0;
               this.m_normal.y = 0.0;
            }
            this.m_points[0].x = 0.5 * (pointAX + pointBX);
            this.m_points[0].y = 0.5 * (pointAY + pointBY);
            this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].x = clipPointX;
               this.m_points[i].y = clipPointY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyA.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].Set(clipPointX, clipPointY);
            }
            this.m_normal.x *= (-1);
            this.m_normal.y *= (-1);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
   });
})();
(function () {
   var b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
      b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
      b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
      b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

   Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
   b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2BuoyancyController.b2BuoyancyController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.normal = new b2Vec2(0, (-1));
      this.offset = 0;
      this.density = 0;
      this.velocity = new b2Vec2(0, 0);
      this.linearDrag = 2;
      this.angularDrag = 1;
      this.useDensity = false;
      this.useWorldGravity = true;
      this.gravity = null;
   };
   b2BuoyancyController.prototype.Step = function (step) {
      if (!this.m_bodyList) return;
      if (this.useWorldGravity) {
         this.gravity = this.GetWorld().GetGravity().Copy();
      }
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (body.IsAwake() == false) {
            continue;
         }
         var areac = new b2Vec2();
         var massc = new b2Vec2();
         var area = 0.0;
         var mass = 0.0;
         for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
            var sc = new b2Vec2();
            var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
            area += sarea;
            areac.x += sarea * sc.x;
            areac.y += sarea * sc.y;
            var shapeDensity = 0;
            if (this.useDensity) {
               shapeDensity = 1;
            }
            else {
               shapeDensity = 1;
            }
            mass += sarea * shapeDensity;
            massc.x += sarea * sc.x * shapeDensity;
            massc.y += sarea * sc.y * shapeDensity;
         }
         areac.x /= area;
         areac.y /= area;
         massc.x /= mass;
         massc.y /= mass;
         if (area < Number.MIN_VALUE) continue;
         var buoyancyForce = this.gravity.GetNegative();
         buoyancyForce.Multiply(this.density * area);
         body.ApplyForce(buoyancyForce, massc);
         var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
         dragForce.Subtract(this.velocity);
         dragForce.Multiply((-this.linearDrag * area));
         body.ApplyForce(dragForce, areac);
         body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
      }
   }
   b2BuoyancyController.prototype.Draw = function (debugDraw) {
      var r = 1000;
      var p1 = new b2Vec2();
      var p2 = new b2Vec2();
      p1.x = this.normal.x * this.offset + this.normal.y * r;
      p1.y = this.normal.y * this.offset - this.normal.x * r;
      p2.x = this.normal.x * this.offset - this.normal.y * r;
      p2.y = this.normal.y * this.offset + this.normal.x * r;
      var color = new b2Color(0, 0, 1);
      debugDraw.DrawSegment(p1, p2, color);
   }
   Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantAccelController.b2ConstantAccelController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.A = new b2Vec2(0, 0);
   };
   b2ConstantAccelController.prototype.Step = function (step) {
      var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
      }
   }
   Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantForceController.b2ConstantForceController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.F = new b2Vec2(0, 0);
   };
   b2ConstantForceController.prototype.Step = function (step) {
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.ApplyForce(this.F, body.GetWorldCenter());
      }
   }
   b2Controller.b2Controller = function () {};
   b2Controller.prototype.Step = function (step) {}
   b2Controller.prototype.Draw = function (debugDraw) {}
   b2Controller.prototype.AddBody = function (body) {
      var edge = new b2ControllerEdge();
      edge.controller = this;
      edge.body = body;
      edge.nextBody = this.m_bodyList;
      edge.prevBody = null;
      this.m_bodyList = edge;
      if (edge.nextBody) edge.nextBody.prevBody = edge;
      this.m_bodyCount++;
      edge.nextController = body.m_controllerList;
      edge.prevController = null;
      body.m_controllerList = edge;
      if (edge.nextController) edge.nextController.prevController = edge;
      body.m_controllerCount++;
   }
   b2Controller.prototype.RemoveBody = function (body) {
      var edge = body.m_controllerList;
      while (edge && edge.controller != this)
      edge = edge.nextController;
      if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
      if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
      if (edge.nextController) edge.nextController.prevController = edge.prevController;
      if (edge.prevController) edge.prevController.nextController = edge.nextController;
      if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
      if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
      body.m_controllerCount--;
      this.m_bodyCount--;
   }
   b2Controller.prototype.Clear = function () {
      while (this.m_bodyList)
      this.RemoveBody(this.m_bodyList.body);
   }
   b2Controller.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Controller.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Controller.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2ControllerEdge.b2ControllerEdge = function () {};
   Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
   b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2GravityController.b2GravityController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.G = 1;
      this.invSqr = true;
   };
   b2GravityController.prototype.Step = function (step) {
      var i = null;
      var body1 = null;
      var p1 = null;
      var mass1 = 0;
      var j = null;
      var body2 = null;
      var p2 = null;
      var dx = 0;
      var dy = 0;
      var r2 = 0;
      var f = null;
      if (this.invSqr) {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
      else {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
   }
   Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
   b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2TensorDampingController.b2TensorDampingController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.T = new b2Mat22();
      this.maxTimestep = 0;
   };
   b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
      if (xDamping === undefined) xDamping = 0;
      if (yDamping === undefined) yDamping = 0;
      this.T.col1.x = (-xDamping);
      this.T.col1.y = 0;
      this.T.col2.x = 0;
      this.T.col2.y = (-yDamping);
      if (xDamping > 0 || yDamping > 0) {
         this.maxTimestep = 1 / Math.max(xDamping, yDamping);
      }
      else {
         this.maxTimestep = 0;
      }
   }
   b2TensorDampingController.prototype.Step = function (step) {
      var timestep = step.dt;
      if (timestep <= Number.MIN_VALUE) return;
      if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) {
            continue;
         }
         var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
      }
   }
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World;

   Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
   b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2DistanceJoint.b2DistanceJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u = new b2Vec2();
   };
   b2DistanceJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2DistanceJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
   }
   b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2DistanceJoint.prototype.GetLength = function () {
      return this.m_length;
   }
   b2DistanceJoint.prototype.SetLength = function (length) {
      if (length === undefined) length = 0;
      this.m_length = length;
   }
   b2DistanceJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2DistanceJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2DistanceJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_length = def.length;
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_impulse = 0.0;
      this.m_gamma = 0.0;
      this.m_bias = 0.0;
   }
   b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
      if (length > b2Settings.b2_linearSlop) {
         this.m_u.Multiply(1.0 / length);
      }
      else {
         this.m_u.SetZero();
      }
      var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
      var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
      var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
      if (this.m_frequencyHz > 0.0) {
         var C = length - this.m_length;
         var omega = 2.0 * Math.PI * this.m_frequencyHz;
         var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
         var k = this.m_mass * omega * omega;
         this.m_gamma = step.dt * (d + step.dt * k);
         this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
         this.m_bias = C * step.dt * k * this.m_gamma;
         this.m_mass = invMass + this.m_gamma;
         this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         var PX = this.m_impulse * this.m_u.x;
         var PY = this.m_impulse * this.m_u.y;
         bA.m_linearVelocity.x -= bA.m_invMass * PX;
         bA.m_linearVelocity.y -= bA.m_invMass * PY;
         bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
         bB.m_linearVelocity.x += bB.m_invMass * PX;
         bB.m_linearVelocity.y += bB.m_invMass * PY;
         bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
      var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
      var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
      var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
      var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
      var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
      this.m_impulse += impulse;
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_linearVelocity.x -= bA.m_invMass * PX;
      bA.m_linearVelocity.y -= bA.m_invMass * PY;
      bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_linearVelocity.x += bB.m_invMass * PX;
      bB.m_linearVelocity.y += bB.m_invMass * PY;
      bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
   }
   b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      if (this.m_frequencyHz > 0.0) {
         return true;
      }
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(dX * dX + dY * dY);
      dX /= length;
      dY /= length;
      var C = length - this.m_length;
      C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
      var impulse = (-this.m_mass * C);
      this.m_u.Set(dX, dY);
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_sweep.c.x -= bA.m_invMass * PX;
      bA.m_sweep.c.y -= bA.m_invMass * PY;
      bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_sweep.c.x += bB.m_invMass * PX;
      bB.m_sweep.c.y += bB.m_invMass * PY;
      bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return b2Math.Abs(C) < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2DistanceJointDef.b2DistanceJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_distanceJoint;
      this.length = 1.0;
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
      var dX = anchorB.x - anchorA.x;
      var dY = anchorB.y - anchorA.y;
      this.length = Math.sqrt(dX * dX + dY * dY);
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
   b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2FrictionJoint.b2FrictionJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_linearMass = new b2Mat22();
      this.m_linearImpulse = new b2Vec2();
   };
   b2FrictionJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2FrictionJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
   }
   b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_angularImpulse;
   }
   b2FrictionJoint.prototype.SetMaxForce = function (force) {
      if (force === undefined) force = 0;
      this.m_maxForce = force;
   }
   b2FrictionJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxTorque = torque;
   }
   b2FrictionJoint.prototype.GetMaxTorque = function () {
      return this.m_maxTorque;
   }
   b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_linearMass.SetZero();
      this.m_angularMass = 0.0;
      this.m_linearImpulse.SetZero();
      this.m_angularImpulse = 0.0;
      this.m_maxForce = def.maxForce;
      this.m_maxTorque = def.maxTorque;
   }
   b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var K = new b2Mat22();
      K.col1.x = mA + mB;
      K.col2.x = 0.0;
      K.col1.y = 0.0;
      K.col2.y = mA + mB;
      K.col1.x += iA * rAY * rAY;
      K.col2.x += (-iA * rAX * rAY);
      K.col1.y += (-iA * rAX * rAY);
      K.col2.y += iA * rAX * rAX;
      K.col1.x += iB * rBY * rBY;
      K.col2.x += (-iB * rBX * rBY);
      K.col1.y += (-iB * rBX * rBY);
      K.col2.y += iB * rBX * rBX;
      K.GetInverse(this.m_linearMass);
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0.0) {
         this.m_angularMass = 1.0 / this.m_angularMass;
      }
      if (step.warmStarting) {
         this.m_linearImpulse.x *= step.dtRatio;
         this.m_linearImpulse.y *= step.dtRatio;
         this.m_angularImpulse *= step.dtRatio;
         var P = this.m_linearImpulse;
         bA.m_linearVelocity.x -= mA * P.x;
         bA.m_linearVelocity.y -= mA * P.y;
         bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
         bB.m_linearVelocity.x += mB * P.x;
         bB.m_linearVelocity.y += mB * P.y;
         bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
      }
      else {
         this.m_linearImpulse.SetZero();
         this.m_angularImpulse = 0.0;
      }
   }
   b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var maxImpulse = 0; {
         var Cdot = wB - wA;
         var impulse = (-this.m_angularMass * Cdot);
         var oldImpulse = this.m_angularImpulse;
         maxImpulse = step.dt * this.m_maxTorque;
         this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_angularImpulse - oldImpulse;
         wA -= iA * impulse;
         wB += iB * impulse;
      } {
         var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
         var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
         var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
         var oldImpulseV = this.m_linearImpulse.Copy();
         this.m_linearImpulse.Add(impulseV);
         maxImpulse = step.dt * this.m_maxForce;
         if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
         }
         impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
         vA.x -= mA * impulseV.x;
         vA.y -= mA * impulseV.y;
         wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
         vB.x += mB * impulseV.x;
         vB.y += mB * impulseV.y;
         wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
      }
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2FrictionJointDef.b2FrictionJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_frictionJoint;
      this.maxForce = 0.0;
      this.maxTorque = 0.0;
   }
   b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
   }
   Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
   b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2GearJoint.b2GearJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_J = new b2Jacobian();
   };
   b2GearJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2GearJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
   }
   b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      var tMat = this.m_bodyB.m_xf.R;
      var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
      var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
      var tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      var PX = this.m_impulse * this.m_J.linearB.x;
      var PY = this.m_impulse * this.m_J.linearB.y;
      return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
   }
   b2GearJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2GearJoint.prototype.SetRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_ratio = ratio;
   }
   b2GearJoint.prototype.b2GearJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var type1 = parseInt(def.joint1.m_type);
      var type2 = parseInt(def.joint2.m_type);
      this.m_revolute1 = null;
      this.m_prismatic1 = null;
      this.m_revolute2 = null;
      this.m_prismatic2 = null;
      var coordinate1 = 0;
      var coordinate2 = 0;
      this.m_ground1 = def.joint1.GetBodyA();
      this.m_bodyA = def.joint1.GetBodyB();
      if (type1 == b2Joint.e_revoluteJoint) {
         this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      this.m_ground2 = def.joint2.GetBodyA();
      this.m_bodyB = def.joint2.GetBodyB();
      if (type2 == b2Joint.e_revoluteJoint) {
         this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      this.m_ratio = def.ratio;
      this.m_constant = coordinate1 + this.m_ratio * coordinate2;
      this.m_impulse = 0.0;
   }
   b2GearJoint.prototype.InitVelocityConstraints = function (step) {
      var g1 = this.m_ground1;
      var g2 = this.m_ground2;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var ugX = 0;
      var ugY = 0;
      var rX = 0;
      var rY = 0;
      var tMat;
      var tVec;
      var crug = 0;
      var tX = 0;
      var K = 0.0;
      this.m_J.SetZero();
      if (this.m_revolute1) {
         this.m_J.angularA = (-1.0);
         K += bA.m_invI;
      }
      else {
         tMat = g1.m_xf.R;
         tVec = this.m_prismatic1.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bA.m_xf.R;
         rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearA.Set((-ugX), (-ugY));
         this.m_J.angularA = (-crug);
         K += bA.m_invMass + bA.m_invI * crug * crug;
      }
      if (this.m_revolute2) {
         this.m_J.angularB = (-this.m_ratio);
         K += this.m_ratio * this.m_ratio * bB.m_invI;
      }
      else {
         tMat = g2.m_xf.R;
         tVec = this.m_prismatic2.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bB.m_xf.R;
         rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
         this.m_J.angularB = (-this.m_ratio * crug);
         K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
      }
      this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
      if (step.warmStarting) {
         bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
         bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
         bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
         bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
         bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
         bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
      var impulse = (-this.m_mass * Cdot);
      this.m_impulse += impulse;
      bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
   }
   b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var linearError = 0.0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var coordinate1 = 0;
      var coordinate2 = 0;
      if (this.m_revolute1) {
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      if (this.m_revolute2) {
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
      var impulse = (-this.m_mass * C);
      bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2GearJointDef.b2GearJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
   };
   b2GearJointDef.prototype.b2GearJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_gearJoint;
      this.joint1 = null;
      this.joint2 = null;
      this.ratio = 1.0;
   }
   b2Jacobian.b2Jacobian = function () {
      this.linearA = new b2Vec2();
      this.linearB = new b2Vec2();
   };
   b2Jacobian.prototype.SetZero = function () {
      this.linearA.SetZero();
      this.angularA = 0.0;
      this.linearB.SetZero();
      this.angularB = 0.0;
   }
   b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      this.linearA.SetV(x1);
      this.angularA = a1;
      this.linearB.SetV(x2);
      this.angularB = a2;
   }
   b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
   }
   b2Joint.b2Joint = function () {
      this.m_edgeA = new b2JointEdge();
      this.m_edgeB = new b2JointEdge();
      this.m_localCenterA = new b2Vec2();
      this.m_localCenterB = new b2Vec2();
   };
   b2Joint.prototype.GetType = function () {
      return this.m_type;
   }
   b2Joint.prototype.GetAnchorA = function () {
      return null;
   }
   b2Joint.prototype.GetAnchorB = function () {
      return null;
   }
   b2Joint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return null;
   }
   b2Joint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2Joint.prototype.GetBodyA = function () {
      return this.m_bodyA;
   }
   b2Joint.prototype.GetBodyB = function () {
      return this.m_bodyB;
   }
   b2Joint.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Joint.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Joint.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Joint.prototype.IsActive = function () {
      return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
   }
   b2Joint.Create = function (def, allocator) {
      var joint = null;
      switch (def.type) {
      case b2Joint.e_distanceJoint:
         {
            joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
         }
         break;
      case b2Joint.e_mouseJoint:
         {
            joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
         }
         break;
      case b2Joint.e_prismaticJoint:
         {
            joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
         }
         break;
      case b2Joint.e_revoluteJoint:
         {
            joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
         }
         break;
      case b2Joint.e_pulleyJoint:
         {
            joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
         }
         break;
      case b2Joint.e_gearJoint:
         {
            joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
         }
         break;
      case b2Joint.e_lineJoint:
         {
            joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
         }
         break;
      case b2Joint.e_weldJoint:
         {
            joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
         }
         break;
      case b2Joint.e_frictionJoint:
         {
            joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
         }
         break;
      default:
         break;
      }
      return joint;
   }
   b2Joint.Destroy = function (joint, allocator) {}
   b2Joint.prototype.b2Joint = function (def) {
      b2Settings.b2Assert(def.bodyA != def.bodyB);
      this.m_type = def.type;
      this.m_prev = null;
      this.m_next = null;
      this.m_bodyA = def.bodyA;
      this.m_bodyB = def.bodyB;
      this.m_collideConnected = def.collideConnected;
      this.m_islandFlag = false;
      this.m_userData = def.userData;
   }
   b2Joint.prototype.InitVelocityConstraints = function (step) {}
   b2Joint.prototype.SolveVelocityConstraints = function (step) {}
   b2Joint.prototype.FinalizeVelocityConstraints = function () {}
   b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return false;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
      Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
      Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
      Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
      Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
      Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
      Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
      Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
      Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
      Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
      Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
      Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
      Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
      Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
   });
   b2JointDef.b2JointDef = function () {};
   b2JointDef.prototype.b2JointDef = function () {
      this.type = b2Joint.e_unknownJoint;
      this.userData = null;
      this.bodyA = null;
      this.bodyB = null;
      this.collideConnected = false;
   }
   b2JointEdge.b2JointEdge = function () {};
   Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
   b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2LineJoint.b2LineJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat22();
      this.m_impulse = new b2Vec2();
   };
   b2LineJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2LineJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
   }
   b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2LineJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2LineJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2LineJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2LineJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2LineJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2LineJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2LineJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2LineJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2LineJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2LineJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2LineJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2LineJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2LineJoint.prototype.GetMaxMotorForce = function () {
      return this.m_maxMotorForce;
   }
   b2LineJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2LineJoint.prototype.b2LineJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2LineJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.y = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
         }
         var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
         var f2r = 0;
         if (this.m_K.col1.x != 0.0) {
            f2r = b / this.m_K.col1.x + f1.x;
         }
         else {
            f2r = f1.x;
         }
         this.m_impulse.x = f2r;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y * this.m_a1;
         L2 = df.x * this.m_s2 + df.y * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = 0;
         if (this.m_K.col1.x != 0.0) {
            df2 = ((-Cdot1)) / this.m_K.col1.x;
         }
         else {
            df2 = 0.0;
         }
         this.m_impulse.x += df2;
         PX = df2 * this.m_perp.x;
         PY = df2 * this.m_perp.y;
         L1 = df2 * this.m_s1;
         L2 = df2 * this.m_s2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec2();
      var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1));
      angularError = 0.0;
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve(impulse, (-C1), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var impulse1 = 0;
         if (k11 != 0.0) {
            impulse1 = ((-C1)) / k11;
         }
         else {
            impulse1 = 0.0;
         }
         impulse.x = impulse1;
         impulse.y = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2LineJointDef.b2LineJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2LineJointDef.prototype.b2LineJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_lineJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
   }
   Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
   b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2MouseJoint.b2MouseJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.m_localAnchor = new b2Vec2();
      this.m_target = new b2Vec2();
      this.m_impulse = new b2Vec2();
      this.m_mass = new b2Mat22();
      this.m_C = new b2Vec2();
   };
   b2MouseJoint.prototype.GetAnchorA = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
   }
   b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2MouseJoint.prototype.GetTarget = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.SetTarget = function (target) {
      if (this.m_bodyB.IsAwake() == false) {
         this.m_bodyB.SetAwake(true);
      }
      this.m_target = target;
   }
   b2MouseJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
      if (maxForce === undefined) maxForce = 0;
      this.m_maxForce = maxForce;
   }
   b2MouseJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2MouseJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2MouseJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2MouseJoint.prototype.b2MouseJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_target.SetV(def.target);
      var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
      var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
      var tMat = this.m_bodyB.m_xf.R;
      this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
      this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
      this.m_maxForce = def.maxForce;
      this.m_impulse.SetZero();
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_beta = 0.0;
      this.m_gamma = 0.0;
   }
   b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var mass = b.GetMass();
      var omega = 2.0 * Math.PI * this.m_frequencyHz;
      var d = 2.0 * mass * this.m_dampingRatio * omega;
      var k = mass * omega * omega;
      this.m_gamma = step.dt * (d + step.dt * k);
      this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
      this.m_beta = step.dt * k * this.m_gamma;
      var tMat;tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var invMass = b.m_invMass;
      var invI = b.m_invI;this.K1.col1.x = invMass;
      this.K1.col2.x = 0.0;
      this.K1.col1.y = 0.0;
      this.K1.col2.y = invMass;
      this.K2.col1.x = invI * rY * rY;
      this.K2.col2.x = (-invI * rX * rY);
      this.K2.col1.y = (-invI * rX * rY);
      this.K2.col2.y = invI * rX * rX;
      this.K.SetM(this.K1);
      this.K.AddM(this.K2);
      this.K.col1.x += this.m_gamma;
      this.K.col2.y += this.m_gamma;
      this.K.GetInverse(this.m_mass);
      this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
      this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
      b.m_angularVelocity *= 0.98;
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      b.m_linearVelocity.x += invMass * this.m_impulse.x;
      b.m_linearVelocity.y += invMass * this.m_impulse.y;
      b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
   }
   b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var tMat;
      var tX = 0;
      var tY = 0;
      tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rX + tMat.col2.x * rY);
      rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
      var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
      tMat = this.m_mass;
      tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
      tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
      var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
      var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
      var oldImpulseX = this.m_impulse.x;
      var oldImpulseY = this.m_impulse.y;
      this.m_impulse.x += impulseX;
      this.m_impulse.y += impulseY;
      var maxImpulse = step.dt * this.m_maxForce;
      if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
         this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
      }
      impulseX = this.m_impulse.x - oldImpulseX;
      impulseY = this.m_impulse.y - oldImpulseY;
      b.m_linearVelocity.x += b.m_invMass * impulseX;
      b.m_linearVelocity.y += b.m_invMass * impulseY;
      b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
   }
   b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2MouseJointDef.b2MouseJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.target = new b2Vec2();
   };
   b2MouseJointDef.prototype.b2MouseJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_mouseJoint;
      this.maxForce = 0.0;
      this.frequencyHz = 5.0;
      this.dampingRatio = 0.7;
   }
   Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PrismaticJoint.b2PrismaticJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat33();
      this.m_impulse = new b2Vec3();
   };
   b2PrismaticJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PrismaticJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
   }
   b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2PrismaticJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2PrismaticJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2PrismaticJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2PrismaticJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2PrismaticJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2PrismaticJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2PrismaticJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2PrismaticJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2PrismaticJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2PrismaticJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_refAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      var Cdot1Y = w2 - w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
         }
         var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
         var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
         var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
         f2r.x += f1.x;
         f2r.y += f1.y;
         this.m_impulse.x = f2r.x;
         this.m_impulse.y = f2r.y;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         df.z = this.m_impulse.z - f1.z;
         PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
         L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
         this.m_impulse.x += df2.x;
         this.m_impulse.y += df2.y;
         PX = df2.x * this.m_perp.x;
         PY = df2.x * this.m_perp.y;
         L1 = df2.x * this.m_s1 + df2.y;
         L2 = df2.x * this.m_s2 + df2.y;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec3();
      var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
      var C1Y = a2 - a1 - this.m_refAngle;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
      angularError = b2Math.Abs(C1Y);
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var k12 = i1 * this.m_s1 + i2 * this.m_s2;
         var k22 = i1 + i2;
         this.m_K.col1.Set(k11, k12, 0.0);
         this.m_K.col2.Set(k12, k22, 0.0);
         var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
         impulse.x = impulse1.x;
         impulse.y = impulse1.y;
         impulse.z = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PrismaticJointDef.b2PrismaticJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_prismaticJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.referenceAngle = 0.0;
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PulleyJoint.b2PulleyJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u1 = new b2Vec2();
      this.m_u2 = new b2Vec2();
   };
   b2PulleyJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PulleyJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
   }
   b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2PulleyJoint.prototype.GetGroundAnchorA = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor1);
      return a;
   }
   b2PulleyJoint.prototype.GetGroundAnchorB = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor2);
      return a;
   }
   b2PulleyJoint.prototype.GetLength1 = function () {
      var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetLength2 = function () {
      var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_ground = this.m_bodyA.m_world.m_groundBody;
      this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
      this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_ratio = def.ratio;
      this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
      this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
      this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
      this.m_impulse = 0.0;
      this.m_limitImpulse1 = 0.0;
      this.m_limitImpulse2 = 0.0;
   }
   b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      var length1 = this.m_u1.Length();
      var length2 = this.m_u2.Length();
      if (length1 > b2Settings.b2_linearSlop) {
         this.m_u1.Multiply(1.0 / length1);
      }
      else {
         this.m_u1.SetZero();
      }
      if (length2 > b2Settings.b2_linearSlop) {
         this.m_u2.Multiply(1.0 / length2);
      }
      else {
         this.m_u2.SetZero();
      }
      var C = this.m_constant - length1 - this.m_ratio * length2;
      if (C > 0.0) {
         this.m_state = b2Joint.e_inactiveLimit;
         this.m_impulse = 0.0;
      }
      else {
         this.m_state = b2Joint.e_atUpperLimit;
      }
      if (length1 < this.m_maxLength1) {
         this.m_limitState1 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse1 = 0.0;
      }
      else {
         this.m_limitState1 = b2Joint.e_atUpperLimit;
      }
      if (length2 < this.m_maxLength2) {
         this.m_limitState2 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse2 = 0.0;
      }
      else {
         this.m_limitState2 = b2Joint.e_atUpperLimit;
      }
      var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
      var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
      this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
      this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
      this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
      this.m_limitMass1 = 1.0 / this.m_limitMass1;
      this.m_limitMass2 = 1.0 / this.m_limitMass2;
      this.m_pulleyMass = 1.0 / this.m_pulleyMass;
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         this.m_limitImpulse1 *= step.dtRatio;
         this.m_limitImpulse2 *= step.dtRatio;
         var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
         var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
         var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
         var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      else {
         this.m_impulse = 0.0;
         this.m_limitImpulse1 = 0.0;
         this.m_limitImpulse2 = 0.0;
      }
   }
   b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = 0;
      var v1Y = 0;
      var v2X = 0;
      var v2Y = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var Cdot = 0;
      var impulse = 0;
      var oldImpulse = 0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
         impulse = this.m_pulleyMass * ((-Cdot));
         oldImpulse = this.m_impulse;
         this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
         impulse = this.m_impulse - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         P2X = (-this.m_ratio * impulse * this.m_u2.x);
         P2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
         impulse = (-this.m_limitMass1 * Cdot);
         oldImpulse = this.m_limitImpulse1;
         this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
         impulse = this.m_limitImpulse1 - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
         impulse = (-this.m_limitMass2 * Cdot);
         oldImpulse = this.m_limitImpulse2;
         this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
         impulse = this.m_limitImpulse2 - oldImpulse;
         P2X = (-impulse * this.m_u2.x);
         P2Y = (-impulse * this.m_u2.y);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
   }
   b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var p1X = 0;
      var p1Y = 0;
      var p2X = 0;
      var p2Y = 0;
      var length1 = 0;
      var length2 = 0;
      var C = 0;
      var impulse = 0;
      var oldImpulse = 0;
      var oldLimitPositionImpulse = 0;
      var tX = 0;
      var linearError = 0.0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length1 = this.m_u1.Length();
         length2 = this.m_u2.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
         }
         else {
            this.m_u1.SetZero();
         }
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_constant - length1 - this.m_ratio * length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_pulleyMass * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         p2X = (-this.m_ratio * impulse * this.m_u2.x);
         p2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         length1 = this.m_u1.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.x *= 1.0 / length1;
            this.m_u1.y *= 1.0 / length1;
         }
         else {
            this.m_u1.SetZero();
         }
         C = this.m_maxLength1 - length1;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass1 * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bA.SynchronizeTransform();
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length2 = this.m_u2.Length();
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.x *= 1.0 / length2;
            this.m_u2.y *= 1.0 / length2;
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_maxLength2 - length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass2 * C);
         p2X = (-impulse * this.m_u2.x);
         p2Y = (-impulse * this.m_u2.y);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bB.SynchronizeTransform();
      }
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
   });
   Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PulleyJointDef.b2PulleyJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.groundAnchorA = new b2Vec2();
      this.groundAnchorB = new b2Vec2();
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_pulleyJoint;
      this.groundAnchorA.Set((-1.0), 1.0);
      this.groundAnchorB.Set(1.0, 1.0);
      this.localAnchorA.Set((-1.0), 0.0);
      this.localAnchorB.Set(1.0, 0.0);
      this.lengthA = 0.0;
      this.maxLengthA = 0.0;
      this.lengthB = 0.0;
      this.maxLengthB = 0.0;
      this.ratio = 1.0;
      this.collideConnected = true;
   }
   b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
      if (r === undefined) r = 0;
      this.bodyA = bA;
      this.bodyB = bB;
      this.groundAnchorA.SetV(gaA);
      this.groundAnchorB.SetV(gaB);
      this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
      var d1X = anchorA.x - gaA.x;
      var d1Y = anchorA.y - gaA.y;
      this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
      var d2X = anchorB.x - gaB.x;
      var d2Y = anchorB.y - gaB.y;
      this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
      this.ratio = r;
      var C = this.lengthA + this.ratio * this.lengthB;
      this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
      this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
   }
   Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
   b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2RevoluteJoint.b2RevoluteJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.K3 = new b2Mat22();
      this.impulse3 = new b2Vec3();
      this.impulse2 = new b2Vec2();
      this.reduced = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2RevoluteJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2RevoluteJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2RevoluteJoint.prototype.GetJointAngle = function () {
      return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
   }
   b2RevoluteJoint.prototype.GetJointSpeed = function () {
      return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
   }
   b2RevoluteJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2RevoluteJoint.prototype.EnableLimit = function (flag) {
      this.m_enableLimit = flag;
   }
   b2RevoluteJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerAngle;
   }
   b2RevoluteJoint.prototype.GetUpperLimit = function () {
      return this.m_upperAngle;
   }
   b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_lowerAngle = lower;
      this.m_upperAngle = upper;
   }
   b2RevoluteJoint.prototype.IsMotorEnabled = function () {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      return this.m_enableMotor;
   }
   b2RevoluteJoint.prototype.EnableMotor = function (flag) {
      this.m_enableMotor = flag;
   }
   b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2RevoluteJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxMotorTorque = torque;
   }
   b2RevoluteJoint.prototype.GetMotorTorque = function () {
      return this.m_maxMotorTorque;
   }
   b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
      this.m_lowerAngle = def.lowerAngle;
      this.m_upperAngle = def.upperAngle;
      this.m_maxMotorTorque = def.maxMotorTorque;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
   }
   b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      if (this.m_enableMotor || this.m_enableLimit) {}
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
      this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
      this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
      this.m_mass.col3.y = r1X * i1 + r2X * i2;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = i1 + i2;
      this.m_motorMass = 1.0 / (i1 + i2);
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (this.m_enableLimit) {
         var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointAngle <= this.m_lowerAngle) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atLowerLimit;
         }
         else if (jointAngle >= this.m_upperAngle) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atUpperLimit;
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x;
         var PY = this.m_impulse.y;
         bA.m_linearVelocity.x -= m1 * PX;
         bA.m_linearVelocity.y -= m1 * PY;
         bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
         bB.m_linearVelocity.x += m2 * PX;
         bB.m_linearVelocity.y += m2 * PY;
         bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      var newImpulse = 0;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = w2 - w1 - this.m_motorSpeed;
         var impulse = this.m_motorMass * ((-Cdot));
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorTorque;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         w1 -= i1 * impulse;
         w2 += i2 * impulse;
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         var Cdot2 = w2 - w1;
         this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
         if (this.m_limitState == b2Joint.e_equalLimits) {
            this.m_impulse.Add(this.impulse3);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse < 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse > 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         v1.x -= m1 * this.impulse3.x;
         v1.y -= m1 * this.impulse3.y;
         w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
         v2.x += m2 * this.impulse3.x;
         v2.y += m2 * this.impulse3.y;
         w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
      }
      else {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
         this.m_impulse.x += this.impulse2.x;
         this.m_impulse.y += this.impulse2.y;
         v1.x -= m1 * this.impulse2.x;
         v1.y -= m1 * this.impulse2.y;
         w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
         v2.x += m2 * this.impulse2.x;
         v2.y += m2 * this.impulse2.y;
         w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var oldLimitImpulse = 0;
      var C = 0;
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var angularError = 0.0;
      var positionError = 0.0;
      var tX = 0;
      var impulseX = 0;
      var impulseY = 0;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         var limitImpulse = 0.0;
         if (this.m_limitState == b2Joint.e_equalLimits) {
            C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
            angularError = b2Math.Abs(C);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            C = angle - this.m_lowerAngle;
            angularError = (-C);
            C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
            limitImpulse = (-this.m_motorMass * C);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            C = angle - this.m_upperAngle;
            angularError = C;
            C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
         }
         bA.m_sweep.a -= bA.m_invI * limitImpulse;
         bB.m_sweep.a += bB.m_invI * limitImpulse;
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      } {
         tMat = bA.m_xf.R;
         var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
         var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         var CLengthSquared = CX * CX + CY * CY;
         var CLength = Math.sqrt(CLengthSquared);
         positionError = CLength;
         var invMass1 = bA.m_invMass;
         var invMass2 = bB.m_invMass;
         var invI1 = bA.m_invI;
         var invI2 = bB.m_invI;
         var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
         if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
            var uX = CX / CLength;
            var uY = CY / CLength;
            var k = invMass1 + invMass2;
            var m = 1.0 / k;
            impulseX = m * ((-CX));
            impulseY = m * ((-CY));
            var k_beta = 0.5;
            bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
            bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
            bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
            bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
            CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         }
         this.K1.col1.x = invMass1 + invMass2;
         this.K1.col2.x = 0.0;
         this.K1.col1.y = 0.0;
         this.K1.col2.y = invMass1 + invMass2;
         this.K2.col1.x = invI1 * r1Y * r1Y;
         this.K2.col2.x = (-invI1 * r1X * r1Y);
         this.K2.col1.y = (-invI1 * r1X * r1Y);
         this.K2.col2.y = invI1 * r1X * r1X;
         this.K3.col1.x = invI2 * r2Y * r2Y;
         this.K3.col2.x = (-invI2 * r2X * r2Y);
         this.K3.col1.y = (-invI2 * r2X * r2Y);
         this.K3.col2.y = invI2 * r2X * r2X;
         this.K.SetM(this.K1);
         this.K.AddM(this.K2);
         this.K.AddM(this.K3);
         this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
         impulseX = b2RevoluteJoint.tImpulse.x;
         impulseY = b2RevoluteJoint.tImpulse.y;
         bA.m_sweep.c.x -= bA.m_invMass * impulseX;
         bA.m_sweep.c.y -= bA.m_invMass * impulseY;
         bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
         bB.m_sweep.c.x += bB.m_invMass * impulseX;
         bB.m_sweep.c.y += bB.m_invMass * impulseY;
         bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
   });
   Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2RevoluteJointDef.b2RevoluteJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_revoluteJoint;
      this.localAnchorA.Set(0.0, 0.0);
      this.localAnchorB.Set(0.0, 0.0);
      this.referenceAngle = 0.0;
      this.lowerAngle = 0.0;
      this.upperAngle = 0.0;
      this.maxMotorTorque = 0.0;
      this.motorSpeed = 0.0;
      this.enableLimit = false;
      this.enableMotor = false;
   }
   b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
   b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2WeldJoint.b2WeldJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2WeldJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2WeldJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2WeldJoint.prototype.b2WeldJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_mass = new b2Mat33();
   }
   b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_impulse.z *= step.dtRatio;
         bA.m_linearVelocity.x -= mA * this.m_impulse.x;
         bA.m_linearVelocity.y -= mA * this.m_impulse.y;
         bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
         bB.m_linearVelocity.x += mB * this.m_impulse.x;
         bB.m_linearVelocity.y += mB * this.m_impulse.y;
         bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
      }
   }
   b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
      var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
      var Cdot2 = wB - wA;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
      this.m_impulse.Add(impulse);
      vA.x -= mA * impulse.x;
      vA.y -= mA * impulse.y;
      wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      vB.x += mB * impulse.x;
      vB.y += mB * impulse.y;
      wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
      var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
      var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
      var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
      var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
      var angularError = b2Math.Abs(C2);
      if (positionError > k_allowedStretch) {
         iA *= 1.0;
         iB *= 1.0;
      }
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      bA.m_sweep.c.x -= mA * impulse.x;
      bA.m_sweep.c.y -= mA * impulse.y;
      bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      bB.m_sweep.c.x += mB * impulse.x;
      bB.m_sweep.c.y += mB * impulse.y;
      bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2WeldJointDef.b2WeldJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2WeldJointDef.prototype.b2WeldJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_weldJoint;
      this.referenceAngle = 0.0;
   }
   b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
})();
(function () {
   var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
   b2DebugDraw.b2DebugDraw = function () {
      this.m_drawScale = 1.0;
      this.m_lineThickness = 1.0;
      this.m_alpha = 1.0;
      this.m_fillAlpha = 1.0;
      this.m_xformScale = 1.0;
      var __this = this;
      //#WORKAROUND
      this.m_sprite = {
         graphics: {
            clear: function () {
               __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
            }
         }
      };
   };
   b2DebugDraw.prototype._color = function (color, alpha) {
      return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
   };
   b2DebugDraw.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
   };
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags = flags;
   };
   b2DebugDraw.prototype.GetFlags = function () {
      return this.m_drawFlags;
   };
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags |= flags;
   };
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags &= ~flags;
   };
   b2DebugDraw.prototype.SetSprite = function (sprite) {
      this.m_ctx = sprite;
   };
   b2DebugDraw.prototype.GetSprite = function () {
      return this.m_ctx;
   };
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
      this.m_drawScale = drawScale;
   };
   b2DebugDraw.prototype.GetDrawScale = function () {
      return this.m_drawScale;
   };
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
      this.m_lineThickness = lineThickness;
      this.m_ctx.strokeWidth = lineThickness;
   };
   b2DebugDraw.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
   };
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_alpha = alpha;
   };
   b2DebugDraw.prototype.GetAlpha = function () {
      return this.m_alpha;
   };
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_fillAlpha = alpha;
   };
   b2DebugDraw.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
   };
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
      this.m_xformScale = xformScale;
   };
   b2DebugDraw.prototype.GetXFormScale = function () {
      return this.m_xformScale;
   };
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (!radius) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (!radius) return;
      var s = this.m_ctx,
         drawScale = this.m_drawScale,
         cx = center.x * drawScale,
         cy = center.y * drawScale;
      s.moveTo(0, 0);
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
      s.moveTo(cx, cy);
      s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.beginPath();
      s.moveTo(p1.x * drawScale, p1.y * drawScale);
      s.lineTo(p2.x * drawScale, p2.y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawTransform = function (xf) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(0xff0000, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

      s.strokeStyle = this._color(0xff00, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
      s.closePath();
      s.stroke();
   };
})(); //post-definitions
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;
// export stuff
exports.Box2D=Box2D;
exports.b2AABB=Box2D.Collision.b2AABB;
exports.b2Vec2 = Box2D.Common.Math.b2Vec2;
exports.b2BodyDef = Box2D.Dynamics.b2BodyDef;
exports.b2Body = Box2D.Dynamics.b2Body;
exports.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
exports.b2Fixture = Box2D.Dynamics.b2Fixture;
exports.b2World = Box2D.Dynamics.b2World;
exports.b2MassData = Box2D.Collision.Shapes.b2MassData;
exports.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
exports.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
exports.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
exports.b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;
exports.b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef;
exports.b2Transform=Box2D.Common.Math.b2Transform;
exports.b2WorldManifold=Box2D.Collision.b2WorldManifold;
}}, []);/* This file has been generated by yabbler.js */
require.define({
"engine/audia": function(require, exports, module) {
// TODO: [BUG] music looping is a little bit off. I blame BUFFER and w/e the fuck is going on with that
// TODO: pan/panning (-1 -> 1)
// TODO: fade methods?
// TODO: implement proper looping
// TODO: repeating via start/end points
// TODO: if muteAll has been set, any newly created objects should also be muted

var Audia = exports.Audia = (function () {
	var supported = true;

	if (typeof AudioContext == "function") {
		var audioContext = new AudioContext();
	} else if (typeof webkitAudioContext == "function") {
		var audioContext = new webkitAudioContext();
	} else {
		supported = false;
	}
	exports.supported = supported;

	// Helper
	var clamp = function (value, min, max) {
		if (value < min) {
			return min;
		} else if (value > max) {
			return max;
		}
		return value;
	};

	var buffers = {};
	var cache = {};
	var cacheId = 0;

	var Audia = function () {
		this._id = ++cacheId;
		this._currentTime = 0;
		this._duration = 0;
		this._gain = null;
		this._onendedTimeout = null;
		this._muted = false;
		this._playing = false;
		this._source = null;
		this._startTime = null;
		this._volume = 1;

		var arg = arguments[0];
		if (typeof arg == "string") {
			this.src = arg;
		} else if (typeof arg == "object") {
			for (var key in arg) {
				this[key] = arg[key];
			}
		}

		cache[this._id] = this;
	};

	Audia.__defineGetter__("version", function () {
		return 0.1;
	});

	Audia.__defineGetter__("supported", function () {
		return supported;
	});

	if (!supported) {
		return Audia;
	}

	Audia.muteAll = function () {
		for (var id in cache) {
			cache[id].mute();
		}
	};

	Audia.unmuteAll = function () {
		for (var id in cache) {
			cache[id].unmute();
		}
	};

	Audia.prototype.__defineGetter__("currentTime", function () {
		if (this._playing) {
			var time = (audioContext.currentTime - this._startTime) + this._currentTime;
			if (time > this._duration) {
				return this._duration;
			} else {
				return time;
			}
		} else {
			return this._currentTime;
		}
	});

	Audia.prototype.__defineSetter__("currentTime", function (currentTime) {
		var currentTime = clamp(currentTime, 0, this._duration);

		if (this.currentTime != currentTime) {
			var playing = this._playing;
			this._stop();
			this._currentTime = currentTime;
			if (playing) {
				this.play();
			}
		}
	});

	Audia.prototype.__defineGetter__("duration", function () {
		return this._duration;
	});

	Audia.prototype.__defineGetter__("muted", function () {
		return this._muted;
	});
	Audia.prototype.__defineSetter__("muted", function (muted) {
		if (muted) {
			this.mute();
		} else {
			this.unmute();
		}
	});

	Audia.prototype.__defineGetter__("playing", function () {
		return this._playing;
	});

	Audia.prototype.__defineGetter__("src", function () {
		return this._src;
	});

	Audia.prototype.__defineSetter__("src", function (url) {
		this._src = url;
		var sound = this;

		// Create the gain node and set the volume
		var gain = audioContext.createGainNode();
		gain.gain.value = this._muted ? 0 : this._volume;

		// Note: panning code is commented out for now, because
		// the mere presence of a panner is causing everything
		// to sound muddy.
		// http://code.google.com/p/chromium/issues/detail?id=108852
		// Create the panner node and set the panning
		//var panner = audioContext.createPanner();

		// Create the buffer source and connect everything
		var source = audioContext.createBufferSource();
		/*
		source.connect(panner);
		panner.connect(gain);
		gain.connect(audioContext.destination);
		*/
		source.connect(gain);
		gain.connect(audioContext.destination);

		// Retain!
		this._gain = gain;
		//this._panner = panner;
		this._source = source;

		if (url in buffers) {
			source.buffer = buffers[url];

			return;
		}

		var xhr = new XMLHttpRequest();
		xhr.open("GET", url, true);
		xhr.responseType = "arraybuffer";
		xhr.onload = function() {
			var buffer = audioContext.createBuffer(xhr.response, false);
			source.buffer = buffer;
			buffers[url] = buffer;
			sound._duration = buffer.duration;
			sound.onload();
		};
		xhr.send();
	});

	Audia.prototype.__defineGetter__("volume", function () {
		return this._volume;
	});

	Audia.prototype.__defineSetter__("volume", function (volume) {
		// Note: max volume of 10 is arbitrary
		var volume = clamp(volume, 0, 10);
		this._volume = volume;

		if (!this._muted) {
			this._gain.gain.value = volume;
		}
	});

	Audia.prototype.onended = function () {};
	Audia.prototype.onload = function () {};

	Audia.prototype.play = function (currentTime) {
		if (currentTime !== undefined) {
			this.currentTime = currentTime;
		}

		if (this._playing) {
			return;
		}
		this._regenerateBuffer();

		var BUFFER = 0.01; // TODO: gross? hopefully a better way can be found
		var grainDuration = (this._duration - this._currentTime - BUFFER);
		this._source.noteGrainOn(0, this._currentTime, grainDuration);
		this._playing = true;
		this._startTime = audioContext.currentTime;
        
		var sound = this;
        
		this._onendedTimeout = setTimeout(function () {
			sound.onended();
			sound._stop();
			sound.currentTime = 0;
			if (sound.loop) {
				sound.play();
			}
		}, grainDuration * 1000);
	};

	Audia.prototype.pause = function () {
		this._stop();
	};

	Audia.prototype.stop = function () {
		this._stop();
		this._currentTime = 0;
	};

	// "Private" methods

	Audia.prototype._stop = function () {
		if (!this._playing) {
			return;
		}

		if (this._onendedTimeout) {
			clearTimeout(this._onendedTimeout);
			this._onendedTimeout = null;
		}

		this._source.noteOff(0);
		this._expireBuffer();

		this._currentTime += (audioContext.currentTime - this._startTime);
		this._playing = false;
	};

	Audia.prototype._expireBuffer = function () {
		this._source = null;
	};

	Audia.prototype.mute = function () {
		this._muted = true;

		if (this._gain) {
			this._gain.gain.value = 0;
		}
	};

	Audia.prototype.unmute = function () {
		this._muted = false;

		if (this._gain) {
			this._gain.gain.value = this._volume;
		}
	};

	Audia.prototype._regenerateBuffer = function () {
		this.src = this._src;
	};

	return Audia;
}());

}}, []);/* This file has been generated by yabbler.js */
require.define({
"engine/director": function(require, exports, module) {
var gamejs = require('gamejs');

var requestAnimationFrame=(function(fps){
    try{
        window;
    }catch(e){
        return;
    }
    //Check for each browser
    //@paul_irish function
    //Globalises this function to work on any browser as each browser has a different namespace for this
    return  window.requestAnimationFrame       ||  //Chromium 
            window.webkitRequestAnimationFrame ||  //Webkit
            window.mozRequestAnimationFrame    || //Mozilla Geko
            window.oRequestAnimationFrame      || //Opera Presto
            window.msRequestAnimationFrame     || //IE Trident?
            function(callback, element){ //Fallback function
                window.setTimeout(callback, 1000/fps);                
            }
     
})()


var Director = exports.Director = function(display, fps){
    this.on_air = false;
    this.scenes = [];
    this.display = display;
    this.last_t = null;
    this.fps = fps;
    this.tick(0);
};


Director.prototype.push = function(scene){
    this.scenes.push(scene);
};
    
Director.prototype.pop = function(){
    if(this.scenes.length){
        var scene = this.scenes.pop();
        if(scene.destroy) scene.destroy();
        return scene;
    }
    return null;
};

Director.prototype.replace = function(scene){
    this.pop();
    this.push(scene);
};
    
Director.prototype.get_active_scene = function(){
    if(this.scenes.length) return this.scenes[this.scenes.length-1];
    return null;        
}
    
Director.prototype.clear = function(){
    while(this.scenes.length) this.pop();
}
 
Director.prototype.tick= function(t){
    var t = t || (new Date()).getTime();
    var msDuration = t - this.last_t;
    this.last_t = t;
    var active_scene = this.get_active_scene();
    if(active_scene && this.on_air){
        this.tick_logic(msDuration);
        this.tick_render(msDuration);
    }
    
    var dir = this;
    function callback(t){
        dir.tick(t);   
    }
    
    requestAnimationFrame(callback, display._canvas);
}

Director.prototype.tick_logic = function(msDuration){
    var active_scene = this.get_active_scene();
    if (active_scene.handleEvent) {
        var evts = gamejs.event.get();
        var i;
        for(i = 0;i < evts.length;i++){
           active_scene.handleEvent(evts[i]);
        }
    } else {
       // throw all events away
       gamejs.event.get();
    }
    if (active_scene.update) active_scene.update(msDuration);
}
 
Director.prototype.tick_render = function(msDuration){
    var active_scene = this.get_active_scene();
    if(active_scene.draw) active_scene.draw(this.display, msDuration);
}
 
Director.prototype.start = function() {
   this.on_air = true;
};

}}, ["gamejs"]);/* This file has been generated by yabbler.js */
require.define({
"engine/sound": function(require, exports, module) {
var audia = require('./audia');
var Audia = audia.Audia;
var object = require('./object');
var utils = require('./utils');
var gamejs = require('gamejs');
var _sounds = {};

if(audia.supported){ //define class based on condition. SUCK ON THAT STATIC LANGUAGES
    var Sound = exports.Sound = function(filename){
        this.cur = 0;
        this.audios = [];
        for(var i= 0; i< 8; i++){
            this.audios.push(new Audia(filename));
        }
    };
    
    Sound.prototype.play = function(loop){
        var audio = this.audios[this.cur++];
        if(this.cur == 8) this.cur = 0;
        audio.loop = loop ? true : false;
        audio.play();
    };
    
    Sound.prototype.stop = function(){
        this.audios.forEach(function(audio){
            audio.stop(); 
        });
    };
    
} else {
    var Sound = exports.Sound = function(filename){
        this.audio = new gamejs.mixer.Sound(filename);
    };
    
    Sound.prototype.play = function(loop){
        this.audio.play(loop ? true : false);
    };
    
    Sound.prototype.stop = function(){
        this.audio.stop();  
    };
}


var SoundObject = exports.SoundObject = function(pars){
       utils.process_parameters(pars, [ 'filename' , 
                                        ['loop', false],
                                        ['position', null]]);
       SoundObject.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(SoundObject, object.Object);

exports.play = function(filename){
    _sounds[filename].play();
}

SoundObject.prototype.draw = function(renderer){
    var play = false;
    if(this.parameters.position){
        var screen_point = renderer.getScreenPoint(this.parameters.position);
        if(screen_point[0] > 0 && screen_point[0] < renderer.width 
           && screen_point[1] >0 && screen_point[1] < renderer.height){
               play = true;
           }
    } else{
        play = true;
    }
    if(play) _sounds[this.parameters.filename].play(this.parameters.loop);
    this.world.destroy(this);
};

var engine = require('../engine');

engine.register_class(SoundObject);

engine.initialize_sounds = exports.initialize = function(list_of_filenames){
    list_of_filenames.forEach(function(filename){
        _sounds[filename] = new Sound(filename); 
    });
};



}}, ["engine/audia", "engine/object", "engine/utils", "gamejs", "engine"]);/* This file has been generated by yabbler.js */
require.define({
"engine/object": function(require, exports, module) {
var log = require('./logging');
var utils = require('./utils');

/*Base class for in game entities
 * 
 */

var Object = exports.Object = function(parameters){
    var parlist = ['world'];
    this.parameters = utils.process_parameters(parameters, parlist);
    
    this.id = this.parameters.id;
    this.world = this.parameters.world;
    this.world.objects[this.id] = this;
    this._tags = {};
};

Object.prototype.AM_OBJECT = true; //HAHAH IM A DUMBASS. srsly, dont know better way.


Object.prototype.add_tag = function(tag){
    this._tags[tag] = true;
};

Object.prototype.has_tag = function(tag){
    return this._tags[tag] ? true : false;
};

Object.prototype.update = function(ms_duration){
    
};

Object.prototype.draw = function(renderer){
    
};

Object.prototype.on_create = function(){

};

Object.prototype.destroy = function(){
    
};

Object.prototype.die = function(){
    
};



}}, ["engine/logging", "engine/utils"]);/* This file has been generated by yabbler.js */
require.define({
"engine/logging": function(require, exports, module) {
var TYPE_WARNING = exports.TYPE_WARNING = 'warning';
var TYPE_ERROR = exports.TYPE_ERROR = 'error';

var Logger = exports.Logger = function (){
    
};

Logger.prototype.log = function (type, message){
    console.log(type, message);
}

exports.logger = new Logger();

exports.warning = function(message){
    exports.logger.log(TYPE_WARNING, message);
}

exports.error = function(message){
    exports.logger.log(TYPE_ERROR, message);
}

}}, []);/* This file has been generated by yabbler.js */
require.define({
"engine/utils": function(require, exports, module) {
var box2d = require('./box2d');

var vec = exports.vec = function(){
    if(!(arguments.length && arguments[0].hasOwnProperty('x'))){
        if(arguments.length==1) return new box2d.b2Vec2(arguments[0][0], arguments[0][1]);
        else if(arguments.length==2) return new box2d.b2Vec2(arguments[0], arguments[1]);
        else throw "kablooie"
    }else return arguments[0];
};

var arr = exports.arr = function(vect){
    if(vect.hasOwnProperty('x')) return [vect.x, vect.y];
    return vect;
};

exports.process_parameters = function(parameters, parameter_list){
    parameter_list.forEach(function(parameter){
        var name, default_value = undefined;
        if(parameter instanceof Array){
            name = parameter[0];
            if(parameter.length > 1){
                default_value = parameter[1];
            }
        } else {
            name = parameter;
        }
        
        if(!(name in parameters)){
            if(default_value != undefined){
                parameters[name] = default_value;
            } else {
                throw 'Missing parameter: '+name;   
            }
        }
    });
    return parameters;
};

var copy = exports.copy = function(src, dest){
    for(var attr in src) dest[attr] = src[attr];
    return dest;
};
}}, ["engine/box2d"]);/* This file has been generated by yabbler.js */
require.define({
"gamejs": function(require, exports, module) {
var matrix = require('./gamejs/utils/matrix');
var objects = require('./gamejs/utils/objects');

/**
 * @fileoverview This module holds the essential `Rect` and `Surface` classes as
 * well as static methods for preloading assets. `gamejs.ready()` is maybe
 * the most important as it kickstarts your app.
 *
 */

var DEBUG_LEVELS = ['info', 'warn', 'error', 'fatal'];
var debugLevel = 2;

/**
 * set logLevel as string or number
 *   * 0 = info
 *   * 1 = warn
 *   * 2 = error
 *   * 3 = fatal
 *
 * @example
 * gamejs.setLogLevel(0); // debug
 * gamejs.setLogLevel('error'); // equal to setLogLevel(2)
 */
exports.setLogLevel = function(logLevel) {
   if (typeof logLevel === 'string' && DEBUG_LEVELS.indexOf(logLevel)) {
      debugLevel = DEBUG_LEVELS.indexOf(logLevel);
   } else if (typeof logLevel === 'number') {
      debugLevel = logLevel;
   } else {
      throw new Error('invalid logLevel ', logLevel, ' Must be one of: ', DEBUG_LEVELS);
   }
   return debugLevel;
};
/**
 * Log a msg to the console if console is enable
 * @param {String} msg the msg to log
 */
var log = exports.log = function() {

   if (gamejs.worker.inWorker === true) {
      gamejs.worker._logMessage(arguments);
      return;
   }

   // IEFIX can't call apply on console
   var args = Array.prototype.slice.apply(arguments, [0]);
   args.unshift(Date.now());
   if (window.console !== undefined && console.log.apply) {
      console.log.apply(console, args);
   }
};
exports.info = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('info')) {
      log.apply(this, arguments);
   }
};
exports.warn = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('warn')) {
      log.apply(this, arguments);
   }
};
exports.error = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('error')) {
      log.apply(this, arguments);
   }
};
exports.fatal = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('fatal')) {
      log.apply(this, arguments);
   }
};

/**
 * Normalize various ways to specify a Rect into {left, top, width, height} form.
 *
 */
function normalizeRectArguments() {
   var left = 0;
   var top = 0;
   var width = 0;
   var height = 0;

   if (arguments.length === 2) {
      if (arguments[0] instanceof Array && arguments[1] instanceof Array) {
         left = arguments[0][0];
         top = arguments[0][1];
         width = arguments[1][0];
         height = arguments[1][1];
      } else {
         left = arguments[0];
         top = arguments[1];
      }
   } else if (arguments.length === 1 && arguments[0] instanceof Array) {
      left = arguments[0][0];
      top = arguments[0][1];
      width = arguments[0][2];
      height = arguments[0][3];
   } else if (arguments.length === 1 && arguments[0] instanceof Rect) {
      left = arguments[0].left;
      top = arguments[0].top;
      width = arguments[0].width;
      height = arguments[0].height;
   } else if (arguments.length === 4) {
      left = arguments[0];
      top = arguments[1];
      width = arguments[2];
      height = arguments[3];
   } else {
      throw new Error('not a valid rectangle specification');
   }
   return {left: left || 0, top: top || 0, width: width || 0, height: height || 0};
}

/**
 * Creates a Rect. Rects are used to hold rectangular areas. There are a couple
 * of convinient ways to create Rects with different arguments and defaults.
 *
 * Any function that requires a `gamejs.Rect` argument also accepts any of the
 * constructor value combinations `Rect` accepts.
 *
 * Rects are used a lot. They are good for collision detection, specifying
 * an area on the screen (for blitting) or just to hold an objects position.
 *
 * The Rect object has several virtual attributes which can be used to move and align the Rect:
 *
 *   top, left, bottom, right
 *   topleft, bottomleft, topright, bottomright
 *   center
 *   width, height
 *   w,h
 *
 * All of these attributes can be assigned to.
 * Assigning to width or height changes the dimensions of the rectangle; all other
 * assignments move the rectangle without resizing it. Notice that some attributes
 * are Numbers and others are pairs of Numbers.
 *
 * @example
 * new Rect([left, top]) // width & height default to 0
 * new Rect(left, top) // width & height default to 0
 * new Rect(left, top, width, height)
 * new Rect([left, top], [width, height])
 * new Rect(oldRect) // clone of oldRect is created
 *
 * @property {Number} right
 * @property {Number} bottom
 * @property {Number} center
 *
 * @param {Array|gamejs.Rect} position Array holding left and top coordinates
 * @param {Array} dimensions Array holding width and height
 */
var Rect = exports.Rect = function() {

   var args = normalizeRectArguments.apply(this, arguments);

   /**
    * Left, X coordinate
    * @type Number
    */
   this.left = args.left;

   /**
    * Top, Y coordinate
    * @type Number
    */
   this.top = args.top;

   /**
    * Width of rectangle
    * @type Number
    */
   this.width = args.width;

   /**
    * Height of rectangle
    * @type Number
    */
   this.height = args.height;

   return this;
};

objects.accessors(Rect.prototype, {
   /**
    * Bottom, Y coordinate
    * @name Rect.prototype.bottom
    * @type Number
    */
   'bottom': {
      get: function() {
         return this.top + this.height;
      },
      set: function(newValue) {
         this.top = newValue - this.height;
         return;
      }
   },
   /**
    * Right, X coordinate
    * @name Rect.prototype.right
    * @type Number
    */
   'right': {
      get: function() {
         return this.left + this.width;
      },
      set: function(newValue) {
         this.left = newValue - this.width;
      }
   },
   /**
    * Center Position. You can assign a rectangle form.
    * @name Rect.prototype.center
    * @type Array
    */
   'center': {
      get: function() {
         return [this.left + (this.width / 2) | 0,
                 this.top + (this.height / 2) | 0
                ];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left - (this.width / 2) | 0;
         this.top = args.top - (this.height / 2) | 0;
         return;
      }
   },
   /**
    * Top-left Position. You can assign a rectangle form.
    * @name Rect.prototype.topleft
    * @type Array
    */
   'topleft': {
      get: function() {
         return [this.left, this.top];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left;
         this.top = args.top;
         return;
      }
   },
   /**
    * Bottom-left Position. You can assign a rectangle form.
    * @name Rect.prototype.bottomleft
    * @type Array
    */
   'bottomleft': {
      get: function() {
         return [this.left, this.bottom];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left;
         this.bottom = args.top;
         return;
      }
   },
   /**
    * Top-right Position. You can assign a rectangle form.
    * @name Rect.prototype.topright
    * @type Array
    */
   'topright': {
      get: function() {
         return [this.right, this.top];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.right = args.left;
         this.top = args.top;
         return;
      }
   },
   /**
    * Bottom-right Position. You can assign a rectangle form.
    * @name Rect.prototype.bottomright
    * @type Array
    */
   'bottomright': {
      get: function() {
         return [this.right, this.bottom];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.right = args.left;
         this.bottom = args.top;
         return;
      }
   },
   /**
    * Position x value, alias for `left`.
    * @name Rect.prototype.y
    * @type Array
    */
   'x': {
      get: function() {
         return this.left;
      },
      set: function(newValue) {
         this.left = newValue;
         return;
      }
   },
   /**
    * Position y value, alias for `top`.
    * @name Rect.prototype.y
    * @type Array
    */
   'y': {
      get: function() {
         return this.top;
      },
      set: function(newValue) {
         this.top = newValue;
         return;
      }
   }
});

/**
 * Move returns a new Rect, which is a version of this Rect
 * moved by the given amounts. Accepts any rectangle form.
 * as argument.
 *
 * @param {Number|gamejs.Rect} x amount to move on x axis
 * @param {Number} y amount to move on y axis
 */
Rect.prototype.move = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   return new Rect(this.left + args.left, this.top + args.top, this.width, this.height);
};

/**
 * Move this Rect in place - not returning a new Rect like `move(x, y)` would.
 *
 * `moveIp(x,y)` or `moveIp([x,y])`
 *
 * @param {Number|gamejs.Rect} x amount to move on x axis
 * @param {Number} y amount to move on y axis
 */
Rect.prototype.moveIp = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   this.left += args.left;
   this.top += args.top;
   return;
};

/**
 * Return the area in which this Rect and argument Rect overlap.
 *
 * @param {gamejs.Rect} Rect to clip this one into
 * @returns {gamejs.Rect} new Rect which is completely inside the argument Rect,
 * zero sized Rect if the two rectangles do not overlap
 */
Rect.prototype.clip = function(rect) {
   if(!this.collideRect(rect)) {
      return new Rect(0,0,0,0);
   }

   var x, y, width, height;

   // Left
   if ((this.left >= rect.left) && (this.left < rect.right)) {
      x = this.left;
   } else if ((rect.left >= this.left) && (rect.left < this.right)) {
      x = rect.left;
   }

   // Right
   if ((this.right > rect.left) && (this.right <= rect.right)) {
      width = this.right - x;
   } else if ((rect.right > this.left) && (rect.right <= this.right)) {
      width = rect.right - x;
   }

   // Top
   if ((this.top >= rect.top) && (this.top < rect.bottom)) {
      y = this.top;
   } else if ((rect.top >= this.top) && (rect.top < this.bottom)) {
      y = rect.top;
   }

   // Bottom
   if ((this.bottom > rect.top) && (this.bottom <= rect.bottom)) {
     height = this.bottom - y;
   } else if ((rect.bottom > this.top) && (rect.bottom <= this.bottom)) {
     height = rect.bottom - y;
   }
   return new Rect(x, y, width, height);
};

/**
 * Join two rectangles
 *
 * @param {gamejs.Rect} union with this rectangle
 * @returns {gamejs.Rect} rectangle containing area of both rectangles
 */
Rect.prototype.union = function(rect) {
   var x, y, width, height;

   x = Math.min(this.left, rect.left);
   y = Math.min(this.top, rect.top);
   width = Math.max(this.right, rect.right) - x;
   height = Math.max(this.bottom, rect.bottom) - y;
   return new Rect(x, y, width, height);
};

/**
 * Grow or shrink the rectangle size
 *
 * @param {Number} amount to change in the width
 * @param {Number} amount to change in the height
 * @returns {gamejs.Rect} inflated rectangle centered on the original rectangle's center
 */
Rect.prototype.inflate = function(x, y) {
    var copy = this.clone();

    copy.inflateIp(x, y);

    return copy;
}

/**
 * Grow or shrink this Rect in place - not returning a new Rect like `inflate(x, y)` would.
 *
 * @param {Number} amount to change in the width
 * @param {Number} amount to change in the height
 */
Rect.prototype.inflateIp = function(x, y) {
    // Use Math.floor here to deal with rounding of negative numbers the
    // way this relies on.
    this.left -= Math.floor(x / 2);
    this.top -= Math.floor(y / 2);
    this.width += x;
    this.height += y;
}

/**
 * Check for collision with a point.
 *
 * `collidePoint(x,y)` or `collidePoint([x,y])` or `collidePoint(new Rect(x,y))`
 *
 * @param {Array|gamejs.Rect} point the x and y coordinates of the point to test for collision
 * @returns {Boolean} true if the point collides with this Rect
 */
Rect.prototype.collidePoint = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   return (this.left <= args.left && args.left <= this.right) &&
       (this.top <= args.top && args.top <= this.bottom);
};

/**
 * Check for collision with a Rect.
 * @param {gamejs.Rect} rect the Rect to test check for collision
 * @returns {Boolean} true if the given Rect collides with this Rect
 */
Rect.prototype.collideRect = function(rect) {
   return !(this.left > rect.right || this.right < rect.left ||
      this.top > rect.bottom || this.bottom < rect.top);
};

/**
 * @param {Array} pointA start point of the line
 * @param {Array} pointB end point of the line
 * @returns true if the line intersects with the rectangle
 * @see http://stackoverflow.com/questions/99353/how-to-test-if-a-line-segment-intersects-an-axis-aligned-rectange-in-2d/293052#293052
 *
 */
Rect.prototype.collideLine = function(p1, p2) {
   var x1 = p1[0];
   var y1 = p1[1];
   var x2 = p2[0];
   var y2 = p2[1];

   function linePosition(point) {
      var x = point[0];
      var y = point[1];
      return (y2 - y1) * x + (x1 - x2) * y + (x2 * y1 - x1 * y2);
   }

   var relPoses = [[this.left, this.top],
                   [this.left, this.bottom],
                   [this.right, this.top],
                   [this.right, this.bottom]
                  ].map(linePosition);

   var noNegative = true;
   var noPositive = true;
   var noZero = true;
   relPoses.forEach(function(relPos) {
      if (relPos > 0) {
         noPositive = false;
      } else if (relPos < 0) {
         noNegative = false;
      } else if (relPos === 0) {
         noZero = false;
      }
   }, this);

   if ( (noNegative || noPositive) && noZero) {
      return false;
   }
   return !((x1 > this.right && x2 > this.right) ||
            (x1 < this.left && x2 < this.left) ||
            (y1 < this.top && y2 < this.top) ||
            (y1 > this.bottom && y2 > this.bottom)
            );
};

/**
 * @returns {String} Like "[x, y][w, h]"
 */
Rect.prototype.toString = function() {
   return ["[", this.left, ",", this.top, "]"," [",this.width, ",", this.height, "]"].join("");
};

/**
 * @returns {gamejs.Rect} A new copy of this rect
 */
Rect.prototype.clone = function() {
   return new Rect(this);
};

/**
 * A Surface represents a bitmap image with a fixed width and height. The
 * most important feature of a Surface is that they can be `blitted`
 * onto each other.
 *
 * @example
 * new gamejs.Surface([width, height]);
 * new gamejs.Surface(width, height);
 * new gamejs.Surface(rect);
 * @constructor
 *
 * @param {Array} dimensions Array holding width and height
 */
var Surface = exports.Surface = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   var width = args.left;
   var height = args.top;
   // unless argument is rect:
   if (arguments.length == 1 && arguments[0] instanceof Rect) {
      width = args.width;
      height = args.height;
   }
   // only for rotatation & scale
   /** @ignore */
   this._matrix = matrix.identity();
   /** @ignore */
	this._canvas = document.createElement("canvas");
	this._canvas.width = width;
	this._canvas.height = height;
	/** @ignore */
	this._blitAlpha = 1.0;

   /** @ignore */
   this._context = this._canvas.getContext('2d');
   // using exports is weird but avoids circular require
   if (exports.display._isSmoothingEnabled()) {
      this._smooth();
   } else {
      this._noSmooth();
   }
   return this;
};

/** @ignore */
Surface.prototype._noSmooth = function() {
	// disable image scaling
	// see https://developer.mozilla.org/en/Canvas_tutorial/Using_images#Controlling_image_scaling_behavior
	// and https://github.com/jbuck/processing-js/commit/65de16a8340c694cee471a2db7634733370b941c
	this.context.mozImageSmoothingEnabled = false;
   this.context.webkitImageSmoothingEnabled = false;
   return;
};
/** @ignore */
Surface.prototype._smooth = function() {
   this.context.mozImageSmoothingEnabled = true;
   this.context.webkitImageSmoothingEnabled = true;

};

/**
 * Blits another Surface on this Surface. The destination where to blit to
 * can be given (or it defaults to the top left corner) as well as the
 * Area from the Surface which should be blitted (e.g., for cutting out parts of
 * a Surface).
 *
 * @example
 * // blit flower in top left corner of display
 * displaySurface.blit(flowerSurface);
 *
 * // position flower at 10/10 of display
 * displaySurface.blit(flowerSurface, [10, 10])
 *
 * // ... `dest` can also be a rect whose topleft position is taken:
 * displaySurface.blit(flowerSurface, new gamejs.Rect([10, 10]);
 *
 * // only blit half of the flower onto the display
 * var flowerRect = flowerSurface.rect;
 * flowerRect = new gamejs.Rect([0,0], [flowerRect.width/2, flowerRect.height/2])
 * displaySurface.blit(flowerSurface, [0,0], flowerRect);
 *
 * @param {gamejs.Surface} src The Surface which will be blitted onto this one
 * @param {gamejs.Rect|Array} dst the Destination x, y position in this Surface.
 *            If a Rect is given, it's top and left values are taken. If this argument
 *            is not supplied the blit happens at [0,0].
 * @param {gamesjs.Rect|Array} area the Area from the passed Surface which
 *            should be blitted onto this Surface.
 * @param {Number} compositionOperation how the source and target surfaces are composited together; one of: source-atop, source-in, source-out, source-over (default), destination-atop, destination-in, destination-out, destination-over, lighter, copy, xor; for an explanation of these values see: http://dev.w3.org/html5/2dcontext/#dom-context-2d-globalcompositeoperation
 * @returns {gamejs.Rect} Rect actually repainted FIXME actually return something?
 */
Surface.prototype.blit = function(src, dest, area, compositeOperation) {

   var rDest, rArea;

   if (dest instanceof Rect) {
      rDest = dest.clone();
      var srcSize = src.getSize();
      if (!rDest.width) {
         rDest.width = srcSize[0];
      }
      if (!rDest.height) {
         rDest.height = srcSize[1];
      }
    } else if (dest && dest instanceof Array && dest.length == 2) {
      rDest = new Rect(dest, src.getSize());
    } else {
      rDest = new Rect([0,0], src.getSize());
    }
   compositeOperation = compositeOperation || 'source-over';

   // area within src to be drawn
   if (area instanceof Rect) {
      rArea = area;
   } else if (area && area instanceof Array && area.length == 2) {
      var size = src.getSize();
      rArea = new Rect(area, [size[0] - area[0], size[1] - area[1]]);
   } else {
      rArea = new Rect([0,0], src.getSize());
   }

   if (isNaN(rDest.left) || isNaN(rDest.top) || isNaN(rDest.width) || isNaN(rDest.height)) {
      throw new Error('[blit] bad parameters, destination is ' + rDest);
   }

   this.context.save();
   this.context.globalCompositeOperation = compositeOperation;
   // first translate, then rotate
   var m = matrix.translate(matrix.identity(), rDest.left, rDest.top);
   m = matrix.multiply(m, src._matrix);
   this.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
   // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
   this.context.globalAlpha = src._blitAlpha;
   this.context.drawImage(src.canvas, rArea.left, rArea.top, rArea.width, rArea.height, 0, 0, rDest.width, rDest.height);
   this.context.restore();
   return;
};

/**
 * @returns {Number[]} the width and height of the Surface
 */
Surface.prototype.getSize = function() {
   return [this.canvas.width, this.canvas.height];
};

/**
 * Obsolte, only here for compatibility.
 * @deprecated
 * @ignore
 * @returns {gamejs.Rect} a Rect of the size of this Surface
 */
Surface.prototype.getRect = function() {
   return new Rect([0,0], this.getSize());
};

/**
 * Fills the whole Surface with a color. Usefull for erasing a Surface.
 * @param {String} CSS color string, e.g. '#0d120a' or '#0f0' or 'rgba(255, 0, 0, 0.5)'
 * @param {gamejs.Rect} a Rect of the area to fill (defauts to entire surface if not specified)
 */
Surface.prototype.fill = function(color, rect) {
   this.context.save();
   this.context.fillStyle = color || "#000000";
   if ( rect === undefined )
       rect = new Rect(0, 0, this.canvas.width, this.canvas.height);

   this.context.fillRect(rect.left, rect.top, rect.width, rect.height);
   this.context.restore();
   return;
};

/**
 * Clear the surface.
 */
Surface.prototype.clear = function(rect) {
   var size = this.getSize();
   rect = rect || new Rect(0, 0, size[0], size[1]);
   this.context.clearRect(rect.left, rect.top, rect.width, rect.height);
   return;
};

objects.accessors(Surface.prototype, {
   /**
    * @type gamejs.Rect
    */
   'rect': {
      get: function() {
         return this.getRect();
      }
   },
   /**
    * @ignore
    */
   'context': {
      get: function() {
         return this._context;
      }
   },
   'canvas': {
      get: function() {
         return this._canvas;
      }
   }
});

/**
 * @returns {gamejs.Surface} a clone of this surface
 */
Surface.prototype.clone = function() {
  var newSurface = new Surface(this.getRect());
  newSurface.blit(this);
  return newSurface;
};

/**
 * @returns {Number} current alpha value
 */
Surface.prototype.getAlpha = function() {
   return (1 - this._blitAlpha);
};

/**
 * Set the alpha value for the whole Surface. When blitting the Surface on
 * a destination, the pixels will be drawn slightly transparent.
 * @param {Number} alpha value in range 0.0 - 1.0
 * @returns {Number} current alpha value
 */
Surface.prototype.setAlpha = function(alpha) {
   if (isNaN(alpha) || alpha < 0 || alpha > 1) {
      return;
   }

   this._blitAlpha = (1 - alpha);
   return (1 - this._blitAlpha);
};

/**
 * The data must be represented in left-to-right order, row by row top to bottom,
 * starting with the top left, with each pixel's red, green, blue, and alpha components
 * being given in that order for each pixel.
 * @see http://dev.w3.org/html5/2dcontext/#canvaspixelarray
 * @returns {ImageData} an object holding the pixel image data {data, width, height}
 */
Surface.prototype.getImageData = function() {
   var size = this.getSize();
   return this.context.getImageData(0, 0, size[0], size[1]);
};

/**
 * @ignore
 */
exports.display = require('./gamejs/display');
/**
 * @ignore
 */
exports.draw = require('./gamejs/draw');
/**
 * @ignore
 */
exports.event = require('./gamejs/event');
/**
 * @ignore
 */
exports.font = require('./gamejs/font');
/**
 * @ignore
 */
exports.http = require('./gamejs/http');
/**
 * @ignore
 */
exports.image = require('./gamejs/image');
/**
 * @ignore
 */
exports.mask = require('./gamejs/mask');
/**
 * @ignore
 */
exports.mixer = require('./gamejs/mixer');
/**
 * @ignore
 */
exports.sprite = require('./gamejs/sprite');
/**
 * @ignore
 */
exports.surfacearray = require('./gamejs/surfacearray');
/**
 * @ignore
 */
exports.time = require('./gamejs/time');
/**
 * @ignore
 */
exports.transform = require('./gamejs/transform');

/**
 * @ignore
 */
exports.utils = {
   arrays: require('./gamejs/utils/arrays'),
   objects: require('./gamejs/utils/objects'),
   matrix: require('./gamejs/utils/matrix'),
   vectors: require('./gamejs/utils/vectors'),
   math: require('./gamejs/utils/math'),
   uri: require('./gamejs/utils/uri'),
   prng: require('./gamejs/utils/prng'),
   base64: require('./gamejs/utils/base64')
};

/**
 * @ignore
 */
exports.pathfinding = {
   astar: require('./gamejs/pathfinding/astar')
};

/**
 * @ignore
 */
exports.worker = require('./gamejs/worker');

/**
 * @ignore
 */
exports.xml = require('./gamejs/xml');

/**
 * @ignore
 */
exports.tmx = require('./gamejs/tmx');

/**
 * @ignore
 */
exports.noise = require('./gamejs/noise');

// preloading stuff
var gamejs = exports;
var RESOURCES = {};

/**
 * ReadyFn is called once all modules and assets are loaded.
 * @param {Function} readyFn the function to be called once gamejs finished loading
 * @name ready
 */
if (gamejs.worker.inWorker === true) {
   exports.ready = function(readyFn) {
      gamejs.worker._ready();
      gamejs.init();
      readyFn();
   }
} else {
   exports.ready = function(readyFn) {

      var getMixerProgress = null;
      var getImageProgress = null;

      // init time instantly - we need it for preloaders
      gamejs.time.init();

      // 2.
      function _ready() {
         if (!document.body) {
            return window.setTimeout(_ready, 50);
         }
         getImageProgress = gamejs.image.preload(RESOURCES);
         try {
            getMixerProgress = gamejs.mixer.preload(RESOURCES);
         } catch (e) {
            gamejs.debug('Error loading audio files ', e);
         }
         window.setTimeout(_readyResources, 50);
      }

      // 3.
      function _readyResources() {
         if (getImageProgress() < 1 || getMixerProgress() < 1) {
            return window.setTimeout(_readyResources, 100);
         }
         gamejs.display.init();
         gamejs.image.init();
         gamejs.mixer.init();
         gamejs.event.init();
         readyFn();
      }

      // 1.
      window.setTimeout(_ready, 13);

      function getLoadProgress() {
         if (getImageProgress) {
            return (0.5 * getImageProgress()) + (0.5 * getMixerProgress());
         }
         return 0.1;
      }

      return getLoadProgress;
   };
}

/**
 * Initialize all gamejs modules. This is automatically called
 * by `gamejs.ready()`.
 * @returns {Object} the properties of this objecte are the moduleIds that failed, they value are the exceptions
 * @ignore
 */
exports.init = function() {
   var errorModules = {};
   ['time', 'display', 'image', 'mixer', 'event'].forEach(function(moduleName) {
      try {
         gamejs[moduleName].init();
      } catch (e) {
         errorModules[moduleName] = e.toString();
      }
   });
   return errorModules;
}

function resourceBaseHref() {
    return (window.$g && window.$g.resourceBaseHref) || document.location.href;
}

/**
 * Preload resources.
 * @param {Array} resources list of resources paths
 * @name preload
 */
var preload = exports.preload = function(resources) {
   var uri = require('./gamejs/utils/uri');
   var baseHref = resourceBaseHref();
   resources.forEach(function(res) {
      RESOURCES[res] = uri.resolve(baseHref, res);
      console.log('res', baseHref, res, RESOURCES[res]);
   }, this);
   return;
};

}}, ["gamejs/utils/matrix", "gamejs/utils/objects", "gamejs/display", "gamejs/draw", "gamejs/event", "gamejs/font", "gamejs/http", "gamejs/image", "gamejs/mask", "gamejs/mixer", "gamejs/sprite", "gamejs/surfacearray", "gamejs/time", "gamejs/transform", "gamejs/utils/arrays", "gamejs/utils/vectors", "gamejs/utils/math", "gamejs/utils/uri", "gamejs/utils/prng", "gamejs/utils/base64", "gamejs/pathfinding/astar", "gamejs/worker", "gamejs/xml", "gamejs/tmx", "gamejs/noise"]);/* This file has been generated by yabbler.js */
require.define({
"combatracer": function(require, exports, module) {
var gamejs = require('gamejs');
var renderer = require('./renderer');
var utils = require('./utils');
var fonts = gamejs.font;
var levels=require('./levels');
var resources = require('./resources');
var weapons=require('./weapons');
var ui=require('./ui');
var uiscenes=require('./uiscenes');
var settings=require('./settings');
var gamescenes=require('./gamescenes');
var sounds=require('./sounds');
var editor=require('./editor');
var garage=require('./garage');
var engine = require('./engine');

var requestAnimationFrame=(function(){
    //Check for each browser
    //@paul_irish function
    //Globalises this function to work on any browser as each browser has a different namespace for this
    try{
        window;
    } catch(e){
        return;
    }
    
    return  window.requestAnimationFrame       ||  //Chromium 
            window.webkitRequestAnimationFrame ||  //Webkit
            window.mozRequestAnimationFrame    || //Mozilla Geko
            window.oRequestAnimationFrame      || //Opera Presto
            window.msRequestAnimationFrame     || //IE Trident?
            function(callback, element){ //Fallback function
                window.setTimeout(callback, 1000/settings.get('FPS'));                
            }
     
})()

var getDefCarDescr=exports.getDefCarDescr=function(car){
    return {'type':car ? car : 'Sandbug',
            'front_weapon':{'type':'Machinegun',
                            'ammo_upgrades':0,
                            'damage_upgrades':0},
            'util':null,
            'rear_weapon':{'type':'MineLauncher',
                            'ammo_upgrades':0,
                            'damage_upgrades':0},
            'acc_upgrades':0,
            'speed_upgrades':0,
            'armor_upgrades':0}
}

exports.image_filenames = [];
exports.sound_filenames = [];

exports.get_preload_list = function(){
    var retv=new Array();
    var i;
    for(i=0;i<resources.cars.length;i++){
        retv[retv.length]='images/cars/'+resources.cars[i];
    }
    for(i=0;i<resources.tiles.length;i++){
        retv[retv.length]='images/tiles/'+resources.tiles[i];
    }
    for(i=0;i<resources.props.length;i++){
        retv[retv.length]='images/props/'+resources.props[i];
    }
    for(i=0;i<resources.animations.length;i++){
        retv[retv.length]='images/animations/'+resources.animations[i];
    }
    for(i=0;i<resources['statics'].length;i++){
        retv[retv.length]='images/static/'+resources['statics'][i];
    }
    for(i=0;i<resources.ui.length;i++){
        retv[retv.length]='images/ui/'+resources.ui[i];
    }
    
    resources.decals.forEach(function(filename){
        retv.push('images/decals/'+filename); 
    });
    
    exports.image_filenames = retv;
    retv = new Array();
    
    if(settings.get('SOUND')){
        resources.sound_fx.forEach(function(filename){
           retv.push('sounds/fx/'+filename); 
        });
        
        //resources.sound_engine.forEach(function(filename){
         //  retv.push('sounds/engine/'+filename); 
        //});
        
        exports.sound_filenames = retv;
    }
    
    
    return exports.image_filenames.concat(exports.sound_filenames);
};

var Director=exports.Director= function Director (display) {
    var onAir = false;
    var activeScene = null;
    this.display=display;
    var last_t;
 
    function tick(t){
        t=t || (new Date()).getTime();
        msDuration=t-last_t;
        last_t=t;
        if(activeScene){
            tick_logic(msDuration);
            tick_render(msDuration);
        }
        requestAnimationFrame(tick, display._canvas);
    }
 
    function tick_logic(msDuration){
        if (!onAir) return;
        if (activeScene.handleEvent) {
            var evts=gamejs.event.get();
            var i;
            for(i=0;i<evts.length;i++){
               activeScene.handleEvent(evts[i]);
            }
        } else {
           // throw all events away
           gamejs.event.get();
        }
        if (activeScene.update) activeScene.update(msDuration);
    }
 
    function tick_render(msDuration){
        if(activeScene.draw) activeScene.draw(display, msDuration);
    }
 
    this.start = function(scene) {
       onAir = true;
       this.replaceScene(scene);
       return;
    };
 
    this.replaceScene = function(scene) {
        if(activeScene && activeScene.destroy) activeScene.destroy(); 
        activeScene = scene;
    };
 
    this.getScene = function() {
       return activeScene;
    };
    
    tick(0);
    
    
    return this;
};


var Communicator=exports.Communicator=function(game){
    this.game=game;
    this.socket;
    this.next_transaction_id=1;
    this.messages=[];
    this.status='closed';
    

    this.queueMessage=function(cmd, payload){
        /*
        message payload is returned as first argument,
        arg as second payload
        */
        this.messages[this.messages.length]=[cmd, payload ? payload : {}];
        this.send();
    };

    this.send=function(){
        if(this.status=='open'){
            for(var i=0;i<this.messages.length;i++){
                var msg={'cmd':this.messages[i][0],
                         'uid':this.game.player.uid,
                         'payload':this.messages[i][1]};
                msg=JSON.stringify(msg);
                //gamejs.log('sending ', msg);
                this.socket.send(msg);
               // console.log('sent '+msg);
            }
            this.messages=[];
        }else if (this.status=='closed'){
            this.connect();
        }else{
            throw new Error('unknown network status');
        }
    };

    this.connect=function(){
        gamejs.log('Connecting...');
        this.socket = new WebSocket(settings.get('SERVER'), 'banditracer');
        this.status='connecting';
        var self=this;
        this.socket.onopen = function() {self.onopen();};
        this.socket.onmessage = function(m) {self.onmessage(m);};
        this.socket.onclose = function() {self.onclose();};
        this.socket.onerror = function() {self.onerror();};
    };

    this.onopen=function(){
        gamejs.log('Connection established!');
        this.status='open';
        this.send();
    };

    this.onmessage=function(m){
       // console.log('recv '+m.data);
        m=JSON.parse(m.data);
        this.game.director.getScene().handleMessage(m.cmd, m.payload);
    };

    this.onclose=function(){
        this.status='closed';
        console.log(this.error ? 'socket closed on error ' : 'socket closed!');
        this.game.aquainted=false;
        this.game.showTitle();
        this.game.player.uid=null;
        this.game.title_scene.alert(this.error ? 'Socket error, connection closed.' : 'Server closed the connection!');
        this.error=false;
    };

    this.error=false;

    this.onerror=function(){
        this.socket.close();
        this.error=true;
    };
};

exports.init = function() {
    exports.game=new Game();
    return exports.game;
};

var Game = exports.Game = function(){
    this.director=null;
    this.cache=renderer.init();
    if(settings.get('SOUND')){
        engine.initialize_sounds(exports.sound_filenames);
        sounds.init();
    } 
    ui.init();
    this.socket=null;
    this.tried_loading=false;
    this.player={'alias':'Player',
                 'uid':null,
                 'singleplayer':{
                    'balance':settings.get('STARTING_BALANCE'),
                    'difficulty':2,
                    'car':getDefCarDescr(),
                    'league':settings.get('STARTING_LEAGUE'),
                    'completed':false,
                    'completed_tracks':[]
                    }
                };

    this.communicator=null;
    this.acquainted=false; //receved a player id from server?

    this.getCommunicator = function(){
         if(!this.communicator)this.communicator=new Communicator(this);
         return this.communicator;
    };

    this.start = function(display){
        this.display=display;
        this.director=new Director(display);
        this.title_scene=new uiscenes.TitleScene(this, this.cache);
        this.director.start(this.title_scene);
        //this.playLevel(levels.drycircuit, false, true);
    };

    this.showEndGameScene=function(position){
         this.director.replaceScene(new uiscenes.EndRaceScene(this, this.cache, position));
    };

    this.showTitle=function(){
       this.director.replaceScene(this.title_scene);
    };
    
    this.showCongratulations=function(){
        this.director.replaceScene(new uiscenes.CongratulationsScene());
    };

    this.createLobby=function(){
         this.director.replaceScene(new uiscenes.CreateLobbyScene(this, this.cache));
    };

    this.showLobbyList=function(){
         this.director.replaceScene(new uiscenes.JoinLobbyScene(this, this.cache));
    };
    
    this.returnTo=function(){
        if(this.return_to){
            if(this.return_to=='editor'){
                this.return_to='';
                this.showEditor();
                return;
            }
            else if(this.return_to=='singleplayer'){
                this.return_to='';
                this.singleplayer();
                return;
            }
        
        }
        this.showTitle();
        return;
    };

    this.showSPGameOver=function(table, win, scene){
        this.director.replaceScene(new uiscenes.SPGameOverScene(table, win, scene));
    };
    
    this.showEditor=function(){
        if(!this.editor_scene)this.editor_scene= new editor.EditorScene()
        this.director.replaceScene(this.editor_scene);  
    };

    this.joinLobby=function(lobby_id){
        this.director.replaceScene(new uiscenes.LobbyScene(this, this.cache, lobby_id));
    };
    
    this.singleplayer=function(){
         this.director.replaceScene(new uiscenes.SinglePlayerScene(this, this.cache));
    };
    
    this.showGarage=function(player_data){
        this.director.replaceScene(new garage.GarageScene(player_data));
    };
    
    this.showCarDealer=function(player_data){
        this.director.replaceScene(new garage.BuyCarScene(player_data));
    };
    
    //singleplayer garage
    this.showSPGarage=function(){
        this.director.replaceScene(new garage.GarageScene(this.player.singleplayer));
    };

    this.playMultiplayer=function(level){
        this.level_scene=new gamescenes.MultiplayerLevelScene(this, level, this.cache);
        this.director.replaceScene(this.level_scene);
    };

    this.playLevel=function(level, ai_test, return_to){
         this.level_scene=new gamescenes.SingleplayerLevelScene(level, ai_test);
         this.return_to=return_to;
         this.director.replaceScene(new uiscenes.ControlsSplash(this, this.cache, this.level_scene));
    };
    
    this.cacheCarSprites=function(level){
        this.cache.cacheCarSprite('wheel.png');
        this.cache.cacheCarSprite('big_wheel.png');
        level.controllers.forEach(function(controller){
            var car = controller.car;
            this.cache.cacheCarSprite(car.filename);
            ([car.front_weapon, car.rear_weapon, car.util]).forEach(function(weapon){
                if(weapon && weapon.pars.preload){
                    weapon.pars.preload.forEach(function(filename){
                        this.cache.cacheCarSprite(filename);
                    }, this);
                }
            }, this);
        }, this);
    };
    
    this.haveSave=function(){
        if(utils.supports_html5_storage()){
            if(localStorage.getItem('banditracer_save')) return true;
        }
        return false;
    };
    
    this.load=function(){
        if(utils.supports_html5_storage() && localStorage.getItem('banditracer_save')){
            var data = JSON.parse(localStorage.getItem('banditracer_save'));
            this.player.alias = data.alias;
            this.player.singleplayer = data.singleplayer;
            if(!this.player.singleplayer.difficulty)this.player.singleplayer.difficulty = 2;
            return true;
        }
        return false;
    };
    
    this.save=function(){
        if(utils.supports_html5_storage()){
            var data=JSON.stringify({'alias':this.player.alias,
                             'singleplayer':this.player.singleplayer});
            localStorage.setItem('banditracer_save', data);
            return true;
        }
        return false;
    };
};

}}, ["gamejs", "renderer", "utils", "levels", "resources", "weapons", "ui", "uiscenes", "settings", "gamescenes", "sounds", "editor", "garage", "engine"]);/* This file has been generated by yabbler.js */
require.define({
"buffs": function(require, exports, module) {
var gamejs = require('gamejs');
var animation = require('./animation');
var utils = require('./utils');
var engine = require('./engine');
var vec=utils.vec;
var arr=utils.arr;

var EFFECT_NO_GRIP = exports.EFFECT_NO_GRIP = 'no_grip';
var EFFECT_ENGINE = exports.EFFECT_ENGINE = 'engine';
var EFFECT_INVULNERABLE = exports.EFFECT_INVULNERABLE = 'invulnerable';

var Buff = exports.Buff=function(pars){
    Buff.superConstructor.apply(this, [pars]);
    this.age = 0;
    this.duration = pars.duration ? pars.duration : null;
    this.effect = pars.effect;
    this.value = pars.value;
    this.object = pars.object;
    this.object.buffs.push(this);
};

gamejs.utils.objects.extend(Buff, engine.Object);

Buff.prototype.update = function(msDuration){
    this.age += msDuration;
    if(this.age > this.duration){
        this.world.destroy(this);
    }
};

Buff.prototype.die = function(){
    for(var i=0; i < this.object.buffs.length; i++) {
        if(this.object.buffs[i].id == this.id) {
            this.object.buffs.splice(i, 1);
            break;
        }
    }
};

Buff.prototype.process_hit = function(damage, owner){
	//return false to not register hit
	return true;
};

var EngineBuff = exports.EngineBuff=function(pars){
    pars.effect = EFFECT_ENGINE;
    EngineBuff.superConstructor.apply(this, [pars]);
};
gamejs.utils.objects.extend(EngineBuff, Buff);
engine.register_class(EngineBuff);

var SlipDebuff = exports.SlipDebuff=function(pars){
    pars.effect = EFFECT_NO_GRIP;
    SlipDebuff.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(SlipDebuff, Buff);
engine.register_class(SlipDebuff);

var InvulnerabilityBuff = exports.InvulnerabilityBuff = function(pars){
	pars.effect = EFFECT_INVULNERABLE;
	pars.duration=1;
	this.hits_left = 3;
	InvulnerabilityBuff.superConstructor.apply(this, [pars]);
	this.animation = new animation.Animation({'filename':'forcefield.png',
											  'duration':1000,
											  'repeat':true});
};

gamejs.utils.objects.extend(InvulnerabilityBuff, Buff);
engine.register_class(InvulnerabilityBuff);

InvulnerabilityBuff.prototype.update = function(msDuration){
	this.animation.update(msDuration);
};

InvulnerabilityBuff.prototype.process_hit = function(damage, owner){
	this.hits_left--;
	if(this.hits_left == 0){
		this.world.destroy(this);
	}
	return false;
};

InvulnerabilityBuff.prototype.draw = function(renderer){
	this.animation.draw(renderer, this.object.get_position());
};

}}, ["gamejs", "animation", "utils", "engine"]);